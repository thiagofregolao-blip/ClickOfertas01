=== C√ìDIGO COMPLETO DO ASSISTENTE CLICK ===
Data de gera√ß√£o: 2025-09-26

Este arquivo cont√©m o c√≥digo completo do endpoint SSE Streaming do assistente do Click Ofertas 
com todas as funcionalidades implementadas:

- ‚úÖ Sistema anti-corrida com requestId
- ‚úÖ Detec√ß√£o de inten√ß√£o (SMALL_TALK, SEARCH, MORE)  
- ‚úÖ Streaming real com efeito "digitando"
- ‚úÖ Persona interativa "Clique" (vendedor masculino)
- ‚úÖ Hard Grounding (anti-alucina√ß√£o)
- ‚úÖ Cache inteligente + cross-sell de acess√≥rios
- ‚úÖ JSON schema valida√ß√£o + fallback robusto

===============================================================================

// SSE Streaming endpoint for assistant chat - Now with RAG and Memory
app.post('/api/assistant/stream', async (req: any, res) => {
  try {
    const { sessionId, message } = req.body || {};
    if (!message?.trim()) return res.status(400).json({ ok:false, error:'message required' });

    const session = await storage.getAssistantSession(sessionId);
    if (!session) return res.status(404).json({ ok:false, error:'session not found' });

    // Buscar nome real do usu√°rio autenticado
    const user = req.user || req.session?.user;
    let name = 'Cliente';
    if (user?.id) {
      try {
        const userData = await storage.getUser(user.id);
        if (userData?.firstName) {
          name = userData.firstName;
          if (userData.lastName) {
            name += ` ${userData.lastName}`;
          }
        }
      } catch (error) {
        console.warn('Could not fetch user name:', error);
      }
    }

    // Salvar mensagem do usu√°rio ANTES de processar
    await storage.createAssistantMessage({
      sessionId,
      content: message,
      role: 'user',
      metadata: { timestamp: new Date().toISOString() },
    });

    // Buscar hist√≥rico de mensagens para contexto
    const sessionWithMessages = await storage.getAssistantSessionWithMessages(sessionId);
    const recentMessages = (sessionWithMessages?.messages || [])
      .slice(-6) // √öltimas 6 mensagens para contexto
      .map(msg => ({
        role: msg.role as 'user' | 'assistant',
        content: msg.content
      }));

    // üÜî ANTI-CORRIDA: Gerar requestId √∫nico
    const requestId = `${Date.now()}-${Math.random().toString(36).slice(2,8)}`;
    
    res.writeHead(200, { 'Content-Type':'text/event-stream', 'Cache-Control':'no-cache', 'Connection':'keep-alive' });
    const write = (d:any)=> res.write(`data: ${JSON.stringify({...d, requestId})}\n\n`);
    
    // Enviar meta com requestId primeiro
    write({ type:'meta', requestId });

    // üß† DETEC√á√ÉO DE INTEN√á√ÉO antes da busca
    console.log(`üé¨ [assistant/stream] Processando: "${message}" para usu√°rio: ${name}`);
    
    const { buildGrounding, composePrompts, detectIntent } = await import('./lib/answerComposer.js');
    const intent = detectIntent(message);
    
    console.log(`üß† [assistant/stream] Inten√ß√£o detectada: ${intent}`);
    
    // üé™ SMALL TALK: Resposta direta sem busca de produtos
    if (intent === 'SMALL_TALK') {
      console.log(`üí¨ [assistant/stream] Small talk detectado - resposta direta`);
      
      const smallTalkSystem = `Voc√™ √© o "Clique", consultor virtual do Click Ofertas. Seja simp√°tico, breve e humano. Responda √† pergunta pessoal feita pelo usu√°rio de forma natural e encaminhe para ajudar com compras. Use humor leve e emoji ocasional.`;
      
      const smallTalkResponse = await clickClient.chat.completions.create({
        model: process.env.CHAT_MODEL || 'gpt-4o-mini',
        messages: [
          { role: 'system', content: smallTalkSystem },
          { role: 'user', content: message }
        ],
        temperature: 0.7,
        max_tokens: 150
      });

      const smallTalkText = smallTalkResponse.choices[0].message.content;
      write({ type:'chunk', text: smallTalkText });
      write({ type:'message', content: smallTalkText });
      
      await storage.createAssistantMessage({ 
        sessionId, 
        content: smallTalkText, 
        role:'assistant', 
        metadata:{ 
          streamed: true, 
          intent: 'SMALL_TALK',
          noProductSearch: true,
          requestId
        } 
      });
      
      write({ type:'end' });
      res.end();
      return; // ‚ö†Ô∏è EARLY RETURN - N√ÉO CONTINUA PARA BUSCA
    }
    
    // ‚ù∂ RAG melhorado: busca produtos apenas para SEARCH e MORE
    const origin = `${req.protocol}://${req.get('host')}`;
    const ground = await buildGrounding(origin, message, sessionId);
    
    console.log(`üìä [assistant/stream] Resultado buildGrounding:`, {
      all: ground.all.length,
      top3: ground.top3.length,
      top8: ground.top8.length
    });
    
    // ‚ùÇ Sistema de aprendizado: registrar busca do usu√°rio
    try {
      await storage.createSearchLog({
        sessionId,
        userId: user?.id || null,
        query: message.toLowerCase().trim(),
        foundProducts: ground.all.length,
        timestamp: new Date(),
        metadata: { 
          hasMultipleStores: new Set(ground.all.map(p => p.storeName).filter(Boolean)).size > 1,
          categories: [...new Set(ground.all.map(p => p.category).filter(Boolean))]
        }
      });
    } catch (error) {
      console.warn('Erro ao registrar busca para aprendizado:', error);
    }
    
    // üß† INTELIG√äNCIA DE VENDAS: gerar recomenda√ß√µes autom√°ticas se h√° produto em foco
    let focusedProduct = null;
    let recommendations = null;
    
    if (ground.contextType === 'focused_product' && ground.sessionMemory?.currentFocusProductId) {
      const focusId = ground.sessionMemory.currentFocusProductId;
      focusedProduct = ground.sessionMemory.lastShownProducts?.find(p => p.id === focusId);
      
      if (focusedProduct) {
        console.log(`üéØ [assistant/stream] Produto em foco detectado: "${focusedProduct.title}"`);
        
        // Importar sistema de recomenda√ß√µes
        const { getProductRecommendations } = await import('./lib/tools.js');
        
        try {
          recommendations = await getProductRecommendations(focusedProduct);
          console.log(`üí° [assistant/stream] Recomenda√ß√µes geradas:`, {
            upsells: recommendations.upsells?.length || 0,
            crossSells: recommendations.crossSells?.length || 0,
            total: recommendations.all?.length || 0
          });
        } catch (error) {
          console.error('‚ùå [assistant/stream] Erro ao gerar recomenda√ß√µes:', error);
          recommendations = { upsells: [], crossSells: [], all: [] };
        }
      }
    }

    const promptResult = composePrompts({
      q: message, name, top3: ground.top3, top8: ground.top8,
      focusedProduct, recommendations
    });
    
    const { SYSTEM, USER, productSet, requiresJsonOutput } = promptResult;
    
    console.log(`üí≠ [assistant/stream] Prompts gerados:`, {
      systemLength: SYSTEM.length,
      userLength: USER.length,
      hasProducts: productSet?.length > 0,
      requiresJson: !!requiresJsonOutput,
      productSetIds: productSet?.map(p => p.id) || []
    });

    // üîß POL√çTICA SEM CAT√ÅLOGO = SEM RESPOSTA DE PRODUTO
    if (!productSet || productSet.length === 0) {
      console.log(`‚ö†Ô∏è [assistant/stream] ProductSet vazio - enviando apenas mensagem de refinamento`);
      
      // Resposta simples sem produtos
      const refinementMessage = "N√£o encontrei produtos para essa busca. Que tal tentar ser mais espec√≠fico? Pode informar categoria (ex: drone, perfume), marca ou faixa de pre√ßo?";
      
      // Enviar mensagem diretamente
      write({ type:'chunk', text: refinementMessage });
      
      await storage.createAssistantMessage({ 
        sessionId, 
        content: refinementMessage, 
        role:'assistant', 
        metadata:{ 
          streamed: true, 
          hardGrounding: true, 
          productSetEmpty: true 
        } 
      });
      
      write({ type:'end' });
      res.end();
      return;
    }

    // ‚ù∑ Construir mensagens com hist√≥rico para mem√≥ria
    const messages = [
      { role:'system' as const, content: SYSTEM },
      // Incluir mensagens anteriores para contexto (excluindo a atual que j√° foi salva)
      ...recentMessages.slice(0, -1),
      { role:'user' as const, content: USER }
    ];

    // ‚ùÉ Hard Grounding: LLM deve retornar JSON estruturado
    let llmResponse = '';
    
    if (requiresJsonOutput) {
      console.log(`üîß [assistant/stream] Usando STREAMING REAL com Hard Grounding`);
      
      // üìù PERSONA INTERATIVA - Sistema que sempre engaja
      const interactiveSystem = `Voc√™ √© o "Clique", consultor virtual masculino do Click Ofertas. Simp√°tico, vendedor esperto com humor leve.

REGRAS CR√çTICAS:
1) Mencione SOMENTE produtos do user content fornecido (n√£o invente nada)
2) Seja breve, natural, PT-BR coloquial
3) SEMPRE termine com UMA pergunta de continuidade (marca preferida? or√ßamento? cidade?)
4) Foque em ajudar o cliente a decidir
5) Use tom confiante e prestativo

Tom: Amig√°vel, direto, engajado`;

      // ‚ö° STREAMING: Resposta em tempo real
      const streamResponse = await clickClient.chat.completions.create({
        model: process.env.CHAT_MODEL || 'gpt-4o-mini',
        messages: [
          { role:'system', content: interactiveSystem },
          ...recentMessages.slice(0, -1),
          { role:'user', content: USER }
        ],
        stream: true,
        temperature: 0.7,
        max_tokens: 250
      });

      let fullStreamText = '';
      
      // üåä STREAMING: Enviar deltas em tempo real
      for await (const chunk of streamResponse) {
        const content = chunk.choices[0]?.delta?.content || '';
        if (content) {
          fullStreamText += content;
          write({ type: 'delta', text: content }); // ‚ö° EFEITO DIGITANDO
        }
      }

      llmResponse = fullStreamText;
      write({ type: 'paragraph_done' });
      
      // üîß JSON ESTRUTURADO: Gerar separadamente para valida√ß√£o
      const jsonResponse = await clickClient.chat.completions.create({
        model: process.env.CHAT_MODEL || 'gpt-4o-mini',
        messages: [
          { role: 'system', content: `IMPORTANTE: Retorne JSON v√°lido no formato EXATO:
{
  "items": [
    {"id": "produto_id", "why": "raz√£o curta"}
  ],
  "message": "texto da resposta"
}

Use somente estes IDs v√°lidos: ${productSet.map(p => p.id).slice(0,3).join(', ')}...

JAMAIS use "produtos", "nome" ou outros campos. Sempre "items" e "why".` },
          { role: 'user', content: `Produtos mencionados na conversa: "${llmResponse}"

IDs v√°lidos:
${productSet.map(p => `- ${p.id}: ${p.title}`).slice(0,3).join('\n')}...` }
        ],
        temperature: 0.1,
        max_tokens: 200
      });

      const rawJson = jsonResponse.choices[0].message.content;
      console.log(`üì¶ [assistant/stream] JSON estruturado gerado:`, rawJson);

      try {
        const parsedResponse = JSON.parse(rawJson || '{}');
        const { items = [], message = '' } = parsedResponse;
        
        // üîß VALIDA√á√ÉO SERVIDOR-SIDE: s√≥ aceitar IDs do productSet
        const allowedIds = new Set(productSet.map(p => p.id));
        const validItems = items.filter(item => allowedIds.has(item.id));
        
        console.log(`‚úÖ [assistant/stream] Valida√ß√£o JSON com Streaming:`, {
          itemsReceived: items.length,
          validItems: validItems.length,
          allowedIds: [...allowedIds],
          receivedIds: items.map(i => i.id),
          streamedText: fullStreamText.length
        });
        
        // ‚ùπ Enviar produtos validados com metadados enriquecidos
        if (validItems.length > 0) {
          const enrichedProducts = validItems.map(item => {
            const product = productSet.find(p => p.id === item.id);
            if (!product) return null;
            
            // Validar upsellIds tamb√©m
            const validUpsells = (item.upsellIds || [])
              .filter(upsellId => allowedIds.has(upsellId))
              .map(upsellId => productSet.find(p => p.id === upsellId))
              .filter(Boolean);
            
            return {
              ...product,
              name: product.title,
              reason: item.reason || 'Produto recomendado',
              upsells: validUpsells,
              cliqueRecommended: true // Marca da nova persona
            };
          }).filter(Boolean);
          
          console.log(`üì¶ [assistant/stream] Enviando ${enrichedProducts.length} produtos do Clique:`, {
            withReasons: enrichedProducts.filter(p => p.reason).length,
            withUpsells: enrichedProducts.filter(p => p.upsells.length > 0).length
          });
          
          write({ 
            type: 'products', 
            products: enrichedProducts,
            query: message,
            validationApplied: true,
            hardGrounding: true,
            cliquePersona: true,
            schemaVersion: 2
          });
        } else {
          console.log(`‚ö†Ô∏è [assistant/stream] Nenhum produto v√°lido ap√≥s valida√ß√£o`);
        }
        
      } catch (error) {
        console.error(`‚ùå [assistant/stream] Erro ao parsear JSON do LLM:`, error);
        console.log(`üîß [assistant/stream] JSON bruto que falhou:`, rawJson);
        
        // üöë FALLBACK: usar produtos do productSet mesmo com JSON quebrado
        const fallbackProducts = productSet.slice(0, 3).map(product => ({
          ...product,
          name: product.title,
          reason: 'Produto selecionado pelo Clique',
          upsells: [],
          cliqueRecommended: true
        }));
        
        console.log(`üöë [assistant/stream] Usando fallback com ${fallbackProducts.length} produtos`);
        
        write({ 
          type: 'products', 
          products: fallbackProducts,
          query: llmResponse,
          validationApplied: false,
          hardGrounding: true, // Ainda usa produtos reais
          jsonParseFailed: true,
          schemaVersion: 2
        });
      }
      
    } else {
      // ‚ù∏ Fallback: modo antigo (n√£o deveria ser usado mais)
      console.log(`‚ö†Ô∏è [assistant/stream] Usando modo antigo (n√£o recomendado)`);
      
      const stream = await clickClient.chat.completions.create({
        model: process.env.CHAT_MODEL || 'gpt-4o-mini',
        messages,
        temperature: 0.15,
        max_tokens: 220,
        frequency_penalty: 0.3,
        presence_penalty: 0.0,
        stream: true
      });

      let full=''; const LIMIT=600;
      
      for await (const part of stream){
        const t = part.choices?.[0]?.delta?.content || '';
        if (!t) continue;
        
        const over = full.length + t.length - LIMIT;
        let piece = over>0 ? t.slice(0, t.length - over) : t;
        
        const newLines = (full + piece).split('\n').length - 1;
        if (newLines >= 4) {
          const lines = (full + piece).split('\n');
          if (lines.length > 4) {
            const fourLines = lines.slice(0, 4).join('\n');
            piece = fourLines.substring(full.length);
            full += piece;
            write({ type:'chunk', text: piece });
            break;
          }
        }
        
        full += piece; 
        write({ type:'chunk', text: piece });
        if (over>0) break;
      }
      
      llmResponse = full;
      
      // Enviar produtos do modo antigo
      const productsToSend = (ground.top8?.length > 0 ? ground.top8 : ground.top3 || []).map(product => ({
        ...product,
        name: product.title,
      }));
      
      if (productsToSend.length > 0) {
        write({ 
          type: 'products', 
          products: productsToSend,
          query: message,
          focusedProduct,
          recommendations,
          hardGrounding: false
        });
      }
    }
    
    await storage.createAssistantMessage({ 
      sessionId, 
      content: llmResponse, 
      role:'assistant', 
      metadata:{ 
        streamed: true, 
        hardGrounding: !!requiresJsonOutput,
        hasProducts: productSet?.length > 0 
      } 
    });
    
    write({ type:'end' }); 
    res.end();
  } catch (e) {
    console.error('stream', e);
    res.write(`data: ${JSON.stringify({ type:'error', message:'stream error' })}\n\n`); res.end();
  }
});

===============================================================================

PRINCIPAIS FUNCIONALIDADES IMPLEMENTADAS:

üÜî SISTEMA ANTI-CORRIDA:
- RequestId √∫nico por request
- Frontend filtra events por requestId  
- Evita responses antigas sobrescrever novas

üß† DETEC√á√ÉO DE INTEN√á√ÉO:
- SMALL_TALK: resposta direta sem busca
- SEARCH: busca normal de produtos  
- MORE: busca adicional/pagination

‚ö° STREAMING REAL:
- Deltas incrementais em tempo real
- Efeito "digitando" no frontend
- Paragraph_done para finalizar par√°grafos

üë®‚Äçüíº PERSONA "CLIQUE":
- Vendedor masculino simp√°tico
- Sempre faz pergunta de continuidade
- Tom confiante e prestativo

üîê HARD GROUNDING:
- JSON schema valida√ß√£o rigorosa
- S√≥ aceita IDs do productSet
- Fallback robusto em caso de erro JSON

üõçÔ∏è CROSS-SELL + CACHE:
- Acess√≥rios buscados em paralelo
- Cache inteligente 120s
- Performance otimizada

üéØ INTELIG√äNCIA DE VENDAS:
- Sistema de recomenda√ß√µes
- Produto em foco + upsells
- Mem√≥ria conversacional

===============================================================================

ARQUIVO GERADO EM: 2025-09-26 10:37:XX
LOCAL: assistente-click-completo.txt (raiz do projeto)