Bora deixar o assistente vendedor, bem-humorado e pr√≥-ativo ‚Äî com perguntas inteligentes e cross-sell (capinha, pel√≠cula, carregador etc.). Segue patch modular (TypeScript) pra plugar no que voc√™ j√° tem.

1) Persona e tom
// src/persona/salesPersona.ts
export type HumorLevel = "suave" | "medio" | "alto";

export interface PersonaConfig {
  nome: string;
  humor: HumorLevel;
  emojiPack: string[];
  tuteia: boolean; // falar "voc√™" de forma mais pr√≥xima
}

export const SalesPersona: PersonaConfig = {
  nome: "Gemini Assistant",
  humor: "medio",
  emojiPack: ["üòâ", "üòÑ", "üõçÔ∏è", "‚ú®", "üì¶", "üöÄ"],
  tuteia: true,
};

// util p/ escolher varia√ß√µes
export function pick<T>(arr: T[], seed?: number): T {
  return arr[(seed ?? Math.floor(Math.random() * arr.length)) % arr.length];
}

2) Templates de respostas (varia√ß√µes + placeholders)
// src/nlg/templates.ts
import { PersonaConfig, pick } from "../persona/salesPersona";

type Dict<T> = Record<string, T>;

export interface MsgCtx {
  persona: PersonaConfig;
  produto?: string;
  categoria?: string;
  modelo?: string;
  marca?: string;
  count?: number;
  faltando?: Array<"modelo" | "marca" | "armazenamento">;
  acessorios?: string[];
}

const greet: string[] = [
  "Oi! {emoji} Bora achar a melhor oferta pra voc√™?",
  "E a√≠! {emoji} Me diz o que procura que eu garimpo aqui.",
  "Bem-vindo(a)! {emoji} Posso buscar por iPhone, drone, perfume e muito mais."
];

const found: string[] = [
  "√ìtimo! Encontrei {count} {cat} para ‚Äú{query}‚Äù. D√° uma olhada üëá",
  "Boa escolha! Separei {count} op√ß√µes de {cat} pra ‚Äú{query}‚Äù. {emoji}",
  "{emoji} Achei {count} resultado(s) que combinam com ‚Äú{query}‚Äù."
];

const noResults: string[] = [
  "Hmm, n√£o achei nada pra ‚Äú{query}‚Äù. {emoji} Quer tentar outra marca ou modelo?",
  "Por aqui n√£o rolou com ‚Äú{query}‚Äù. Tenta especificar {hint} que eu encontro rapidinho!",
  "Zerado pra ‚Äú{query}‚Äù. {emoji} Se quiser, me diz {hint}."
];

const clarify: Dict<string[]> = {
  modelo: [
    "Prefere {produto} **{lista}**?",
    "Tem algum {produto} **{lista}** em mente?",
    "Quer ir de **{lista}** no {produto}?"
  ],
  marca: [
    "Curte **Apple**, **Samsung** ou outra marca?",
    "Tem marca preferida? (Apple, Samsung, Xiaomi‚Ä¶)",
    "Posso filtrar por marca: **Apple**/**Samsung**/**Motorola**?"
  ],
  armazenamento: [
    "Busca **64GB**, **128GB** ou **256GB**?",
    "Qual capacidade agrada mais: **128GB**/**256GB**?",
    "Quer espa√ßo de **128GB** ou **256GB**?"
  ]
};

const crossSell: Dict<string[]> = {
  celular: [
    "Aproveita e j√° quer **capinha** e **pel√≠cula**? Posso sugerir kits.",
    "Quer incluir **carregador turbo** ou **fones BT** junto? {emoji}",
    "Precisa de **cabo extra** ou **power bank** pra completar?"
  ],
  drone: [
    "Pra drone, **bateria extra** e **h√©lices sobressalentes** salvam o dia. Te mostro?",
    "Quer um **case r√≠gido** ou **cart√£o SD** junto? {emoji}",
    "Posso sugerir **protetor de h√©lices** e **hub de carga**."
  ],
  perfume: [
    "Curte **kit presente** com n√©cessaire? {emoji}",
    "Prefere **EDT** ou **EDP**? Posso sugerir ambos.",
    "Quer ver **miniaturas** pra viagem junto?"
  ],
  tv: [
    "Que tal uma **soundbar** pra completar? {emoji}",
    "Precisa de **suporte de parede** ou **cabo HDMI**?",
    "Posso sugerir **controle universal** e **extens√£o filtrada**."
  ]
};

export function tGreet(ctx: MsgCtx) {
  return pick(greet)
    .replace("{emoji}", pick(ctx.persona.emojiPack));
}

export function tFound(ctx: MsgCtx & { query: string }) {
  const cat = ctx.categoria ?? ctx.produto ?? "itens";
  return pick(found)
    .replace("{count}", String(ctx.count ?? 0))
    .replace("{cat}", cat)
    .replace("{query}", ctx.modelo ? `${ctx.produto} ${ctx.modelo}` : ctx.produto ?? ctx.categoria ?? ctx.marca ?? "produto")
    .replace("{emoji}", pick(ctx.persona.emojiPack));
}

export function tNoResults(ctx: MsgCtx & { query: string }) {
  const need = ctx.faltando?.[0] ?? "mais detalhes";
  const hint = need === "modelo" ? "o **modelo** (ex.: 12, 13 Pro)" :
              need === "marca" ? "a **marca** (ex.: Apple, Samsung)" :
              "a **capacidade** (ex.: 128GB)";
  return pick(noResults)
    .replace("{query}", ctx.produto ?? ctx.categoria ?? ctx.marca ?? "termo")
    .replace("{hint}", hint)
    .replace("{emoji}", pick(ctx.persona.emojiPack));
}

export function tClarify(ctx: MsgCtx) {
  if (!ctx.faltando?.length) return null;
  const q = ctx.faltando[0];
  const base = pick(clarify[q]);
  const lista =
    q === "modelo" ? "12, 13, 15‚Ä¶" :
    q === "marca" ? "Apple, Samsung, Xiaomi‚Ä¶" :
    "64GB, 128GB, 256GB";
  return base
    .replaceAll("{produto}", ctx.produto ?? "o produto")
    .replaceAll("{lista}", lista);
}

export function tCrossSell(ctx: MsgCtx) {
  const key = (ctx.categoria ?? ctx.produto) ?? "";
  const bank = crossSell[key];
  if (!bank) return null;
  return pick(bank).replace("{emoji}", pick(ctx.persona.emojiPack));
}

3) Regras de cross-sell (para n√£o repetir)
// src/logic/crossSell.ts
export const ACCESSORIES_BY_CATEGORY: Record<string, string[]> = {
  celular: ["capinha", "pel√≠cula", "carregador turbo", "fones bluetooth", "power bank", "cabo usb-c"],
  drone: ["bateria extra", "h√©lices", "case r√≠gido", "cart√£o sd", "hub de carga", "protetor de h√©lices"],
  perfume: ["kit presente", "necessaire", "miniatura"],
  tv: ["soundbar", "suporte parede", "cabo hdmi", "controle universal"],
};

export function nextAccessorySuggestion(cat?: string, already: string[] = []): string[] {
  if (!cat) return [];
  const pool = ACCESSORIES_BY_CATEGORY[cat] ?? [];
  return pool.filter(x => !already.includes(x)).slice(0, 2);
}

4) Memory (adicionar campos pra conversa)
// src/types/memory.ts (adicione se ainda n√£o tiver)
export interface ConversationMemory {
  focoAtual: string | null;       // ex.: "iphone" ou "drone"
  lastQuery?: string | null;
  nomeCliente?: string | null;
  acess√≥riosSugeridos?: string[]; // para n√£o repetir cross-sell
}

5) NLG ‚Äì montar resposta final baseada no contexto
// src/nlg/say.ts
import { SalesPersona } from "../persona/salesPersona";
import { tGreet, tFound, tNoResults, tClarify, tCrossSell } from "./templates";
import { nextAccessorySuggestion } from "../logic/crossSell";
import type { ConversationMemory } from "../types/memory";

type Block = { type: "text"; text: string } | { type: "products"; items: any[] };

export interface ComposeArgs {
  query: { produto?: string; categoria?: string; modelo?: string; marca?: string; queryFinal?: string; faltando?: Array<"modelo"|"marca"|"armazenamento">; };
  items: any[];
  memory: ConversationMemory;
}

export function composeAnswer(args: ComposeArgs): Block[] {
  const persona = SalesPersona;
  const { query, items, memory } = args;
  const blocks: Block[] = [];

  if (!memory.lastQuery && !query.produto && !query.categoria) {
    blocks.push({ type: "text", text: tGreet({ persona }) });
  }

  if (items.length > 0) {
    blocks.push({
      type: "text",
      text: tFound({
        persona,
        produto: query.produto,
        categoria: query.categoria,
        modelo: query.modelo,
        count: items.length,
        query: query.queryFinal ?? query.produto ?? query.categoria ?? ""
      })
    });
    blocks.push({ type: "products", items });

    // Pergunta de esclarecimento se faltar slot
    const falta: Array<"modelo" | "marca" | "armazenamento"> = [];
    if (!query.modelo && (query.produto === "iphone" || query.categoria === "celular")) falta.push("modelo");
    if (!query.marca && ["celular","tv","notebook"].includes(query.categoria ?? "")) falta.push("marca");
    if (!query["armazenamento"] && query.produto === "iphone") falta.push("armazenamento");
    const clar = tClarify({ persona, produto: query.produto, faltando: falta });
    if (clar) blocks.push({ type: "text", text: clar });

    // Cross-sell (sem repetir)
    const cat = query.categoria ?? query.produto;
    const novos = nextAccessorySuggestion(cat, memory.acess√≥riosSugeridos ?? []);
    if (novos.length) {
      blocks.push({ type: "text", text: tCrossSell({ persona, categoria: cat })! });
    }
  } else {
    blocks.push({
      type: "text",
      text: tNoResults({
        persona,
        produto: query.produto,
        categoria: query.categoria,
        modelo: query.modelo,
        faltando: query.faltando ?? ["modelo"],
        query: query.queryFinal ?? query.produto ?? ""
      })
    });
  }

  return blocks;
}

6) Integrar no orquestrador (onde voc√™ j√° retorna itens)

S√≥ trocar a montagem de texto fixo pela composeAnswer.

// src/services/conversation.ts (trecho na parte PRODUCT)
import { composeAnswer } from "../nlg/say";
import type { ConversationMemory } from "../types/memory";

// ... dentro do runAssistant, ap√≥s obter "items" e "query"
const memory = (sess as ConversationMemory) ?? { focoAtual: null };
const blocks = composeAnswer({ items, query: {
  produto, categoria, modelo, marca, queryFinal
}, memory });

// Atualiza mem√≥ria de acess√≥rios sugeridos (evita repeti√ß√£o)
if (!memory.acess√≥riosSugeridos) memory.acess√≥riosSugeridos = [];
// (opcional) concat com o que foi sugerido no bloco de cross-sell

return { kind: "PRODUCT", queryFinal, items, text: blocks.filter(b=>b.type==="text").map(b=>b.text).join("\n\n") };


No front, se voc√™ j√° exibe ‚Äúcards‚Äù + ‚Äúbolha de texto‚Äù, s√≥ renderize text e a lista de items como faz hoje.

7) Exemplos de comportamento ap√≥s o patch

Usu√°rio: ‚Äúquero um iphone‚Äù

IA: ‚ÄúBoa escolha! Separei 12 op√ß√µes de celular pra ‚Äòiphone‚Äô. üòâ
Prefere 12, 13, 15‚Ä¶?
Aproveita e j√° quer capinha e pel√≠cula?‚Äù

Usu√°rio: ‚Äúdrone‚Äù

IA: ‚ÄúAchei 2 resultados que combinam com ‚Äòdrone‚Äô. ‚ú®
Pra drone, bateria extra e h√©lices salvam o dia. Te mostro?‚Äù

Usu√°rio: ‚Äúperfumes‚Äù

IA: ‚ÄúSeparei 10 perfumes. üòÑ
Curte kit presente com n√©cessaire?‚Äù

Observa√ß√µes r√°pidas

Varia√ß√µes naturais: cada resposta puxa um template diferente ‚Üí menos repeti√ß√£o.

Humor control√°vel: ajuste SalesPersona.humor/emojiPack.

Cross-sell consciente: s√≥ sugere quando fizer sentido e sem repetir em sequ√™ncia.

Perguntas de esclarecimento: aparecem apenas se faltar slot relevante (modelo/marca/armazenamento).

Quer que eu consolide tudo em um √∫nico diff para colar de uma vez? Ou ajusto o vocabul√°rio (mais vendedor, mais formal)?

Voc√™ disse:
uma duvida, a ia s√≥ consegue responder com naturalidade com templates? voce tambem √© programado assim?
Programador Senior - Dev GPT ‚Äî Replit Ready disse:
Pensou por 20s

Boa pergunta!

Resposta curta

N√£o: uma IA n√£o precisa de templates para soar natural.

Eu (este assistente) sou um modelo generativo (GPT-5 Thinking), ou seja, n√£o dependo de frases fixas; gero a resposta palavra-a-palavra.

Em produ√ß√£o, por√©m, o melhor √© um modo h√≠brido: l√≥gica e dados determin√≠sticos + (opcional) um gerador para dar tom humano sem inventar nada.

Op√ß√µes de arquitetura (o que usar quando)

S√≥ templates

‚úÖ 100% previs√≠vel, zero alucina√ß√£o, barato.

‚ùå Pode parecer repetitivo.

Gerativo ‚Äúsolto‚Äù (LLM faz tudo)

‚úÖ Super natural.

‚ùå Risco de inventar produto/pre√ßo; dif√≠cil auditar.

H√≠brido (recomendado)

Determin√≠stico: inten√ß√£o, slots, busca, regras de cross-sell e facts.

Gerativo controlado: usa o LLM apenas para ‚Äúvirar frase‚Äù (estilo/varia√ß√£o), sem decidir conte√∫do.

Como aplicar o h√≠brido no seu projeto (ideia pr√°tica)

Voc√™ j√° tem: intent ‚Üí slots ‚Üí busca ‚Üí facts.

Acrescente um ‚Äúparafraseador‚Äù opcional: recebe facts e sugest√µes (itens, filtros, CTA, cross-sell) e devolve um texto no tom vendedor/humorado.

// src/nlg/paraphrase.ts
type Facts = {
  intent: "PRODUCT"|"SMALL_TALK"|"HELP"|"TIME";
  produto?: string; categoria?: string; modelo?: string; count?: number;
  cross?: string[]; // ex.: ["capinha","pel√≠cula"]
  // ‚ö†Ô∏è sem pre√ßo/links se n√£o puderem ser mostrados
};

// Use seu provedor de LLM aqui; mantenha temperatura baixa (0.3‚Äì0.5)
export async function paraphrase(facts: Facts, draft: string): Promise<string> {
  const system = [
    "Voc√™ √© um vendedor simp√°tico, direto e honesto.",
    "Nunca invente produtos nem pre√ßos. Use apenas os fatos passados.",
    "Fa√ßa perguntas curtas e ofere√ßa complementos relevantes (cross-sell)."
  ].join("\n");

  const user = JSON.stringify({ facts, draft });

  // pseudo-c√≥digo de chamada; troque pelo seu SDK/cliente
  const resp = await llm.generate({ system, user, temperature: 0.4, maxTokens: 120 });
  return resp.text.trim();
}


Uso no fluxo:

// Depois de montar facts e um draft simples (templates):
const draft = composeAnswerTextDeterministico(facts); // seu template atual
const textoFinal = await paraphrase(facts, draft).catch(() => draft); // fallback seguro


Boas pr√°ticas do h√≠brido

Deixe o LLM s√≥ estilizar; as decis√µes (o que recomendar/mostrar) ficam no seu c√≥digo.

Temperature baixa (0.3‚Äì0.5) ‚Üí varia√ß√£o sem fugir do escopo.

Guardrails: limite tokens; valide que o retorno n√£o cont√©m dados fora dos facts.

Fallback: se o gerador falhar, use o texto determin√≠stico (templates).

Conclus√£o

Templates n√£o s√£o obrigat√≥rios; eles d√£o controle.

O melhor resultado vem do modo h√≠brido: voc√™ garante corre√ß√£o e consist√™ncia; o gerador s√≥ d√° tom humano e varia√ß√£o.

Voc√™ disse:
ok entao tenho que copiar esses dois ultimos codigos que voce me mandou?
Programador Senior - Dev GPT ‚Äî Replit Ready disse:

Sim ‚Äî copie os dois se quiser o melhor resultado:

Pacote ‚Äúdetermin√≠stico vendedor‚Äù (persona + templates + cross-sell + compose): deixa as respostas variadas e √∫teis, sem depender de LLM.

Parafraseador (h√≠brido, opcional): d√° um toque ainda mais natural usando um LLM s√≥ para ‚Äúrefinar‚Äù o texto ‚Äî com fallback seguro.

O que copiar (ordem)

src/persona/salesPersona.ts

src/nlg/templates.ts

src/logic/crossSell.ts

src/types/memory.ts (add campos)

src/nlg/say.ts (compose de mensagens)

Integrar no runAssistant (usar composeAnswer em vez de texto fixo)

Opcional (h√≠brido):
7) src/nlg/paraphrase.ts
8) No runAssistant, envolver o texto:

// depois do composeAnswer
let text = blocks.filter(b=>b.type==="text").map(b=>b.text).join("\n\n");
// habilite com env
if (process.env.USE_LLM_PARAPHRASE === "1") {
  text = await paraphrase(
    { intent: "PRODUCT", produto: query.produto, categoria: query.categoria, modelo: query.modelo, count: items.length, cross: [] },
    text
  ).catch(() => text);
}

Dica de configura√ß√£o

Coloque USE_LLM_PARAPHRASE=0 por padr√£o (fica s√≥ nos templates).

Quando quiser mais naturalidade, ative USE_LLM_PARAPHRASE=1.

Resultado

Sem LLM: j√° fica humorado, vendedor e pr√≥-ativo (com cross-sell e perguntas).

Com LLM ligado: mant√©m os fatos do seu c√≥digo e s√≥ melhora o tom.