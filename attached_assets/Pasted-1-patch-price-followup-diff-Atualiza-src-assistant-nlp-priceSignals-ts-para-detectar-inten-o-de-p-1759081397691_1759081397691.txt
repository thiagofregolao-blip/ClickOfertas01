1) patch-price-followup.diff

Atualiza src/assistant/nlp/priceSignals.ts para detectar intenção de preço mesmo sem produto, retornando hasPriceIntent.

*** a/src/assistant/nlp/priceSignals.ts
--- b/src/assistant/nlp/priceSignals.ts
@@
-import { QuerySignal } from "../types";
-import { norm } from "./normalize";
-
-export function extractPriceSignals(
-  msgRaw: string
-): Pick<QuerySignal, "price_min" | "price_max" | "sort" | "offset"> {
-  const msg = norm(msgRaw);
-
-  if (/\bsegundo\s+(mais|mas)\s+barat\w+\b/.test(msg))
-    return { sort: "price.asc", offset: 1 };
-
-  if (/\b(mais|mas)\s+(barat\w+|economic\w+)\b/.test(msg) || /\b(em\s+conta)\b/.test(msg))
-    return { sort: "price.asc" };
-
-  if (/\b(mais|mas)\s+car\w+\b/.test(msg) || /\bpremium\b/.test(msg) || /\btop\s+de\s+linha\b/.test(msg))
-    return { sort: "price.desc" };
-
-  const mMax = msg.match(
-    /\b(ate|hasta|maxim\w+|por\s+menos\s+de)\s+([\p{Sc}]?\s?[\d\.\,]+)/u
-  );
-  if (mMax) {
-    const val = parseMoney(mMax[2]);
-    if (!Number.isNaN(val)) return { price_max: val };
-  }
-
-  const mMin = msg.match(
-    /\b(desde|a\s+partir\s+de|minim\w+)\s+([\p{Sc}]?\s?[\d\.\,]+)/u
-  );
-  if (mMin) {
-    const val = parseMoney(mMin[2]);
-    if (!Number.isNaN(val)) return { price_min: val };
-  }
-
-  const mRange = msg.match(
-    /\b(entre|de)\s+([\p{Sc}]?\s?[\d\.\,]+)\s+(e|a)\s+([\p{Sc}]?\s?[\d\.\,]+)/u
-  );
-  if (mRange) {
-    const a = parseMoney(mRange[2]);
-    const b = parseMoney(mRange[4]);
-    if (!Number.isNaN(a) && !Number.isNaN(b)) {
-      const [min, max] = a < b ? [a, b] : [b, a];
-      return { price_min: min, price_max: max };
-    }
-  }
-  return {};
-}
-
-export function parseMoney(s: string): number {
-  let x = s
-    .trim()
-    .replace(/^r\$\s*/i, "")
-    .replace(/^gs\s*/i, "")
-    .replace(/^usd\s*/i, "")
-    .replace(/\./g, "")
-    .replace(/,/g, ".");
-  const n = Number(x);
-  return Number.isFinite(n) ? n : NaN;
-}
+import { QuerySignal } from "../types";
+import { norm } from "./normalize";
+
+export function extractPriceSignals(
+  msgRaw: string
+): Pick<QuerySignal, "price_min" | "price_max" | "sort" | "offset"> & { hasPriceIntent?: boolean } {
+  const msg = norm(msgRaw);
+
+  // palavras que sinalizam intenção de preço (sem precisar de produto)
+  const priceWords = [
+    "barato", "barata", "economico", "econômico", "economica", "econômica",
+    "mais barato", "mas barato", "baratinho",
+    "caro", "cara", "mais caro", "top de linha", "premium",
+    "ate", "hasta", "por menos de", "a partir de", "entre", "de"
+  ];
+  const hasPriceIntent = priceWords.some(w => msg.includes(norm(w)));
+
+  // 2º mais barato
+  if (/\b(segundo|2o|2º)\s+(mais|mas)\s+barat\w+\b/.test(msg))
+    return { sort: "price.asc", offset: 1, hasPriceIntent: true };
+
+  // Mais barato
+  if (/\b(qual\s+o\s+)?(mais|mas)\s+barat\w+\b/.test(msg) || /\b(em\s+conta)\b/.test(msg))
+    return { sort: "price.asc", hasPriceIntent: true };
+
+  // Mais caro / premium
+  if (/\b(mais|mas)\s+car\w+\b/.test(msg) || /\bpremium\b/.test(msg) || /\btop\s+de\s+linha\b/.test(msg))
+    return { sort: "price.desc", hasPriceIntent: true };
+
+  // Até X
+  const mMax = msg.match(/\b(ate|hasta|maxim\w+|por\s+menos\s+de)\s+([\p{Sc}]?\s?[\d\.\,]+)/u);
+  if (mMax) {
+    const val = parseMoney(mMax[2]);
+    if (!Number.isNaN(val)) return { price_max: val, hasPriceIntent: true };
+  }
+
+  // A partir de X
+  const mMin = msg.match(/\b(desde|a\s+partir\s+de|minim\w+)\s+([\p{Sc}]?\s?[\d\.\,]+)/u);
+  if (mMin) {
+    const val = parseMoney(mMin[2]);
+    if (!Number.isNaN(val)) return { price_min: val, hasPriceIntent: true };
+  }
+
+  // Entre X e Y
+  const mRange = msg.match(/\b(entre|de)\s+([\p{Sc}]?\s?[\d\.\,]+)\s+(e|a)\s+([\p{Sc}]?\s?[\d\.\,]+)/u);
+  if (mRange) {
+    const a = parseMoney(mRange[2]);
+    const b = parseMoney(mRange[4]);
+    if (!Number.isNaN(a) && !Number.isNaN(b)) {
+      const [min, max] = a < b ? [a, b] : [b, a];
+      return { price_min: min, price_max: max, hasPriceIntent: true };
+    }
+  }
+  return { hasPriceIntent };
+}
+
+export function parseMoney(s: string): number {
+  let x = s
+    .trim()
+    .replace(/^r\$\s*/i, "")
+    .replace(/^gs\s*/i, "")
+    .replace(/^usd\s*/i, "")
+    .replace(/\./g, "")
+    .replace(/,/g, ".");
+  const n = Number(x);
+  return Number.isFinite(n) ? n : NaN;
+}

2) patch-routes-followup.diff

Atualiza src/assistant/assistantRoutes.ts para herdar foco/categoria da sessão quando a frase tiver apenas intenção de preço.

*** a/src/assistant/assistantRoutes.ts
--- b/src/assistant/assistantRoutes.ts
@@
 import type { Express, Router } from "express";
 import { classify } from "../nlp/intent";
 import { extractModeloGBCor } from "../nlp/slots";
 import { buildQuery, runQueryLocal } from "../query/builder";
 import { policyAnswer } from "../policy/decide";
 import { sayFound, sayGreeting, sayNoResults } from "../nlg/templates";
 import { getSession, updateSession } from "../core/session";
 import type { Intent, CatalogItem } from "../types";
 import { naturalize } from "../nlg/naturalizer";
 import type { CatalogProvider } from "../catalog/provider";
+import { extractPriceSignals } from "../nlp/priceSignals";
@@
   post("/assistant/query", async (req: any, res: any) => {
     const { sessionId = "anon", message, lang = "pt" } = (req.body ?? {}) as { sessionId?: string; message?: string; lang?: "pt"|"es" };
     if (!message || !message.trim()) return res.status(400).json({ ok:false, error:"Mensagem vazia" });
 
     const sess = getSession(sessionId);
-    const { intent, base } = classify(message);
+    const { intent, base } = classify(message);
+
+    // NEW: follow-up de preço → herda foco/categoria da sessão
+    const priceSig = extractPriceSignals(message);
+    const priceOnlyFollowUp =
+      priceSig.hasPriceIntent &&
+      !base.produto &&
+      !base.categoria &&
+      (sess.focoAtual || sess.categoriaAtual);
+
+    const effectiveIntent = (priceOnlyFollowUp ? "PRODUCT_SEARCH" : intent) as Intent;
+    const effectiveBase = priceOnlyFollowUp
+      ? {
+          ...base,
+          produto: sess.focoAtual ?? undefined,
+          categoria: sess.categoriaAtual ?? undefined,
+        }
+      : base;
@@
-    if (intent !== "PRODUCT_SEARCH") {
+    if (effectiveIntent !== "PRODUCT_SEARCH") {
       let draft = "";
       if (intent === "SMALL_TALK") draft = sayGreeting(sessionId, lang);
       else if (intent === "TIME_QUERY") {
         const now = new Date(), hh = String(now.getHours()).padStart(2,"0"), mm = String(now.getMinutes()).padStart(2,"0");
         draft = lang === "es" ? `Ahora son las ${hh}:${mm}.` : `Agora são ${hh}:${mm}.`;
         if (sess.focoAtual) draft += lang === "es" ? ` ¿Seguimos con ${sess.focoAtual}?` : ` Quer continuar no ${sess.focoAtual}?`;
       } else if (intent === "HELP") {
         draft = lang === "es" ? "Dime el producto (ej.: iPhone, drone, perfume) y te muestro ofertas."
                               : "Diga o produto (ex.: iPhone, drone, perfume) que eu mostro as ofertas.";
       } else if (intent === "WHOAMI") {
         draft = lang === "es" ? "Soy tu asistente de compras." : "Sou seu assistente de compras.";
       } else {
         draft = sayGreeting(sessionId, lang);
       }
       const text = await naturalize({ intent:"SMALL_TALK", draft }, (process.env.REPLY_TONE as any) || "vendedor_descontraido");
       return res.json({ ok:true, text, items:[], blocks:[{type:"text",text}], debug:{ intent } });
     }
@@
-    const produtoNovo = base.produto && base.produto !== sess.focoAtual;
+    const produtoNovo = effectiveBase.produto && effectiveBase.produto !== sess.focoAtual;
     updateSession(sessionId, {
-      focoAtual: base.produto ?? sess.focoAtual ?? null,
-      categoriaAtual: produtoNovo ? base.categoria ?? null : sess.categoriaAtual ?? base.categoria ?? null,
-      lastQuery: base.produto ?? sess.lastQuery ?? null,
+      focoAtual: effectiveBase.produto ?? sess.focoAtual ?? null,
+      categoriaAtual: produtoNovo ? effectiveBase.categoria ?? null : sess.categoriaAtual ?? effectiveBase.categoria ?? null,
+      lastQuery: effectiveBase.produto ?? sess.lastQuery ?? null,
     });
@@
-    const slots = extractModeloGBCor(message);
-    const q = buildQuery({ base: { ...base }, text: message, preferInStockCheapest: true, slots: { attrs: slots.attrs, modelo: slots.modelo } });
+    const slots = extractModeloGBCor(message);
+    const q = buildQuery({
+      base: { ...effectiveBase },
+      text: message,
+      preferInStockCheapest: true,
+      slots: { attrs: slots.attrs, modelo: slots.modelo }
+    });

Como aplicar

Salve cada bloco como arquivo:

patch-price-followup.diff

patch-routes-followup.diff

Rode:

git apply patch-price-followup.diff
git apply patch-routes-followup.diff


npm run dev e teste:

“quero um iPhone barato”

“qual o mais barato você tem?”

“tem mais barato que isso?” (opcional: adicione “segundo mais barato” para offset:1)