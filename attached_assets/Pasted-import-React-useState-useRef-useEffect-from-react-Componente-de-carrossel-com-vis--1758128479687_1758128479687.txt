import React, { useState, useRef, useEffect } from 'react';

/**
 * Componente de carrossel com visão parcial de banners vizinhos.
 * 
 * @param {Array} banners - array de objetos com { src, alt } representando cada banner.
 */
const Carousel = ({ banners }) => {
  // Proporção do tamanho total (slide + margens) em relação à área disponível
  const visibleRatio = 0.9;
  // Porção da área reservada aos gaps (metade em cada lado)
  const gapRatio = 0.04;

  // Clones: último banner no início e primeiro banner no final
  const slides = [
    { ...banners[banners.length - 1], clone: true },
    ...banners.map((b) => ({ ...b, clone: false })),
    { ...banners[0], clone: true }
  ];

  const carouselRef = useRef(null);
  const trackRef = useRef(null);
  const [currentIndex, setCurrentIndex] = useState(1);
  const [dims, setDims] = useState({
    slideWidth: 0,
    slideMargin: 0,
    slideTotal: 0,
    leftover: 0
  });
  const autoplayRef = useRef(null);

  // Calcula dimensões e aplica margens/larguras aos slides
  const calculateDimensions = () => {
    const carousel = carouselRef.current;
    if (!carousel) return;

    const computed = window.getComputedStyle(carousel);
    const paddingLeft  = parseFloat(computed.paddingLeft) || 0;
    const paddingRight = parseFloat(computed.paddingRight) || 0;
    const availableWidth = carousel.clientWidth - paddingLeft - paddingRight;

    const marginHalf  = availableWidth * (gapRatio / 2);
    const slideMargin = marginHalf * 2;
    const slideTotal  = availableWidth * visibleRatio;
    const slideWidth  = slideTotal - slideMargin;
    const leftover    = availableWidth - slideTotal;

    // Salva dimensões
    setDims({ slideWidth, slideMargin, slideTotal, leftover });

    // Aplica margens/larguras aos slides via estilo inline
    if (trackRef.current) {
      Array.from(trackRef.current.children).forEach((child) => {
        child.style.width = `${slideWidth}px`;
        child.style.marginLeft  = `${marginHalf}px`;
        child.style.marginRight = `${marginHalf}px`;
      });
    }
  };

  // Atualiza a posição do carrossel para centralizar o slide corrente
  const updatePosition = (withTransition = true) => {
    const { slideTotal, leftover } = dims;
    if (!trackRef.current || !slideTotal) return;

    trackRef.current.style.transition = withTransition
      ? `transform 0.8s ease-in-out`
      : 'none';

    const offset = currentIndex * slideTotal - leftover / 2;
    trackRef.current.style.transform = `translateX(-${offset}px)`;
  };

  // Avança para o próximo slide
  const nextSlide = () => setCurrentIndex((idx) => idx + 1);

  // Inicia o autoplay
  const startAutoPlay = () => {
    stopAutoPlay();
    autoplayRef.current = setInterval(nextSlide, 4000);
  };
  // Pausa o autoplay
  const stopAutoPlay = () => clearInterval(autoplayRef.current);

  // Tratamento para reposicionar quando chega ao clone
  const handleTransitionEnd = (e) => {
    if (e.propertyName !== 'transform') return;

    // Se chegamos ao clone final, voltamos ao primeiro real
    if (slides[currentIndex].clone && currentIndex === slides.length - 1) {
      setCurrentIndex(1);
      // Sem animação
      requestAnimationFrame(() => updatePosition(false));
    }
    // Se chegamos ao clone inicial, vamos para o último real
    if (slides[currentIndex].clone && currentIndex === 0) {
      setCurrentIndex(banners.length);
      requestAnimationFrame(() => updatePosition(false));
    }
  };

  // Calcula dimensões na montagem e nos redimensionamentos
  useEffect(() => {
    calculateDimensions();
    window.addEventListener('resize', calculateDimensions);
    return () => window.removeEventListener('resize', calculateDimensions);
  }, []);

  // Atualiza a posição sempre que currentIndex ou dimensões mudam
  useEffect(() => {
    updatePosition();
  }, [currentIndex, dims]);

  // Configura/autodestrói o autoplay e transição
  useEffect(() => {
    const track = trackRef.current;
    if (track) {
      track.addEventListener('transitionend', handleTransitionEnd);
    }
    // Inicia autoplay
    startAutoPlay();
    // Limpa listeners e interval ao desmontar
    return () => {
      stopAutoPlay();
      if (track) {
        track.removeEventListener('transitionend', handleTransitionEnd);
      }
    };
  }, [slides.length]);

  return (
    <div
      className="carousel"
      ref={carouselRef}
      onMouseEnter={stopAutoPlay}
      onMouseLeave={startAutoPlay}
    >
      {/* Estilos de apoio (poderiam estar em um arquivo CSS) */}
      <style>{`
        .carousel {
          position: relative;
          width: 100%;
          overflow: hidden;
          padding-left: var(--stage-padding-desktop);
          padding-right: var(--stage-padding-desktop);
          box-sizing: border-box;
        }
        .carousel-track {
          display: flex;
          will-change: transform;
        }
        .carousel-item img {
          width: 100%;
          display: block;
          border-radius: 8px;
        }
        .dots {
          display: flex;
          justify-content: center;
          margin-top: 10px;
          gap: 6px;
        }
        .dot {
          width: 10px;
          height: 10px;
          border-radius: 50%;
          background: #ccc;
          cursor: pointer;
        }
        .dot.active {
          background: #333;
        }
        @media (max-width: 768px) {
          .carousel {
            padding-left: var(--stage-padding-mobile);
            padding-right: var(--stage-padding-mobile);
          }
        }
      `}</style>

      <div className="carousel-track" ref={trackRef}>
        {slides.map((slide, idx) => (
          <div className="carousel-item" key={idx}>
            <img src={slide.src} alt={slide.alt} />
          </div>
        ))}
      </div>

      <div className="dots">
        {banners.map((_, idx) => (
          <span
            key={idx}
            className={currentIndex - 1 === idx ? 'dot active' : 'dot'}
            onClick={() => setCurrentIndex(idx + 1)}
          />
        ))}
      </div>
    </div>
  );
};

export default Carousel;