Perfeito ponto. Com 5k+ produtos não dá pra “cadastrar na mão”. A solução definitiva é tornar o dicionário canônico dinâmico, gerado do seu catálogo, e plugar isso no pipeline. Segue um patch enxuto com:

Builder offline que lê o catálogo e gera canon.json (produtos, categorias, marcas, sinônimos PT/ES + singular).

Loader em runtime (cache quente) para consultas.

Fallbacks automáticos (plural/typo/majority-vote por categoria).

Observabilidade: coleta de termos desconhecidos ao vivo (pra você revisar, sem quebrar).

Cross-sell por categoria (genérico, sem ifs por produto).

Teste mínimo de cobertura.

1) Script: gera dicionário canônico do catálogo
// scripts/build-canon.ts
import fs from "fs";
import path from "path";

// Espera catálogo em JSON: [{ id, nome, categoria, marca }]
type Item = { id:string; nome:string; categoria:string; marca?:string };

const SRC = path.resolve("data/catalogo.json");
const OUT = path.resolve("data/canon.json");

const stop = new Set([
  "de","da","do","para","com","sem","e","ou","the","a","an",
  "para","por","con","sin","y","o","la","el","los","las"
]);

// normaliza PT/ES
function norm(s:string){
  return s.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g,"")
    .replace(/[^\p{L}\p{N}\s]/gu," ")
    .replace(/\s+/g," ").trim();
}

// singular simples PT/ES
function singular(w:string){
  const x = norm(w);
  if (x.endsWith("oes")||x.endsWith("aes")) return x.slice(0,-3)+"ao";
  if (x.endsWith("is")) return x.slice(0,-1)+"l";
  if (x.endsWith("ns")) return x.slice(0,-2)+"m";
  if (x.endsWith("es") && x.length>4) return x.slice(0,-2);
  if (x.endsWith("s") && x.length>3) return x.slice(0,-1);
  return x;
}

// tokeniza e remove stopwords
function toks(s:string){ return norm(s).split(" ").filter(t=>t && !stop.has(t)); }

function headNoun(name:string){
  // heurística: primeiro token não-marcas/stop + segundo se for número/série
  const ts = toks(name);
  if (!ts.length) return null;
  return singular(ts[0]);
}

function build(){
  const raw = JSON.parse(fs.readFileSync(SRC,"utf8")) as Item[];

  const productCanon: Record<string,string> = {};
  const categoryCanon: Record<string,string> = {};
  const productToCategory: Record<string,string> = {};
  const brands = new Set<string>();
  const votes: Record<string, Record<string, number>> = {}; // product -> {cat:count}

  for (const it of raw){
    const nome = it.nome ?? "";
    const cat  = singular(it.categoria ?? "");
    if (!cat) continue;

    categoryCanon[cat] = cat; // canônico
    const h = headNoun(nome);
    if (!h) continue;

    // sinônimos: plural e variações simples do nome
    const tks = toks(nome).map(singular);
    for (const t of tks){
      if (t.length<2) continue;
      productCanon[t] = h;
    }

    // votação de categoria por produto canônico
    votes[h] ??= {};
    votes[h][cat] = (votes[h][cat] ?? 0) + 1;

    if (it.marca) brands.add(norm(it.marca));
  }

  // majority vote
  for (const p of Object.keys(votes)){
    const entry = votes[p];
    const top = Object.entries(entry).sort((a,b)=>b[1]-a[1])[0]?.[0];
    if (top) productToCategory[p] = top;
  }

  const out = {
    productCanon,
    categoryCanon,
    productToCategory,
    brands: Array.from(brands)
  };
  fs.mkdirSync(path.dirname(OUT), { recursive: true });
  fs.writeFileSync(OUT, JSON.stringify(out,null,2));
  console.log(`✔ canon.json gerado com ${Object.keys(productCanon).length} termos / ${Object.keys(categoryCanon).length} categorias`);
}

build();


Como usar:

Exporte seu catálogo atual para data/catalogo.json.

Rode: node scripts/build-canon.ts → gera data/canon.json.

2) Loader em runtime (cache)
// src/nlp/canon.store.ts
import fs from "fs";
import path from "path";

type CanonData = {
  productCanon: Record<string,string>;
  categoryCanon: Record<string,string>;
  productToCategory: Record<string,string>;
  brands: string[];
};

let CACHE: CanonData | null = null;

export function loadCanon(): CanonData {
  if (CACHE) return CACHE;
  const p = path.resolve("data/canon.json");
  const raw = fs.existsSync(p) ? JSON.parse(fs.readFileSync(p, "utf8")) : {
    productCanon:{}, categoryCanon:{}, productToCategory:{}, brands:[]
  };
  CACHE = raw as CanonData;
  return CACHE!;
}

export function canonProduct(token: string): string | null {
  const { productCanon } = loadCanon();
  return productCanon[token] ?? null;
}
export function canonCategory(token: string): string | null {
  const { categoryCanon } = loadCanon();
  return categoryCanon[token] ?? null;
}
export function productDefaultCategory(prod: string): string | null {
  const { productToCategory } = loadCanon();
  return productToCategory[prod] ?? null;
}
export function allBrands(): Set<string> {
  return new Set(loadCanon().brands);
}

3) Integrar no NLP (substitui mapa hardcoded)
// src/utils/lang-ptbr.ts (apenas acrescentar estes helpers)
import { canonProduct, canonCategory } from "../nlp/canon.store";

export function tokenCanonProduct(t: string): string | null {
  return canonProduct(t) ?? null;
}
export function tokenCanonCategory(t: string): string | null {
  return canonCategory(t) ?? null;
}

// src/nlp/intent.ts (trocar detecção canônica)
import { normPTBR, tokenizePTBR } from "../utils/lang-ptbr";
import { tokenCanonProduct, tokenCanonCategory } from "../utils/lang-ptbr";

function firstCanonProduct(msg: string): string | null {
  for (const t of tokenizePTBR(msg)) {
    const c = tokenCanonProduct(t);
    if (c) return c;
  }
  return null;
}
function firstCanonCategory(msg: string): string | null {
  for (const t of tokenizePTBR(msg)) {
    const c = tokenCanonCategory(t);
    if (c) return c;
  }
  return null;
}


E no classifyIntent, use firstCanonProduct/Category (você já tinha algo similar — só plugue nessas).

4) Interpretador: usar categoria por maioria quando não vier da sessão
// src/modules/buscaProduto.ts (trecho relevante)
import { productDefaultCategory } from "../nlp/canon.store";

let categoria = memoria?.categoriaAtual ?? (produto ? productDefaultCategory(produto) ?? undefined : undefined);

5) Tolerância a typos (edit distance pequena) sem libs
// src/nlp/fuzzy.ts
export function damerauLevenshtein(a:string,b:string):number{
  const al=a.length, bl=b.length;
  const da:Record<string,number>={};
  const max=al+bl;
  const d=Array.from({length:al+2},()=>Array(bl+2).fill(0));
  d[0][0]=max;
  for(let i=0;i<=al;i++){d[i+1][0]=max; d[i+1][1]=i;}
  for(let j=0;j<=bl;j++){d[0][j+1]=max; d[1][j+1]=j;}
  for(let i=1;i<=al;i++){
    let db=0;
    for(let j=1;j<=bl;j++){
      const i1=da[b[j-1]]??0, j1=db;
      const cost = a[i-1]===b[j-1]?0:1;
      if(cost===0) db=j;
      d[i+1][j+1]=Math.min(
        d[i][j]+cost,           // sub
        d[i+1][j]+1,            // ins
        d[i][j+1]+1,            // del
        d[i1][j1]+(i-i1-1)+1+(j-j1-1) // transposição
      );
    }
    da[a[i-1]]=i;
  }
  return d[al+1][bl+1];
}


Uso no intent: se não achou canônico direto, tenta fuzzy (distância ≤1/2 para termos do dicionário mais frequentes — opcionalmente selecione só sobre Object.keys(productCanon).slice(0, N)).

6) Cross-sell genérico por categoria (escala)
// src/logic/crossSell.ts (substitua por algo genérico)
export const ACCESSORIES_BY_CATEGORY: Record<string,string[]> = {
  celular:["capinha","película","carregador","fones bt","power bank"],
  drone:["bateria extra","hélices","case","cartão sd","hub de carga"],
  perfume:["kit presente","necessaire","miniatura"],
  tv:["soundbar","suporte parede","cabo hdmi"],
  roupa:["cinto","bolsa","lenço","organizador"]
};

export function accessoriesForCategory(cat?: string): string[] {
  return ACCESSORIES_BY_CATEGORY[cat ?? ""] ?? [];
}


No NLG, basta usar a categoria resolvida do turno (query.categoria) para sugerir — sem “ifs” de produto.

7) Observabilidade: termos desconhecidos (telemetria leve)
// src/observability/unknown-terms.ts
const hits = new Map<string, number>();
export function trackUnknownToken(token: string){
  const k = token.trim(); if (!k) return;
  hits.set(k, (hits.get(k) ?? 0) + 1);
}
export function snapshotUnknown(){ return [...hits.entries()].sort((a,b)=>b[1]-a[1]).slice(0,100); }


Integre no intent: quando um token não bater no dicionário nem no fuzzy, chame trackUnknownToken(t). Depois você lista em um endpoint admin /debug/unknown para revisar e, se quiser, adicionar sinônimos permanentes ao catálogo (ou reexecutar o builder).

8) Teste mínimo (garante que não regressa)
// __tests__/canon.spec.ts
import { loadCanon } from "../src/nlp/canon.store";

test("canon carregado e tem categorias", ()=>{
  const c = loadCanon();
  expect(Object.keys(c.productCanon).length).toBeGreaterThan(100);
  expect(Object.keys(c.categoryCanon).length).toBeGreaterThan(5);
});

test("produto mapeia para categoria por majority vote", ()=>{
  const c = loadCanon();
  const anyProd = Object.values(c.productCanon)[0];
  if (anyProd) {
    expect(c.productToCategory[anyProd]).toBeDefined();
  }
});

Fluxo operacional (1x ao dia ou CI)

Exporta/atualiza data/catalogo.json (do seu DB).

Roda node scripts/build-canon.ts.

Sobe a app (loader lê data/canon.json).

Monitora /debug/unknown para capturar termos novos de usuários; quando acumular muitos, reexporta catálogo + rebuild.

Por que isso resolve “de vez”

O canônico vem do catálogo → cobre milhares de SKUs automaticamente (inclusive plural/variações PT/ES).

Categoria padrão por majority vote evita ficar preso em “celular”/“drone”: cada produto canônico carrega sua categoria mais frequente.

Fuzzy pega digitações “iphnoe”, “dornes”.

Cross-sell por categoria escala sem if por produto.

Observabilidade mostra lacunas reais de vocabulário → você corrige no catálogo e o builder resolve o resto.