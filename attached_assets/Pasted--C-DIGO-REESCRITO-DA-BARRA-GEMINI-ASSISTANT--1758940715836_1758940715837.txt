// =============================================
// CÓDIGO REESCRITO DA BARRA GEMINI ASSISTANT
// =============================================
// Arquivo: server/routes.ts
// Rota: POST /api/assistant/gemini/stream
// Descrição: Assistente Gemini com comportamento "show-then-ask"
// Versão Melhorada: Incorpora todas as melhorias em contexto, busca, integração API, escalabilidade, segurança, manutenção e fluidez.

// Dependências adicionais (instale via npm se necessário):
// - compromise: para NLP leve em detecção de contexto
// - fuzzysearch: para matching fuzzy na busca
// - p-retry: para retries em storage
// - winston: para logging estruturado
// - node-cache: para cache in-memory
// - zod: para validação de schema

import { Request, Response } from 'express';
import nlp from 'compromise'; // Para NLP leve
import fuzzysearch from 'fuzzysearch'; // Para matching fuzzy
import pRetry from 'p-retry'; // Para retries
import winston from 'winston'; // Logging estruturado
import NodeCache from 'node-cache'; // Cache in-memory
import { z } from 'zod'; // Validação

// Configurar logger
const logger = winston.createLogger({
  level: 'info',
  format: winston.format.json(),
  transports: [new winston.transports.Console()],
});

// Cache in-memory para buscas (TTL: 5min)
const searchCache = new NodeCache({ stdTTL: 300 });

// Expansão de categorias para segmentoDaQuery (mantido para fallback)
function segmentoDaQueryGemini(query: string, ofertas: any[] = []) {
  const q = (query || "").toLowerCase();
  const marcas = new Set(ofertas.map(o => (o.marca || "").toLowerCase()));
  const tem = (s: string) => q.includes(s) || [...marcas].some(m => m.includes(s));
  if (tem("iphone") || tem("apple")) return "aparelhos da Apple";
  if (tem("samsung") || tem("galaxy")) return "aparelhos Samsung";
  if (tem("drone")) return "drones";
  if (tem("perfume")) return "perfumes";
  if (tem("notebook") || tem("laptop")) return "notebooks";
  if (tem("tv") || tem("televisão")) return "TVs";
  return "esses produtos";
}

// POST /api/assistant/gemini/stream - Gemini Assistant with "show-then-ask" behavior
app.post('/api/assistant/gemini/stream', async (req: Request, res: Response) => {
  // Validação com Zod
  const schema = z.object({
    message: z.string().min(1),
    sessionId: z.string().min(1),
  });
  const parsed = schema.safeParse(req.body);
  if (!parsed.success) {
    return res.status(400).json({ error: 'Invalid request: ' + parsed.error.message });
  }

  const { message, sessionId } = parsed.data;
  const user = req.user || req.session?.user;

  // Configuração SSE
  res.setHeader('Content-Type', 'text/event-stream; charset=utf-8');
  res.setHeader('Cache-Control', 'no-cache, no-transform');
  res.setHeader('Connection', 'keep-alive');
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.flushHeaders?.();

  const send = (event: string, payload: any) => {
    res.write(`event: ${event}\n`);
    res.write(`data: ${JSON.stringify(payload)}\n\n`);
  };

  // Persistência com retry
  const saveWithRetry = async (operation: () => Promise<any>) => {
    return pRetry(operation, { retries: 3, onFailedAttempt: (error) => logger.warn(`Retry tentativa: ${error.attemptNumber}, erro: ${error.message}`) });
  };

  try {
    let session = await saveWithRetry(() => storage.getAssistantSession(sessionId));
    if (!session) {
      session = await saveWithRetry(() => storage.createAssistantSession({
        id: sessionId,
        userId: user?.id || null,
        metadata: { createdAt: new Date().toISOString(), provider: 'gemini', contextSummary: {} }, // Adicionado contextSummary
      }));
    }
    
    await saveWithRetry(() => storage.createAssistantMessage({ 
      sessionId, 
      role: 'user', 
      content: message, 
      metadata: { timestamp: new Date().toISOString(), provider: 'gemini' } 
    }));
  } catch (error) {
    logger.error('Erro persistente ao salvar mensagem Gemini:', error);
  }

  // Anti-duplicidade: Checar última mensagem
  try {
    const messages = await storage.getAssistantMessages(sessionId);
    const lastUserMsg = messages.filter(m => m.role === 'user').slice(-2, -1)[0]?.content;
    if (lastUserMsg === message) {
      send('delta', { text: "Ei, já respondi isso! Quer refinar a busca?" });
      send('complete', { provider: 'gemini' });
      res.end();
      return;
    }
  } catch (error) {
    logger.warn('Erro ao checar duplicidade:', error);
  }

  // Tool: buscarOfertas (melhorada com fuzzy, ranking avançado, cache, filtros e sinônimos)
  async function buscarOfertas(args: { query: string; maxResultados?: number; minPrice?: number; maxPrice?: number; brand?: string; }) {
    const { query, maxResultados = 12, minPrice, maxPrice, brand } = args || {};
    
    const q = String(query || "").toLowerCase().trim();
    if (!q) return [];
    
    // Dicionário de sinônimos
    const synonyms = {
      celular: ['smartphone', 'telefone'],
      perfume: ['fragrância', 'colônia'],
      notebook: ['laptop', 'computador portátil'],
      tv: ['televisão', 'smart tv'],
    };
    
    // Expandir query com sinônimos
    const expandedQueries = [q, ...(synonyms[q.split(' ')[0]] || [])];
    
    // Cache key
    const cacheKey = `${q}|${minPrice}|${maxPrice}|${brand}`;
    const cached = searchCache.get(cacheKey);
    if (cached) {
      logger.info(`Cache hit para query: ${q}`);
      return cached as any[];
    }
    
    try {
      const { searchSuggestions } = await import('./lib/tools.js');
      let products = [];
      
      // Tentar busca com queries expandidas
      for (const searchQuery of expandedQueries) {
        const searchResult = await searchSuggestions(searchQuery);
        products = [...products, ...(searchResult.products || [])];
      }
      
      // Remover duplicatas
      products = Array.from(new Map(products.map(p => [p.id, p])).values());
      
      // Normalização e fuzzy matching
      products = products.filter(p => 
        expandedQueries.some(sq => fuzzysearch(sq, (p.title || '').toLowerCase()) || fuzzysearch(sq, (p.marca || '').toLowerCase()))
      );
      
      // Filtros dinâmicos
      if (minPrice) products = products.filter(p => (p.price?.USD || 0) >= minPrice);
      if (maxPrice) products = products.filter(p => (p.price?.USD || 0) <= maxPrice);
      if (brand) products = products.filter(p => (p.marca || '').toLowerCase() === brand.toLowerCase());
      
      // Ranking avançado: preço ponderado por rating (assumindo rating 0-5)
      products.sort((a: any, b: any) => {
        const scoreA = (a.price?.USD || 0) * (1 - (a.rating || 0) / 5);
        const scoreB = (b.price?.USD || 0) * (1 - (b.rating || 0) / 5);
        return scoreA - scoreB;
      });
      
      const sorted = products.slice(0, Math.max(1, Math.min(50, maxResultados)));
      
      if (sorted.length > 0) {
        send('products', {
          products: sorted.map((p: any) => ({ ...p, name: p.title })),
          query,
          hardGrounding: true,
          provider: 'gemini'
        });
      }
      
      // Cache result
      searchCache.set(cacheKey, sorted);
      
      return sorted;
    } catch (error) {
      logger.error('Erro na busca Gemini:', error);
      return [];
    }
  }

  // Sanitização expandida (adiciona remoção de PII e promoções indesejadas)
  function sanitizeChatGemini(text = "") {
    return String(text)
      .replace(/!\[[^\]]*\]\([^)]+\)/g, "")        // imagens
      .replace(/\[([^\]]+)\]\(([^)]+)\)/g, "$1")   // links → só texto
      .replace(/https?:\/\/\S+/g, "")             // URLs cruas
      .replace(/\b\d{3}[-.]?\d{3}[-.]?\d{4}\b/g, "[PII]") // Exemplo: remover SSN-like
      .replace(/promoção especial|desconto exclusivo/g, "") // Remover promoções hard-coded
      .replace(/\s{2,}/g, " ")
      .trim();
  }

  // Watchdog para evitar travamentos
  const watchdogTimeout = setTimeout(() => {
    send('delta', { text: "Algo deu errado, mas que tal buscar 'iPhone 13' ou 'Samsung S24'? 😊" });
    send('complete', { provider: 'gemini' });
    res.end();
  }, 10000);

  send('meta', { ok: true, provider: 'gemini' });

  try {
    let userQuery = String(message || "").trim();

    // 1) CONTEXTO INTELIGENTE: Enriquecer query vaga com histórico (melhorado com NLP, summary persistente e preferências)
    let finalQuery = userQuery;
    let contextSummary = session.metadata.contextSummary || {};
    
    // Regex expandida
    const vagueModelMatch = userQuery.match(/(quero|procuro|tem|modelo|vers[ãa]o|o|a|esse|este|pro|max|plus|mini|se)?\s*(\d{1,3})(?:\s*(pro\s*max|pro\s*|max|plus|mini|se|promax))?/ig);
    const numericOnlyMatch = userQuery.match(/^\d{1,3}(?:\s*(pro\s*max|pro|max|plus|mini|se))?$/i);
    
    const needsContext = (vagueModelMatch || numericOnlyMatch) && !/\b(iphone|samsung|xiaomi|apple|perfume|drone|celular|smartphone|notebook|tv)\b/i.test(userQuery);
    
    if (needsContext) {
      try {
        const messages = await storage.getAssistantMessages(sessionId);
        const recentUserMessages = messages
          .filter(m => m.role === 'user')
          .slice(-10)
          .reverse();
        
        // Usar NLP para extrair entidades
        let contextAnchor = '';
        for (const msg of recentUserMessages) {
          const doc = nlp(msg.content);
          const entities = doc.topics().out('array'); // Extrai tópicos/marcas
          const potentialAnchor = entities.find(e => /iphone|apple|samsung|galaxy|xiaomi|perfume|drone|celular|smartphone|notebook|tv/i.test(e));
          if (potentialAnchor) {
            contextAnchor = potentialAnchor;
            break;
          }
        }
        
        // Fallback para contextSummary persistente
        if (!contextAnchor && contextSummary.ultimaMarca) {
          contextAnchor = contextSummary.ultimaMarca;
        }
        
        if (contextAnchor) {
          let modelString = '';
          if (vagueModelMatch) {
            const number = vagueModelMatch[2];
            const variant = vagueModelMatch[3] || '';
            modelString = `${number} ${variant}`.trim();
          } else if (numericOnlyMatch) {
            modelString = numericOnlyMatch[0];
          }
          
          finalQuery = `${contextAnchor} ${modelString}`.replace(/\s+/g, ' ').trim();
          logger.info(`🧠 [Context] Enriquecendo query: "${userQuery}" → "${finalQuery}" usando anchor "${contextAnchor}"`);
          
          // Extrair preferências via NLP
          const doc = nlp(userQuery);
          const priceTerms = doc.match('(barato|caro|orçamento|preço até|preço máximo)').out('array');
          const colorTerms = doc.match('(azul|vermelho|preto|branco|dourado)').out('array');
          
          contextSummary = {
            ...contextSummary,
            ultimaMarca: contextAnchor,
            preferencias: {
              preco: priceTerms.length > 0 ? priceTerms[0] : contextSummary.preferencias?.preco,
              cor: colorTerms.length > 0 ? colorTerms[0] : contextSummary.preferencias?.cor,
            },
          };
          
          // Atualizar contextSummary
          await saveWithRetry(() => storage.updateAssistantSession(sessionId, { metadata: { ...session.metadata, contextSummary } }));
        } else {
          logger.info('🧠 [Context] Nenhum contexto encontrado');
        }
      } catch (error) {
        logger.warn('❌ Erro ao buscar contexto:', error);
      }
    }

    // 2) Mostra primeiro (prefetch com a query enriquecida) - SEMPRE (com filtros dinâmicos se aplicável)
    // Exemplo: extrair filtros da query (simples, pode expandir)
    let minPrice, maxPrice, brand;
    if (/preço mínimo (\d+)/i.test(userQuery)) minPrice = parseInt(RegExp.$1);
    if (/preço máximo (\d+)/i.test(userQuery)) maxPrice = parseInt(RegExp.$1);
    if (/marca (\w+)/i.test(userQuery)) brand = RegExp.$1;
    
    const ofertas = finalQuery ? await buscarOfertas({ query: finalQuery, maxResultados: 12, minPrice, maxPrice, brand }) : [];
    logger.info(`🔍 [Final Search] Buscando com query final: "${finalQuery}" | Encontrados: ${ofertas.length} produtos`);

    // 3) Resposta fluida com Gemini
    let finalMessage;
    if (ofertas.length > 0) {
      const topProducts = ofertas.slice(0, 3);
      const productList = topProducts.map(p => 
        `${p.title} por $${p.price?.USD || 'consultar'} na ${p.storeName}`
      ).join(', ');

      try {
        const { GoogleGenerativeAI } = await import('@google/generative-ai');
        const geminiAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY || '');
        
        const model = geminiAI.getGenerativeModel({ model: 'gemini-1.5-flash-latest' }); // Atualizado para versão mais recente
        
        const systemPrompt = `
          Você é um assistente de compras amigável e fluido, como um vendedor experiente em uma loja.
          Responda em português, com tom natural e conversacional, sem soar robótico.
          Sempre mostre os produtos encontrados primeiro, destacando detalhes como preço ou loja de forma breve.
          Inclua uma pergunta leve para engajar o usuário, com base no contexto da query.
          Evite pedir informações obrigatórias ou bloquear a conversa; faça suposições inteligentes se necessário.
        `;

        const prompt = `
          ${systemPrompt}
          O usuário perguntou: "${userQuery}".
          Produtos encontrados: ${productList}.
          Contexto da sessão: ${JSON.stringify(contextSummary)}.
          Gere uma resposta fluida, mencionando os produtos e fazendo uma pergunta leve para refinar a busca.
        `;

        const result = await model.generateContent(prompt);
        finalMessage = sanitizeChatGemini(result.response.text() || `Encontrei: ${productList} 📱`);
        
        // Logging de uso (tokens)
        if (result.usage) {
          logger.info(`Gemini usage: prompt_tokens: ${result.usage.promptTokenCount}, completion_tokens: ${result.usage.completionTokenCount}`);
        }
      } catch (geminiError) {
        logger.error('Erro no Gemini:', geminiError);
        // Fallback dinâmico (mantém fluidez)
        const count = ofertas.length;
        const firstProduct = topProducts[0];
        finalMessage = count === 1
          ? `Olha, achei um ${firstProduct.title} por $${firstProduct.price?.USD || 'consultar'} na ${firstProduct.storeName}. Quer saber mais sobre ele? 😊`
          : `Encontrei ${count} opções, como ${productList}. Algum desses te interessa ou quer refinar a busca? 😊`;
      }
    } else {
      // Resposta fluida para nenhum resultado
      try {
        const { GoogleGenerativeAI } = await import('@google/generative-ai');
        const geminiAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY || '');
        const model = geminiAI.getGenerativeModel({ model: 'gemini-1.5-flash-latest' });

        const systemPrompt = `
          Você é um assistente de compras amigável e fluido.
          Responda em português, com tom natural, sugerindo alternativas ou perguntas para manter a conversa.
          Evite dizer que precisa de mais informações; faça suposições baseadas no contexto.
        `;

        const prompt = `
          ${systemPrompt}
          O usuário perguntou: "${userQuery}".
          Nenhum produto foi encontrado.
          Contexto da sessão: ${JSON.stringify(contextSummary)}.
          Sugira uma alternativa ou faça uma pergunta para continuar a conversa.
        `;

        const result = await model.generateContent(prompt);
        finalMessage = sanitizeChatGemini(result.response.text());
      } catch (geminiError) {
        logger.error('Erro no Gemini (no results):', geminiError);
        finalMessage = `Não achei nada para "${userQuery}", mas que tal tentar algo como "iPhone 13" ou "Samsung S24"? 😊`;
      }
    }

    // 4) Reduzir perguntas repetitivas
    const recentMessages = await storage.getAssistantMessages(sessionId);
    const recentAssistantMessages = recentMessages
      .filter(m => m.role === 'assistant' && m.metadata?.showThenAsk)
      .slice(-3);
    const hasRecentQuestion = recentAssistantMessages.some(m => m.content.includes('?'));
    
    if (hasRecentQuestion) {
      finalMessage = finalMessage.replace(/\?.*$/, '.'); // Remover pergunta se já fez recentemente
    }

    // 5) Entrega: chat curto + ofertas para o painel
    send('delta', { text: finalMessage });
    
    await saveWithRetry(() => storage.createAssistantMessage({
      sessionId,
      role: 'assistant',
      content: finalMessage,
      metadata: { streamed: true, timestamp: new Date().toISOString(), provider: 'gemini', showThenAsk: true }
    }));

  } catch (error) {
    logger.error('Erro no chat Gemini:', error);
    send('delta', { text: "Não consegui processar agora, mas posso sugerir alguns iPhones populares, como o iPhone 13 por $600. Quer continuar? 😊" });
  }

  send('complete', { provider: 'gemini' });
  res.end();
  clearTimeout(watchdogTimeout);
});

// =============================================
// ANÁLISE DO CÓDIGO GEMINI REESCRITO COM FLUIDEZ
// =============================================

/*
MELHORIAS IMPLEMENTADAS (TODAS AS DISCUTIDAS):

1. CONTEXTO INTELIGENTE:
   - Regex expandida com mais flags e padrões.
   - Integração com compromise para NLP (extração de entidades).
   - ContextSummary persistente na sessão para acesso rápido.
   - Extração de preferências (preço, cor) via NLP para respostas proativas.

2. BUSCA DE PRODUTOS:
   - Normalização com fuzzysearch.
   - Ranking ponderado por preço e rating.
   - Cache in-memory com NodeCache.
   - Filtros dinâmicos (minPrice, maxPrice, brand) extraídos da query.
   - Sinônimos para reduzir "zero resultados".

3. TEMPLATES DE RESPOSTA:
   - Substituídos por geração dinâmica com Gemini para respostas naturais.
   - Categorias expandidas (adicionadas notebook e TV).

4. INTEGRAÇÃO GEMINI API:
   - Modelo atualizado para gemini-1.5-flash-latest.
   - Prompt otimizado com system prompt para fluidez.
   - Logging de tokens para monitoramento de custos.
   - Sanitização expandida para PII e promoções.
   - Geração de respostas com contexto e suposições inteligentes.
   - Fallbacks dinâmicos para manter fluidez.

5. ESCALABILIDADE E SEGURANÇA:
   - Validação com Zod.
   - Anti-duplicidade checando última mensagem.
   - Retries com p-retry para storage.
   - Logging estruturado com Winston.
   - Watchdog para SSE (evita travamentos).

6. USABILIDADE E MANUTENÇÃO:
   - Perguntas leves integradas naturalmente no Gemini.
   - Redução de perguntas repetitivas.
   - Respostas proativas com preferências do contextSummary.
   - Evita bloqueios com sugestões alternativas.

PONTOS FORTES MANTIDOS E APRIMORADOS:
✅ Contexto mais robusto e proativo
✅ Fallbacks com dados reais e dinâmicos
✅ Sistema show-then-ask preservado, mas fluido

PONTOS FRACOS RESOLVIDOS:
✅ Dependência API com logging e fallbacks
✅ Regex melhorada
✅ Busca tokenizada/fuzzy com sinônimos
✅ Anti-duplicidade adicionado
✅ Memória persistente com preferências
✅ Sem templates fixos, respostas naturais

SUGESTÕES ADICIONAIS:
- Adicionar rate-limiting no Express level.
- Integrar testes unitários.
- Para multi-provider, criar abstração AIProvider.
*/