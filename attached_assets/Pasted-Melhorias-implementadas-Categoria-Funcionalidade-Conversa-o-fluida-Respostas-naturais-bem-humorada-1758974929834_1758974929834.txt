Melhorias implementadas
Categoria	Funcionalidade
ConversaÃ§Ã£o fluida	Respostas naturais, bem-humoradas, estilo vendedor
SaudaÃ§Ã£o personalizada	Cumprimenta o usuÃ¡rio pelo nome e com base no horÃ¡rio local
DetecÃ§Ã£o de intenÃ§Ã£o	Reconhece follow-ups como â€œgosteiâ€, â€œquero outroâ€, â€œmais baratoâ€
GeraÃ§Ã£o dinÃ¢mica de resposta	Frases livres e variadas, sem templates fixos
MemÃ³ria por usuÃ¡rio	Armazena preferÃªncias, produtos vistos, estilo de conversa
Evita citar lojas	Usa linguagem neutra como â€œvÃ¡rias opÃ§Ãµes disponÃ­veisâ€
CorreÃ§Ã£o de horÃ¡rio	Usa hora local enviada pelo frontend para saudaÃ§Ã£o correta
ModularizaÃ§Ã£o	CÃ³digo organizado em mÃ³dulos para manutenÃ§Ã£o e escalabilidade
ðŸ§  Estrutura de Arquivos
CÃ³digo
/gemini-assistant
â”œâ”€â”€ routes/
â”‚   â””â”€â”€ gemini.ts
â”œâ”€â”€ lib/
â”‚   â”œâ”€â”€ respostas.ts
â”‚   â”œâ”€â”€ followup.ts
â”‚   â”œâ”€â”€ memoria.ts
â”‚   â””â”€â”€ utils.ts
ðŸ“¦ CÃ³digo principal â€” routes/gemini.ts
ts
import { buscarOfertas } from '@/lib/gemini/busca';
import { persistSessionAndMessage, getSessionMessages, salvarResposta } from '@/lib/gemini/session';
import { gerarSaudacao, saudacaoInicial } from '@/lib/gemini/utils';
import { detectarIntencaoFollowUp, responderFollowUp } from '@/lib/gemini/followup';
import { gerarRespostaConversacional, gerarPerguntaLeve } from '@/lib/gemini/respostas';
import { getUserMemory, updateUserMemory } from '@/lib/gemini/memoria';

export default async function handler(req, res) {
  const { message, sessionId, horaLocal } = req.body;
  const user = req.user || req.session?.user;
  const userName = user?.name || 'cliente';
  const userId = user?.id;

  res.setHeader('Content-Type', 'text/event-stream; charset=utf-8');
  res.setHeader('Cache-Control', 'no-cache');
  res.setHeader('Connection', 'keep-alive');
  res.flushHeaders?.();

  const send = (event, payload) => {
    res.write(`event: ${event}\n`);
    res.write(`data: ${JSON.stringify(payload)}\n\n`);
  };

  await persistSessionAndMessage(sessionId, userId, message);
  const mensagens = await getSessionMessages(sessionId);
  const memoria = await getUserMemory(userId);

  // SaudaÃ§Ãµes simples
  if (/^(bom dia|boa tarde|boa noite|oi|olÃ¡)$/i.test(message.trim())) {
    const saudacao = gerarSaudacao(userName, horaLocal);
    send('delta', { text: `${saudacao} Como posso te ajudar hoje? ðŸ˜Š` });
    send('complete', { provider: 'gemini' });
    return res.end();
  }

  // Follow-up inteligente
  const intencao = detectarIntencaoFollowUp(message);
  if (intencao) {
    const resposta = responderFollowUp(intencao);
    send('delta', { text: resposta });
    send('complete', { provider: 'gemini' });
    return res.end();
  }

  // Enriquecer contexto
  const contexto = mensagens.map(m => m.text).join(' | ');
  const finalQuery = message.length < 4 ? `${contexto} ${message}` : message;

  // Buscar produtos
  const produtos = await buscarOfertas({ query: finalQuery });
  send('products', { products: produtos, query: finalQuery, provider: 'gemini' });

  // Atualizar memÃ³ria
  await updateUserMemory(userId, {
    ultimaBusca: finalQuery,
    produtosVistos: produtos.map(p => p.id),
  });

  // Gerar resposta
  const saudacao = saudacaoInicial(mensagens) ? gerarSaudacao(userName, horaLocal) : '';
  const resposta = gerarRespostaConversacional(finalQuery, produtos, memoria);
  const pergunta = gerarPerguntaLeve(finalQuery);

  const textoFinal = [saudacao, resposta, pergunta].filter(Boolean).join(' ');
  send('delta', { text: textoFinal });

  await salvarResposta(sessionId, textoFinal);
  send('complete', { provider: 'gemini' });
  res.end();
}
ðŸ§© MÃ³dulos auxiliares
lib/utils.ts
ts
export function gerarSaudacao(nome: string, horaLocal?: number) {
  const hora = horaLocal ?? new Date().getHours();
  const base = hora < 12 ? 'Bom dia' : hora < 18 ? 'Boa tarde' : 'Boa noite';
  return `${base}, ${nome}! ðŸ‘‹`;
}

export function saudacaoInicial(mensagens: any[]) {
  return mensagens.length <= 1;
}
lib/followup.ts
ts
export function detectarIntencaoFollowUp(msg: string) {
  const m = msg.toLowerCase();
  if (m.includes('gostei') || m.includes('quero esse')) return 'confirmar';
  if (m.includes('nÃ£o gostei') || m.includes('mostra outros')) return 'rejeitar';
  if (m.includes('128gb') || m.includes('mais barato')) return 'refinar';
  return null;
}

export function responderFollowUp(tipo: string) {
  switch (tipo) {
    case 'confirmar': return 'Ã“tima escolha! Posso te ajudar a finalizar ou mostrar acessÃ³rios ðŸ›ï¸';
    case 'rejeitar': return 'Sem problemas! Vou buscar outras opÃ§Ãµes que talvez te agradem mais ðŸ”„';
    case 'refinar': return 'Entendi! Vou ajustar a busca com base no que vocÃª quer ðŸ”';
    default: return 'Se quiser refinar ou ver mais, Ã© sÃ³ me dizer ðŸ˜‰';
  }
}
lib/respostas.ts
ts
export function gerarRespostaConversacional(query: string, produtos: any[], memoria: any) {
  if (produtos.length === 0) return 'NÃ£o achei nada com esse termo. Me dÃ¡ mais detalhes que eu busco certinho ðŸ™‚';
  const segmento = detectarSegmento(query, produtos);
  const marcaFavorita = memoria?.marca_preferida;

  const frases = [
    `Olha sÃ³, ${segmento} Ã© comigo mesmo! Separei umas opÃ§Ãµes que estÃ£o com preÃ§o Ã³timo ðŸ’¸`,
    `VocÃª vai curtir essas sugestÃµes de ${segmento}. Se quiser algo mais especÃ­fico, me dÃ¡ um toque ðŸ˜‰`,
    `Tem bastante coisa boa rolando em ${segmento}. DÃ¡ uma olhada e me diz o que achou ðŸ‘€`,
    `Separei umas opÃ§Ãµes de ${segmento} que estÃ£o fazendo sucesso. Se tiver uma marca em mente, me fala que eu afino a busca ðŸ”`
  ];

  if (marcaFavorita) {
    frases.push(`Como vocÃª curte ${marcaFavorita}, achei umas opÃ§Ãµes que podem te agradar ðŸ˜Ž`);
  }

  return frases[Math.floor(Math.random() * frases.length)];
}

export function gerarPerguntaLeve(query: string) {
  if (/iphone/i.test(query)) return 'Prefere linha 13 ou 15?';
  if (/drone/i.test(query)) return 'Quer um modelo compacto ou com cÃ¢mera parruda?';
  if (/perfume/i.test(query)) return 'Tem alguma marca favorita (Dior, Calvin Klein...)?';
  return '';
}

function detectarSegmento(query: string, produtos: any[]) {
  if (/perfume/i.test(query)) return 'perfumes';
  if (/iphone|celular|smartphone/i.test(query)) return 'celulares';
  if (/drone/i.test(query)) return 'drones';
  return 'produtos';
}
lib/memoria.ts
ts
const memoriaUsuarios = {};

export async function getUserMemory(userId: string) {
  return memoriaUsuarios[userId] || {};
}

export async function updateUserMemory(userId: string, dados: any) {
  memoriaUsuarios[userId] = {
    ...memoriaUsuarios[userId],
    ...dados
  };
}