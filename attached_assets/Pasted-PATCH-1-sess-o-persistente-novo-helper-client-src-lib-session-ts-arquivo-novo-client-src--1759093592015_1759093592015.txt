PATCH 1 ‚Äî sess√£o persistente (novo helper)

client/src/lib/session.ts (arquivo novo)

// client/src/lib/session.ts
export async function getPersistedSessionId(): Promise<string> {
  const KEY = "gemini.sessionId";
  let sid = localStorage.getItem(KEY);
  if (sid && sid.trim()) return sid;

  try {
    const r = await fetch("/api/assistant/sessions");
    const j = await r.json();
    sid = j?.sessionId || `web_${Math.random().toString(36).slice(2)}`;
  } catch {
    sid = `web_${Math.random().toString(36).slice(2)}`;
  }
  localStorage.setItem(KEY, sid);
  return sid;
}

PATCH 2 ‚Äî usar text do backend + fix de sess√£o

client/src/components/GeminiAssistantBar.tsx (trechos a alterar)

@@
+import { getPersistedSessionId } from "@/lib/session";
@@
-// (havia um cache em mem√≥ria tipo geminiSessionCache...)
-// const cached = geminiSessionCache.get(key);
-// ...isso quebra quando a p√°gina recarrega e pode trocar a sess√£o
+// Mant√©m a mesma sess√£o entre turnos e recargas
+const [sessionId, setSessionId] = useState<string | null>(null);
+useEffect(() => {
+  let alive = true;
+  (async () => {
+    const sid = await getPersistedSessionId();
+    if (alive) setSessionId(sid);
+  })();
+  return () => { alive = false; };
+}, []);
@@
-function pickAssistantText(resp: any) {
-  const serverText = resp?.text && String(resp.text).trim();
-  if (serverText) return serverText;
-  // fallback local (causava o "n√£o achei...")
-  if (Array.isArray(resp?.items) && resp.items.length > 0) {
-    return "Separei algumas op√ß√µes pra voc√™ üòâ";
-  }
-  return "N√£o encontrei resultados agora, mas posso tentar com outra marca, modelo ou faixa de pre√ßo.";
-}
+function pickAssistantText(resp: any) {
+  // SEMPRE prioriza o texto do servidor
+  const t = (resp?.text || "").trim();
+  if (t) return t;
+  // fallback m√≠nimo s√≥ se o servidor realmente n√£o mandou text
+  if (Array.isArray(resp?.items) && resp.items.length > 0) return "Separei algumas op√ß√µes pra voc√™ üòâ";
+  return "Posso tentar com outra marca, modelo ou faixa de pre√ßo. üôÇ";
+}
@@
-async function startGeminiStream(/* args atuais */) {
+async function startGeminiStream(/* args atuais */) {
   // ... valida√ß√µes
+  if (!sessionId) return; // aguarda inicializar a sess√£o
@@
-  const res = await fetch("/api/assistant/query", {
+  const res = await fetch("/api/assistant/query", {
     method: "POST",
     headers: { "Content-Type": "application/json" },
-    body: JSON.stringify({ sessionId, message: userMessage, lang }),
+    body: JSON.stringify({ sessionId, message: userMessage, lang }),
   });
   const data = await res.json();
-  const items = data?.items ?? [];
-  let finalMessage = "";
-
-  // ‚ùå Fallback antigo baseado em items.length === 0
-  // if (!items.length) {
-  //   finalMessage = `Hmm, n√£o achei nada pra "${userMessage}". üòÖ Quer tentar outra marca ou modelo?`;
-  // } else {
-  //   finalMessage = data.text ?? "Encontrei algumas op√ß√µes!";
-  // }
-  finalMessage = pickAssistantText(data);
+  const items = Array.isArray(data?.items) ? data.items : [];
+  const finalMessage = pickAssistantText(data);
@@
-  // opcional: debug
-  // console.debug("assistant debug:", data?.debug);
+  // Debug √∫til para checar heran√ßa de foco e ‚Äúmais barato‚Äù
+  if (data?.debug) {
+    console.debug("assistant debug >", {
+      priceOnlyFollowUp: data.debug?.priceOnlyFollowUp,
+      sort: data.debug?.query?.sort,
+      focoAtual: data.debug?.session?.focoAtual,
+      lastQuery: data.debug?.session?.lastQuery,
+      categoriaAtual: data.debug?.session?.categoriaAtual,
+      itens: items.length
+    });
+  }
@@
-  // render dos cards
-  if (items.length) setGeminiResults(items);
-  else setGeminiResults([]);
+  // Cards de produto (ou limpa)
+  setGeminiResults(items);
 }


Al√©m disso, remova qualquer mensagem local parecida com:
Hmm, n√£o achei nada pra "${userMessage}"...
Use este grep pra localizar e apagar:

rg -n "barato|n√£o achei|N√£o encontrei resultados" client/
