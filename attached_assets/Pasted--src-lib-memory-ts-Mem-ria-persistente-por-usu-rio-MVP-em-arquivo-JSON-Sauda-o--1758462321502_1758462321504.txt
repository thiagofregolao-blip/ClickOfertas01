// src/lib/memory.ts
/**
 * Mem√≥ria persistente por usu√°rio (MVP em arquivo JSON).
 * + Sauda√ß√£o natural e n√£o repetitiva baseada em hor√°rio/cidade/visitas.
 *
 * Troca futura por DB (Redis/SQL): mantenha a mesma interface p√∫blica.
 */

import fs from 'fs/promises';
import path from 'path';
import { fileURLToPath } from 'url';
import OpenAI from 'openai';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const DB_PATH = path.join(__dirname, '..', '..', 'data', 'memory.json');

export type UserMemory = {
  userId: string;
  profile: {
    name?: string;
    preferredCity?: 'Ciudad del Este' | 'Salto del Guair√°' | 'Pedro Juan Caballero' | '';
  };
  prefs: {
    budget?: 'baixo'|'medio'|'alto';
    mode?: 'a-pe'|'app'|'carro';
  };
  history: {
    lastIntent?: string;
    lastCategories?: string[];
    lastProducts?: string[];
    lastStores?: string[];
  };
  lastSummary?: string;
  lastSeen: string;
  counters: { visits: number };
  greetHistory?: number[]; // √≠ndices usados recentemente para evitar repeti√ß√£o
};

type DB = UserMemory[];

async function readDB(): Promise<DB> {
  try {
    const raw = await fs.readFile(DB_PATH, 'utf-8');
    return JSON.parse(raw || '[]');
  } catch {
    return [];
  }
}

async function writeDB(db: DB) {
  await fs.writeFile(DB_PATH, JSON.stringify(db, null, 2), 'utf-8');
}

/** Busca ou cria mem√≥ria vazia para userId. */
export async function getUserMemory(userId: string, name?: string): Promise<UserMemory> {
  const db = await readDB();
  let m = db.find(x => x.userId === userId);
  if (!m) {
    m = {
      userId,
      profile: { name: name || '' , preferredCity: '' },
      prefs: {},
      history: { lastIntent:'', lastCategories:[], lastProducts:[], lastStores:[] },
      lastSummary: '',
      lastSeen: new Date().toISOString(),
      counters: { visits: 0 },
      greetHistory: []
    };
    db.push(m);
    await writeDB(db);
  }
  return m;
}

/** Atualiza e persiste mem√≥ria. */
export async function updateUserMemory(userId: string, patch: Partial<UserMemory>) {
  const db = await readDB();
  const i = db.findIndex(x => x.userId === userId);
  if (i === -1) return;
  db[i] = {
    ...db[i],
    ...patch,
    profile: { ...db[i].profile, ...patch.profile },
    prefs:   { ...db[i].prefs,   ...patch.prefs },
    history: {
      ...db[i].history,
      ...(patch.history || {}),
      lastCategories: patch.history?.lastCategories ?? db[i].history.lastCategories ?? [],
      lastProducts:   patch.history?.lastProducts   ?? db[i].history.lastProducts   ?? [],
      lastStores:     patch.history?.lastStores     ?? db[i].history.lastStores     ?? [],
    },
    greetHistory: patch.greetHistory ?? db[i].greetHistory ?? [],
    lastSeen: new Date().toISOString()
  };
  await writeDB(db);
}

/** Heur√≠stica simples para extrair categorias/cidade a partir do texto. */
export function extractSignals(message: string){
  const t = message.toLowerCase();
  const categories: string[] = [];
  if (/(iphone|samsung|galaxy|xiaomi|smartphone|celular)/.test(t)) categories.push('eletronicos');
  if (/(fone|headphone|jbl|sony|audio|soundbar)/.test(t))         categories.push('audio');
  if (/(perfume|parfum|cosm[e√©]tico)/.test(t))                    categories.push('perfumes');

  let preferredCity: UserMemory['profile']['preferredCity'] = '';
  if (/salto/i.test(t)) preferredCity = 'Salto del Guair√°';
  else if (/pedro\s*juan/i.test(t)) preferredCity = 'Pedro Juan Caballero';
  else if (/cde|ciudad\s*del\s*este/i.test(t)) preferredCity = 'Ciudad del Este';

  return { categories, preferredCity };
}

/** ----- RESUMO curto para mem√≥ria (opcional, j√° usado no projeto) ----- */
const client = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });
const CHAT_MODEL = process.env.CHAT_MODEL || 'gpt-4o-mini';

export async function summarizeForMemory(input: { message: string; reply: string; name?: string }) {
  const prompt = `
Resuma a conversa abaixo em at√© 2 linhas, focando inten√ß√£o e prefer√™ncias (cidade/or√ßamento/categorias).
PT-BR, direto.

Usu√°rio: ${input.name||'Cliente'}
Pergunta: ${input.message}
RespostaClick: ${input.reply}
`;
  const r = await client.chat.completions.create({
    model: CHAT_MODEL,
    messages: [{ role:'user', content: prompt }],
    temperature: 0.1,
    max_tokens: 80
  });
  return r.choices[0].message.content || '';
}

/** -------------------- SAUDA√á√ÉO NATURAL E N√ÉO REPETITIVA -------------------- */

const GREET_TEMPLATES: ((ctx: {
  name: string;
  tod: 'manh√£'|'tarde'|'noite';
  city?: string;
  visits: number;
}) => string)[] = [
  ({name, tod, city}) => `Ol√°, ${name}! Boa ${tod}${city ? ` em ${city}` : ''} üëã`,
  ({name, tod}) => `Oi, ${name}! Tudo certo por a√≠ nessa ${tod}?`,
  ({name, city}) => `Bem-vindo de volta, ${name}! ${city ? `Vamos explorar ${city} hoje?` : 'Pronto pra achar boas ofertas?'}`,
  ({name}) => `E a√≠, ${name}! Posso te mostrar as melhores ofertas de hoje?`,
  ({name, city}) => `Que bom te ver, ${name}! ${city ? `Tenho novidades de ${city}.` : 'Tenho novidades fresquinhas.'}`
];

/** Determina per√≠odo do dia. */
function timeOfDay(d = new Date()): 'manh√£'|'tarde'|'noite' {
  const h = d.getHours();
  if (h < 12) return 'manh√£';
  if (h < 18) return 'tarde';
  return 'noite';
}

/**
 * Retorna uma sauda√ß√£o curta:
 * - Usa nome (ou "Cliente").
 * - Considera cidade preferida quando houver.
 * - Evita repetir os √∫ltimos templates usados (greetHistory).
 * - Atualiza visits e greetHistory no retorno (caller persiste).
 */
export function makeNaturalGreeting(mem: UserMemory) {
  const name = mem.profile.name || 'Cliente';
  const tod = timeOfDay();
  const city = mem.profile.preferredCity || '';
  const visits = (mem.counters.visits || 0) + 1;

  const recent = new Set((mem.greetHistory || []).slice(-3)); // evita √∫ltimos 3
  // escolhe o primeiro template n√£o usado recentemente
  let idx = 0;
  for (let i=0;i<GREET_TEMPLATES.length;i++){
    if (!recent.has(i)) { idx = i; break; }
  }
  const text = GREET_TEMPLATES[idx]({ name, tod, city, visits }).trim();

  const nextHistory = [...(mem.greetHistory || []), idx].slice(-8); // mant√©m hist√≥rico curto
  const nextCounters = { visits };

  return { text, nextHistory, nextCounters };
}
ts
Copiar c√≥digo
// src/routes/assistant.ts
/**
 * Atualizado: /assistant/session agora retorna 'greeting' natural da mem√≥ria.
 * O restante (POST /message, GET /stream) permanece igual ao seu SSE atual.
 */

import { Router } from 'express';
import OpenAI from 'openai';
import { searchSuggestions, buildItinerary } from '../lib/tools.js';
import { maybeAttachPromo } from '../lib/promo.js';
import { getUserMemory, updateUserMemory, makeNaturalGreeting } from '../lib/memory.js';

const router = Router();
const client = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });
const CHAT_MODEL = process.env.CHAT_MODEL || 'gpt-4o-mini';

const SYSTEM_PROMPT = `
Voc√™ √© o Click, assistente de compras/viagens focado em Ciudad del Este, Salto del Guair√° e Pedro Juan Caballero.
Respostas curtas, PT-BR, sem inventar pre√ßos/estoques.
` as const;

/** ---------- NOVO: sess√£o com sauda√ß√£o de mem√≥ria ---------- */
router.post('/session', async (req, res)=>{
  try{
    const sessionId = 'sess-' + Math.random().toString(36).slice(2,10);

    // Pegamos identidade do usu√°rio (o front envia ap√≥s login)
    const userId   = (req.headers['x-user-id'] || '').toString() || 'anon';
    const userName = (req.headers['x-user-name'] || '').toString();

    // L√™/Cria mem√≥ria e gera sauda√ß√£o natural
    const mem = await getUserMemory(userId, userName);
    const g = makeNaturalGreeting(mem);

    // Persistimos contadores e hist√≥rico de sauda√ß√µes
    await updateUserMemory(userId, {
      profile: { name: userName || mem.profile.name },
      counters: g.nextCounters,
      greetHistory: g.nextHistory
    });

    res.json({
      ok:true,
      sessionId,
      createdAt: new Date().toISOString(),
      greeting: g.text // ‚Üê sauda√ß√£o pronta para usar no front
    });
  } catch (e) {
    console.error(e);
    res.json({ ok:true, sessionId: 'sess-'+Math.random().toString(36).slice(2,10), greeting: 'Ol√°! Posso ajudar hoje?' });
  }
});

/** ---------- (SUAS rotas existentes ‚Äî sem mudan√ßas) ---------- */
// ... mantenha aqui seu POST /assistant/message (com SSE params se j√° aplicou as otimiza√ß√µes)
// ... e o GET /assistant/stream (SSE) que voc√™ j√° est√° usando.

export default router;
tsx
Copiar c√≥digo
// web/SearchDock.tsx
/**
 * Pequena mudan√ßa: usamos a sauda√ß√£o vinda de /assistant/session (greeting).
 * Mantemos o streaming ‚Äúoi‚Äù no foco se voc√™ quiser, mas a sauda√ß√£o j√° aparece de cara.
 */

import React, { useEffect, useMemo, useRef, useState } from 'react';
import { SearchBarClick } from './SearchBarClick';

type Store = { id:string; name:string; label?:string; mall?:string };
type Product = { id:string; title:string; category?:string; price?:any; score?:number; storeId?:string };
type SuggestResponse = { ok:boolean; category?:string; topStores:Store[]; products:Product[]; scratchcard?:any };

export default function SearchDock() {
  const uid = useMemo(()=> localStorage.getItem('uid') || (localStorage.setItem('uid', 'u-'+Math.random().toString(36).slice(2,8)), localStorage.getItem('uid')!), []);
  const userName = useMemo(()=> localStorage.getItem('userName') || 'Cliente', []);

  const [sessionId, setSessionId] = useState<string>('');
  const [greeting, setGreeting] = useState<string>(''); // ‚Üê NOVO: sauda√ß√£o da mem√≥ria
  const [query, setQuery] = useState<string>('');
  const [sug, setSug] = useState<SuggestResponse | null>(null);
  const [loading, setLoading] = useState<boolean>(false);

  // SSE
  const [streamingText, setStreamingText] = useState<string>('');
  const esRef = useRef<EventSource|null>(null);

  useEffect(()=> {
    // Agora enviamos cabe√ßalhos com user id/nome para receber greeting personalizado
    fetch('/assistant/session', {
      method:'POST',
      headers: { 'x-user-id': uid, 'x-user-name': userName }
    })
      .then(r=>r.json())
      .then(d=> { setSessionId(d.sessionId); setGreeting(d.greeting || ''); });
  }, [uid, userName]);

  function startStream(message: string) {
    if (esRef.current) { esRef.current.close(); esRef.current = null; }
    setStreamingText('');

    const qs = new URLSearchParams({ sessionId, message, userId: uid, userName });
    const es = new EventSource(`/assistant/stream?${qs.toString()}`);
    esRef.current = es;
    es.onmessage = (evt) => {
      try {
        const payload = JSON.parse(evt.data);
        if (payload.type === 'chunk' && payload.text) setStreamingText(prev => prev + payload.text);
      } catch { setStreamingText(prev => prev + evt.data); }
    };
    es.onerror = () => { es.close(); esRef.current = null; };
  }
  useEffect(()=> () => { esRef.current?.close(); }, []);

  async function handleFocusStart() {
    // opcional: iniciar stream de "oi"
    if (sessionId) startStream('oi');
  }
  async function handleQueryChange(text:string){
    setQuery(text);
    const q = text.trim();
    if (!q) { setSug(null); return; }
    try{
      setLoading(true);
      const r = await fetch(`/suggest?q=${encodeURIComponent(q)}`, { headers:{ 'x-user-id': uid }});
      const data = await r.json();
      setSug(data);
    } finally { setLoading(false); }
  }
  async function handleSubmit(text:string){ if (text.trim()) startStream(text.trim()); }

  return (
    <div className="w-full">
      <SearchBarClick
        onFocusStart={handleFocusStart}
        onChangeQuery={handleQueryChange}
        onSubmitQuery={handleSubmit}
      />

      <div className="mt-4 space-y-4">
        {/* Mostra sauda√ß√£o natural da mem√≥ria (se existir); abaixo segue o streaming ao vivo */}
        <div className="rounded-2xl border bg-white/80 backdrop-blur p-4 shadow-sm min-h-[72px]">
          <div className="text-sm text-gray-500 mb-1">Click</div>
          <div className="whitespace-pre-wrap">
            {greeting || `Ol√°, ${userName}!`}
            {streamingText ? `\n${streamingText}` : ''}
          </div>
        </div>

        <div className="rounded-2xl border bg-white/80 backdrop-blur p-4 shadow-sm">
          <div className="flex items-center justify-between mb-3">
            <div className="text-sm text-gray-500">
              {loading ? 'Buscando ofertas‚Ä¶' : (query ? `Resultados para ‚Äú${query}‚Äù` : 'Ofertas e destaques')}
            </div>
            {sug?.category ? <div className="text-xs px-2 py-1 rounded-full border bg-gray-50">{sug.category}</div> : null}
          </div>

          {!sug ? (
            <div className="text-gray-500 text-sm">Sem resultados ainda. Digite algo na barra acima.</div>
          ) : (
            <div className="grid grid-cols-12 gap-4">
              <div className="col-span-12 md:col-span-4">
                <div className="text-sm font-semibold mb-2">Melhores lojas</div>
                <div className="grid gap-2">
                  {(sug.topStores || []).map((s, i) => (
                    <div key={s.id} className="p-3 rounded-xl border hover:shadow-sm transition-all">
                      <div className="flex items-center justify-between">
                        <div className="font-medium truncate">{s.name}</div>
                        {i<2 && s.label ? (
                          <span className="text-[10px] px-1 py-0.5 rounded bg-amber-100 border border-amber-300">{s.label}</span>
                        ) : null}
                      </div>
                      {s.mall ? <div className="text-xs text-gray-500 mt-1">{s.mall}</div> : null}
                    </div>
                  ))}
                  {(!sug.topStores || !sug.topStores.length) && (
                    <div className="text-xs text-gray-500">Nenhuma loja no momento.</div>
                  )}
                </div>
              </div>

              <div className="col-span-12 md:col-span-8">
                <div className="text-sm font-semibold mb-2">Ofertas e produtos</div>
                <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-3">
                  {(sug.products || []).map((p) => (
                    <div key={p.id} className="p-3 rounded-xl border hover:shadow-sm transition-all">
                      <div className="font-medium truncate mb-1">{p.title}</div>
                      <div className="text-xs text-gray-500 mb-2">
                        {p.category || '‚Äî'} {('score' in p && p.score !== undefined) ? `‚Ä¢ score ${p.score}` : ''}
                      </div>
                      <div className="text-sm">
                        {p.price?.USD ? <>USD <b>{p.price.USD}</b></> : <span className="text-gray-400">sem pre√ßo</span>}
                      </div>
                    </div>
                  ))}
                  {(!sug.products || !sug.products.length) && (
                    <div className="text-xs text-gray-500">Nenhum produto encontrado.</div>
                  )}
                </div>
              </div>
            </div>
          )}
        </div>

      </div>
    </div>
  );
}
Como funciona (r√°pido)
Mem√≥ria guarda nome, cidade e um hist√≥rico de templates usados em sauda√ß√µes.

Ao criar sess√£o (POST /assistant/session), o backend:

carrega a mem√≥ria do usu√°rio (via x-user-id/x-user-name);

gera uma sauda√ß√£o variando template + hor√°rio + cidade;

retorna greeting j√° pronto e atualiza visits e greetHistory.

O front mostra esse greeting imediatamente no painel acima da barra.

No foco da barra, voc√™ pode iniciar o SSE como antes (opcional).