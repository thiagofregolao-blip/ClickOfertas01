perfeito ‚Äî aqui v√£o os diffs m√≠nimos para corrigir o sintoma (card continua ‚ÄúRASPE!‚Äù ap√≥s gerar cupom).
Eles fazem 3 coisas: (1) a consulta de elegibilidade realmente roda, (2) a UI √© atualizada na hora do sucesso (optimistic + refetch), e (3) o overlay para de receber eventos/CPU ap√≥s o reveal. Tamb√©m deixo 1 linha no backend para impedir cache.

1) client/src/components/scratch-card.tsx

Adicionar queryFn, invalidar cache no sucesso, e cortar eventos/RAF ap√≥s reveal.

--- a/client/src/components/scratch-card.tsx
+++ b/client/src/components/scratch-card.tsx
@@
-import { useMutation, useQuery } from "@tanstack/react-query";
+import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
@@
 export default function ScratchCard({ product, currency, themeColor, onRevealed, onClick }: ScratchCardProps) {
+  const qc = useQueryClient();
@@
-  // Query para verificar elegibilidade
-  const { data: eligibility, refetch: checkEligibility } = useQuery({
-    queryKey: ['/api/scratch/offers', product.id, 'eligibility'],
-    retry: false,
-  });
+  // Query para verificar elegibilidade (AGORA COM queryFn REAL)
+  const { data: eligibility, refetch: checkEligibility } = useQuery({
+    queryKey: ['/api/scratch/offers', product.id, 'eligibility'],
+    queryFn: async () => {
+      const r = await apiRequest(`/api/scratch/offers/${product.id}/eligibility`);
+      return r.json();
+    },
+    enabled: !!product?.id,
+    staleTime: 15_000,
+    retry: false,
+  });
@@
   const generateCouponMutation = useMutation({
@@
-    onSuccess: (data: any) => {
+    onSuccess: (data: any) => {
       if (data?.success && data?.coupon) {
         setCoupon(data.coupon);
         setCouponGenerated(true);
         setShowModal(false);
         setShowCouponModal(true);
@@
         toast({
           title: "üéâ Cupom gerado!",
           description: "Veja os detalhes do seu cupom!",
           duration: 3000,
         });
+
+        // 1) Atualiza a elegibilidade IMEDIATAMENTE (optimistic)
+        qc.setQueryData(
+          ['/api/scratch/offers', product.id, 'eligibility'],
+          () => ({
+            eligible: false,
+            hasActive: true,
+            activeOffer: {
+              productId: product.id,
+              status: 'revealed',
+              expiresAt: data.coupon.expiresAt, // timer do lado do servidor
+            },
+          })
+        );
+        // 2) Confirma com o servidor
+        qc.invalidateQueries({ queryKey: ['/api/scratch/offers', product.id, 'eligibility'] });
       }
     },
@@
       } else {
         toast({
           title: "üòÖ Ops, algo deu errado",
           description: "Tente novamente em alguns segundos",
           variant: "destructive",
           duration: 3000,
         });
+        // Em erro gen√©rico tamb√©m vale refazer elegibilidade, para garantir estado correto
+        qc.invalidateQueries({ queryKey: ['/api/scratch/offers', product.id, 'eligibility'] });
       }
     }
   });
@@
-          <canvas
+          <canvas
             ref={canvasRef}
-            className={`absolute inset-0 w-full h-full cursor-pointer transition-all duration-200 ${
-              isFading ? 'opacity-0 scale-105' : 'opacity-100 scale-100'
-            }`}
+            className={`absolute inset-0 w-full h-full cursor-pointer transition-all duration-200 ${
+              isFading ? 'opacity-0 scale-105 pointer-events-none' : 'opacity-100 scale-100'
+            }`}
             onMouseDown={handleMouseDown}
             onMouseMove={handleMouseMove}
             onMouseUp={handleMouseUp}
             onMouseLeave={handleMouseUp}
             onTouchStart={handleTouchStart}
             onTouchMove={handleTouchMove}
             onTouchEnd={handleTouchEnd}
             style={{ touchAction: 'none', display: 'block' }}
           />
@@
   );
 }
+
+// üîï Garantir que o rAF pare ap√≥s revelar e no unmount
+// (coloque dentro do componente, pr√≥ximo dos outros effects)
+useEffect(() => {
+  if (isRevealed && rafId.current) {
+    cancelAnimationFrame(rafId.current);
+    rafId.current = null;
+  }
+  return () => {
+    if (rafId.current) {
+      cancelAnimationFrame(rafId.current);
+      rafId.current = null;
+    }
+    // Fecha/suspende √°udio
+    try { audioCtxRef.current?.close?.(); } catch {}
+  };
+}, [isRevealed]);


Observa√ß√£o: se voc√™ n√£o tem a rota /api/products/:id/scratch usada por scratchMutation, remova essa mutation ou crie a rota. Ela n√£o √© necess√°ria para corrigir o bug de UI.

2) server/routes.ts

Evitar cache na elegibilidade (sen√£o o front pode receber um ‚Äúainda eleg√≠vel‚Äù antigo).

--- a/server/routes.ts
+++ b/server/routes.ts
@@
 app.get('/api/scratch/offers/:productId/eligibility', async (req: any, res) => {
   try {
+    // N√£o permitir cache (sempre estado mais recente)
+    res.set('Cache-Control', 'no-store');


(o resto da rota permanece igual)

Por que isso resolve teu sintoma

A query agora realmente busca o estado no servidor e passa a dirigir a UI.

No momento em que o cupom √© gerado, for√ßamos a UI para ‚ÄúRESGATADO‚Äù (optimistic) e confirmamos com o backend (invalidate/refetch).

O overlay deixa de capturar eventos e o rAF √© cancelado, ent√£o n√£o existe mais aquela sensa√ß√£o de que ainda d√° pra raspar/clicar por cima.

Com no-store, a elegibilidade n√£o vem de cache antigo.