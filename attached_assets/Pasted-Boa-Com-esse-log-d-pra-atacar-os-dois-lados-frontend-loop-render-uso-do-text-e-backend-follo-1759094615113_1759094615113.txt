Boa! Com esse log dÃ¡ pra atacar os dois lados: frontend (loop/render + uso do text) e backend (follow-up â€œmais baratoâ€).
Abaixo vÃ£o patches cirÃºrgicos pro frontend que resolvem:

Loop infinito de render no GeminiAssistantBar.tsx (useEffect reinicializando sem necessidade).

Logs nÃ£o aparecendo (usa console.log e nÃ£o debug).

Mensagem do servidor ignorada (garante que SEMPRE usa data.text do backend, sem fallback local).

Use como â€œcola e substituiâ€ dentro do client/src/components/GeminiAssistantBar.tsx (ou o arquivo onde estÃ¡ o componente/barra). Se seu arquivo tem nomes ligeiramente diferentes, adapte os trechos pelo comentÃ¡rio/Ã¢ncora.

PATCH A â€” Evitar re-render infinito (StrictMode & init uma vez)

Adicione no topo do componente (logo apÃ³s os imports) um flag de inicializaÃ§Ã£o:

// ANTES de qualquer hook de estado
const didInitRef = React.useRef(false);


E no useEffect de setup da sessÃ£o/stream troque para:

React.useEffect(() => {
  // evita rodar 2x no StrictMode e evita loop por setState
  if (didInitRef.current) return;
  didInitRef.current = true;

  const sidKey = "gemini.sessionId";
  let sid = localStorage.getItem(sidKey);
  if (!sid) {
    sid = `web_${Math.random().toString(36).slice(2)}${Date.now().toString(36)}`;
    localStorage.setItem(sidKey, sid);
  }
  setSessionId(sid); // se vocÃª mantÃ©m no estado

  console.log("ğŸŸ¢ [GeminiAssistantBar] SessÃ£o ativa:", { sid });

  // â€¦ qualquer outro setup de listeners que vocÃª faÃ§a â€¦
}, []); // <<< DEPENDÃŠNCIAS VAZIAS (importante)


Se vocÃª jÃ¡ tinha um useEffect similar, garanta:

usa [] como deps;

tem o guard didInitRef.current para nÃ£o rodar duas vezes no StrictMode;

nÃ£o faz setState com valores que mudam toda renderizaÃ§Ã£o.

PATCH B â€” Logs confiÃ¡veis (trocar console.debug)

Onde vocÃª loga a resposta do servidor / SSE, troque:

console.debug("assistant debug >", payload);


por

console.log("ğŸ§  assistant debug >", payload);


E logo que receber cada evento do stream, logue o texto:

console.log("ğŸ“¨ SSE evento >", evtData); // { text, items, debug, provider, ... }

PATCH C â€” Usar SEMPRE o text do backend (sem fallback local)

Procure onde vocÃª finaliza o stream e insere a mensagem do assistente (algo como setChatMessages(prev => [...prev, { type: 'assistant', text: finalMessage }])). Garanta que a fonte Ã© o text vindo do backend:

// Dentro do onmessage/onend do SSE (ou apÃ³s o fetch da resposta final):
const serverText =
  evtData?.text ??
  data?.text ??
  ""; // nunca aplique um fallback local genÃ©rico aqui

// Se vier vazio por algum bug de rede, mande algo neutro:
const finalMessage = serverText.trim() || "OK, posso refinar sua busca por preÃ§o/capacidade/modelo. ğŸ™‚";

setChatMessages(prev => [...prev, { type: "assistant", text: finalMessage }]);


Importante: NÃƒO troque por checagens tipo if (items.length === 0) ....
O texto jÃ¡ vem pronto do backend (com dicas), entÃ£o renderize o que o servidor mandar.

PATCH D â€” Short-circuit do frontend (se ainda existir)

Se houver uma funÃ§Ã£o de fallback local (ex.: pickAssistantText() ou fallbackNoResults()), remova a decisÃ£o local baseada em items.length e deixe sÃ³:

// Em qualquer lugar que hoje use um "fallback" local:
return data?.text || "";

PATCH E â€” Start do stream com sessÃ£o estÃ¡vel

Na funÃ§Ã£o que dispara a busca (ex.: startGeminiStream), garanta que usa sempre o mesmo sessionId do localStorage (nÃ£o gere um novo a cada submit):

const sid = localStorage.getItem("gemini.sessionId")!;
const body = JSON.stringify({ message: inputText, sessionId: sid, lang: "pt" });

console.log("ğŸš€ start stream", { message: inputText, sessionId: sid });

const resp = await fetch("/api/assistant/query/stream", {
  method: "POST",
  headers: { "Content-Type": "application/json" },
  body
});


Isso resolve inconsistÃªncia entre turnos â€œiphoneâ€ â†’ â€œquero um mais baratoâ€.

Checklist rÃ¡pido de verificaÃ§Ã£o

Abra o console da pÃ¡gina (F12) e filtre por â€œassistant debugâ€.
VocÃª deve ver algo assim quando digitar â€œquero um mais baratoâ€ apÃ³s â€œiphoneâ€:

ğŸ§  assistant debug > {
  priceOnlyFollowUp: true,
  query: { produto: "iphone", categoria: "celular", sort: "price.asc", in_stock: true, ... },
  session: { focoAtual: "iphone", categoriaAtual: "celular" }
}


O chat deve exibir o texto do backend, e nÃ£o a frase fixa â€œHmm, nÃ£o achei nada pra â€˜baratoâ€™â€¦â€.

Se nada aparecer, verifique:

O SSE estÃ¡ chamando setChatMessages com data.text?

A sessÃ£o estÃ¡ estÃ¡vel (um Ãºnico sessionId)?

O log â€œğŸ“¨ SSE evento > â€¦â€ aparece com { text: "â€¦", debug: {...} }?