Front-end ainda tem texto hardcoded e ignora o text do backend.

O endpoint n√£o est√° usando composeAnswer (ou n√£o est√° dando await/passando sessionId).

A rota√ß√£o por sess√£o n√£o foi ligada (o √≠ndice n√£o avan√ßa ‚Üí sempre varia√ß√£o 0).

Vamos fechar isso com um patch √† prova de bala: rota√ß√£o determin√≠stica por sess√£o + uso obrigat√≥rio do compose + sanity log.

Patch 1 ‚Äî contador de turno por sess√£o (rota√ß√£o garantida)
*** a/src/services/sessionStore.ts
--- b/src/services/sessionStore.ts
@@
 export type SessionPayload = {
   focoAtual?: string|null;
   lastQuery?: string|null;
   categoriaAtual?: string|null;
   nomeCliente?: string|null;
   acessorios?: string[];
   rngSeed?: number;
+  turn?: number;         // <- NOVO: n√∫mero do turno na sess√£o
 };
@@
 export async function updateSession(id: string, data: Partial<SessionPayload>){ const prev=mem.get(id)??{}; mem.set(id,{...prev,...data}); }
 
 // util: avan√ßa e devolve √≠ndice (0..len-1) por sess√£o/chave
 export function nextVariant(id: string, key: string, len: number): number {
   const s = mem.get(id) ?? {};
   const k = `__v_${key}` as keyof SessionPayload;
   // @ts-ignore
   const cur = (s[k] as number | undefined) ?? -1;
   // @ts-ignore
   s[k] = (cur + 1) % Math.max(1, len);
   mem.set(id, s);
   // @ts-ignore
   return s[k] as number;
 }

Patch 2 ‚Äî composeAnswer usa rota√ß√£o + await (sem RNG fixo)
*** a/src/nlg/say.ts
--- b/src/nlg/say.ts
@@
-import { tGreet, tFound, tNoResults, tClarify, tCrossSell, greet, found, noResults } from "./templates";
+import { tGreet, tFound, tNoResults, tClarify, tCrossSell, greet, found, noResults } from "./templates";
 import { nextAccessorySuggestion } from "../logic/crossSell";
 import type { ConversationMemory } from "../types/memory";
-import { mulberry32 } from "../utils/rng";
-import { nextVariant } from "../services/sessionStore";
+import { nextVariant } from "../services/sessionStore";
 
-type Block = { type:"text"; text:string } | { type:"products"; items:any[] };
+type Block = { type:"text"; text:string } | { type:"products"; items:any[] };
 export interface ComposeArgs {
   query: { produto?:string; categoria?:string; modelo?:string; marca?:string; queryFinal?:string; faltando?: Array<"modelo"|"marca"|"armazenamento">; };
   items: any[];
   memory: ConversationMemory;
 }
-export function composeAnswer(args: ComposeArgs & { sessionId?: string }): Block[] {
-  const persona = SalesPersona; const { query, items, memory } = args; const blocks: Block[] = [];
-  // seed: quanto mais variar, melhor (hora atual + foco) ‚Äî valor ser√° setado no orchestrator
-  const rng = mulberry32((Date.now() >>> 10) ^ Math.floor(Math.random()*1e9));
-  if (!memory.lastQuery && !query.produto && !query.categoria) {
+export function composeAnswer(args: ComposeArgs & { sessionId: string }): Block[] {
+  const persona = SalesPersona; const { query, items, memory, sessionId } = args; const blocks: Block[] = [];
+  if (!memory.lastQuery && !query.produto && !query.categoria) {
     // rota√ß√£o determin√≠stica por sess√£o
-    const idx = args.sessionId ? nextVariant(args.sessionId, "greet", greet.length) : 0;
+    const idx = nextVariant(sessionId, "greet", greet.length);
     const text = greet[idx].replace("{emoji}", "‚ú®");
     blocks.push({ type:"text", text });
   }
   if (items.length>0){
-    const idx = args.sessionId ? nextVariant(args.sessionId, "found", found.length) : 0;
+    const idx = nextVariant(sessionId, "found", found.length);
     const base = found[idx]
       .replace("{count}", String(query ? (query as any).count ?? items.length : items.length))
       .replace("{cat}", (query.categoria ?? query.produto ?? "itens") as string)
       .replace("{query}", query.queryFinal ?? query.produto ?? query.categoria ?? "")
       .replace("{emoji}", "üòÑ");
     blocks.push({ type:"text", text: base });
@@
   } else {
-    const idx = args.sessionId ? nextVariant(args.sessionId, "nores", noResults.length) : 0;
+    const idx = nextVariant(sessionId, "nores", noResults.length);
     const need = (query.faltando?.[0] ?? "mais detalhes") as string;
     const hint = need==="modelo" ? "o **modelo** (ex.: 12, 13 Pro)" : need==="marca" ? "a **marca** (ex.: Apple, Samsung)" : "a **capacidade** (ex.: 128GB)";
     const text = noResults[idx]
       .replace("{query}", query.queryFinal ?? query.produto ?? "")
       .replace("{hint}", hint)
       .replace("{emoji}", "üòâ");
     blocks.push({ type:"text", text });
   }
   return blocks;
 }

Patch 3 ‚Äî endpoint usa composeAnswer (e nunca string fixa)
*** a/server/routes.ts
--- b/server/routes.ts
@@
-    const blocks = composeAnswer({ items, query: query!, memory: { focoAtual: query?.produto ?? null } as any, sessionId: sid });
-    const text = blocks.filter(b=>b.type==="text").map(b=>b.text).join("\n\n");
+    const blocks = composeAnswer({
+      items,
+      query: query!,
+      memory: { focoAtual: query?.produto ?? null } as any,
+      sessionId: sid
+    });
+    const text = blocks.filter(b => b.type === "text").map(b => b.text).join("\n\n");
     return res.json({ ok:true, kind:"PRODUCT", text, queryFinal: query?.queryFinal, items, debug: { original: message, canon: canonMsg, query } });

Verifica√ß√£o r√°pida (pega bug de texto hardcoded)

Rode no projeto:

grep -R 'D√™ uma olhada' -n src server


Se aparecer fora de src/nlg/templates.ts, remova: √© um texto fixo antigo que o front est√° renderizando (e ignora as varia√ß√µes).

Sanity logs (tempor√°rios)

No endpoint, logo antes do return:

console.log("[answer]", {
  textPreview: text.slice(0, 60),
  variantFound: (blocks.find(b=>b.type==="text") as any)?.text
});


Voc√™ deve ver a frase mudar a cada nova mensagem dentro da mesma sess√£o (ex.: ‚Äú√ìtimo!‚Ä¶‚Äù, depois ‚ÄúBoa escolha!‚Ä¶‚Äù, depois ‚ÄúüòÑ Achei‚Ä¶‚Äù e assim por diante).

TL;DR

Sim, aquele bug do pick atrapalhava, mas o problema persiste quando:

o front/endpoint ainda usa string fixa, ou

a rota√ß√£o n√£o est√° ligada.

Com os 3 patches acima (rota√ß√£o + compose obrigat√≥rio + ca√ßa ao hardcode), as respostas variam de verdade.