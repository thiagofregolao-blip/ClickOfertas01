Respira â€” dÃ¡ pra arrumar rÃ¡pido. O crash veio de duas referÃªncias inexistentes que ficaram no seu cÃ³digo novo:

write is not defined â†’ vocÃª removeu/renomeou o helper mas ainda tem chamadas write(...).

watchdog is not defined â†’ o timer nÃ£o foi declarado antes de dar clearInterval(watchdog).

AlÃ©m disso, seus logs mostram vÃ¡rias respostas HTML nos endpoints /api/products/search e /api/accessories/search (erro â€œUnexpected token '<'â€), entÃ£o o parser tentou JSON.parse num HTML de 404/erro e quebrou a busca. Isso nÃ£o derruba o servidor, mas faz a IA ficar â€œdigitando para sempreâ€ se vocÃª nÃ£o fecha o stream.

Abaixo vai um patch cirÃºrgico para deixar tudo operando agora, sem reescrever nada grande.

1) Traga de volta um helper compatÃ­vel (write) e o send novo

Cole estes helpers onde vocÃª escreve no SSE (no mesmo escopo onde tem res):

const SSE_COMPAT = true; // deixe true atÃ© o front migrar 100%

function send(event: string, payload: any) {
  // eventos nomeados
  res.write(`event: ${event}\n`);
  res.write(`data: ${JSON.stringify(payload)}\n\n`);
  // legado: onmessage com {type: ...}
  if (SSE_COMPAT) {
    res.write(`data: ${JSON.stringify({ type: event, ...payload })}\n\n`);
  }
}

// âš ï¸ Compatibilidade com chamadas antigas:
function write(obj: any) {
  const event = obj?.type ?? 'delta';
  send(event, obj);
}


Com isso, todas as chamadas antigas write({ type:'chunk'|'delta'|'products'|'end'|'complete', ... }) voltam a funcionar. Se vocÃª jÃ¡ usa send('delta', {text}), beleza â€” ambos coexistem.

2) Declare e limpe o watchdog com seguranÃ§a

Antes de criar o intervalo:

let watchdog: NodeJS.Timeout | null = null;
watchdog = setInterval(() => {
  // se ficar mudo, mande um delta de presenÃ§a
  write({ type: 'delta', text: '\n(um instanteâ€¦ garimpando ofertas) ' });
}, 7000);

// ... no fim OU em qualquer catch/finally:
if (watchdog) { clearInterval(watchdog); watchdog = null; }


Assim some o erro â€œwatchdog is not definedâ€ e vocÃª nunca deixa o stream â€œmudoâ€.

3) Nunca tente fazer JSON de HTML (proteÃ§Ã£o no tryFetch)

Troque seu fetch util por este guard de Content-Type:

async function tryFetchJSON(url: string, ms = 2500) {
  const ctrl = new AbortController();
  const t = setTimeout(() => ctrl.abort(), ms);
  try {
    const r = await fetch(url, { signal: ctrl.signal });
    if (!r.ok) return null;
    const ct = r.headers.get('content-type') || '';
    if (!ct.toLowerCase().includes('application/json')) {
      // HTML/Texto? nÃ£o Ã© JSON â†’ ignore em silÃªncio
      return null;
    }
    return await r.json();
  } catch {
    return null;
  } finally {
    clearTimeout(t);
  }
}


E troque nas chamadas problemÃ¡ticas:

const cat = await tryFetchJSON(`${origin}/api/products/search?q=${q}`);
const acc = await tryFetchJSON(`${origin}/api/accessories/search?compat=${q}`);


Isso elimina os â€œUnexpected token '<' â€¦ not valid JSONâ€ dos logs e impede travas na pipeline.

4) Garanta texto e finalizaÃ§Ã£o em TODO fluxo

Logo que abrir o stream:

write({ type: 'meta', requestId });        // opcional
write({ type: 'delta', text: 'Beleza! JÃ¡ confiro essas ofertasâ€¦ ğŸ˜‰' }); // 1Âº delta imediato


Quando a busca vier vazia:

write({ type: 'delta', text: 'NÃ£o achei itens agora. Me diz **memÃ³ria** (128/256GB) e **cidade** que eu garimpo ofertas ğŸ˜‰' });
write({ type: 'complete' }); // ou 'done' se o front espera isso
if (watchdog) clearInterval(watchdog);
res.end();
return;


Quando terminar o stream da OpenAI:

// Se tiver cards:
write({ type: 'products', products: top8, query });
// Fechamento padronizado:
write({ type: 'complete' });
if (watchdog) clearInterval(watchdog);
res.end();


Importante: sempre emita um complete/done no fim; senÃ£o o front fica preso em â€œdigitandoâ€¦â€.

5) Mapeie TODOS os eventos do SDK para â€œdeltaâ€

Para a Responses API e para Chat Completions (se usar):

// Responses API
stream.on('event', (e: any) => {
  if (e.type === 'response.output_text.delta' && e.delta) {
    write({ type: 'delta', text: e.delta });
  }
  if (e.type === 'response.refusal.delta' && e.delta) {
    write({ type: 'delta', text: e.delta });
  }
});
// Chat Completions (fallback)
for await (const chunk of stream) {
  const t = chunk?.choices?.[0]?.delta?.content;
  if (t) write({ type: 'delta', text: t });
}

6) (Frontend) duas linhas que evitam â€œsumirâ€ e â€œpiscarâ€

No handler do SSE (onde vocÃª processa o JSON):

SÃ³ desligue â€œestÃ¡ digitandoâ€¦â€ depois do primeiro delta vÃ¡lido.

Ao receber type:'products', nÃ£o chame seu fetchSuggest(); sÃ³ renderize o que veio do SSE nesse request (use a flag haveProductsInThisRequestRef que te passei antes).

Checklist de 60 segundos

 O servidor sobe sem crash (sumiram write/watchdog undefined).

 curl -N no seu /assistant/stream mostra: meta? â†’ delta â†’ (talvez products) â†’ complete.

 Logs de â€œUnexpected token '<'â€ sumiram (guard de Content-Type).

 Front nÃ£o trava em â€œdigitandoâ€ (tem delta inicial + complete).

 Produtos nÃ£o somem (SSE manda products, suggest nÃ£o sobrescreve).