Entendi o bug: o texto est√° duplicando/embaralhando (‚ÄúCliqueClique‚Ä¶ options options‚Ä¶‚Äù) e os cards n√£o aparecem. Isso acontece quando o mesmo delta √© processado duas vezes. No seu caso, isso est√° vindo de dois lugares ao mesmo tempo:

Backend manda o mesmo conte√∫do em dois formatos (modo compat√≠vel):
event: delta e tamb√©m data: {"type":"delta", ...}.
Se o front escuta ambos, voc√™ concatena duas vezes.

Voc√™ pode estar ‚Äúdando sa√≠da‚Äù duas vezes do stream do modelo:

uma via Responses API (response.output_text.delta) e

outra via Chat Completions (choices[0].delta.content).
Se os dois handlers est√£o ativos, cada token sai duas vezes.

Al√©m disso, quando chega products, pode estar sendo descartado por ‚ÄúrequestId‚Äù diferente, ou sobrescrito por um fetchSuggest tardio.

A seguir, patches m√≠nimos e certeiros.

PASSO 1 ‚Äî Escolha um formato de evento AGORA (elimina texto duplicado)

Op√ß√£o A (mais simples agora): desligue o compat no backend.

const SSE_COMPAT = false; // <<< desliga o espelho {type:...}
function send(event: string, payload: any) {
  res.write(`event: ${event}\n`);
  res.write(`data: ${JSON.stringify(payload)}\n\n`);
}


OU, se ainda n√£o puder:

Op√ß√£o B (com compat ligado), mas o front s√≥ processa UM canal

No front, remova o onmessage legado ou ignore mensagens com {type:"delta"} quando j√° veio event: delta.

Dica r√°pida: crie uma flag global namedEventsSeen=true ap√≥s o primeiro event:; se ela for true, ignore qualquer payload que venha s√≥ com type.

PASSO 2 ‚Äî Garanta que s√≥ existe um emissor de delta do modelo

No backend, n√£o mapeie os dois engines ao mesmo tempo. Escolha Responses ou Chat Completions. Padr√£o recomendado:

// Responses API ‚Äî √∫nico produtor de deltas
const stream = await client.responses.stream({ model:"gpt-4.1", input:[...] });

stream.on("event", (e: any) => {
  if (e.type === "response.output_text.delta" && e.delta) {
    send("delta", { requestId, text: e.delta, seq: ++deltaSeq });
  }
});
stream.on("end", async () => {
  // ... enviar products e done ...
});


Se voc√™ ainda tem o loop do Chat Completions (for await (const part of stream)), remova-o enquanto usa responses.stream. N√£o deixe os dois.

PASSO 3 ‚Äî Numere os deltas (dedupe √† prova de bala)

No backend:

let deltaSeq = 0;
send("delta", { requestId, text: "Beleza! J√° confiro‚Ä¶ üòâ", seq: ++deltaSeq });


Em cada delta, inclua seq: ++deltaSeq.

No front:

const lastSeqByReq = new Map<string, number>();

function handleDelta(d) {
  const req = d.requestId;
  const last = lastSeqByReq.get(req) ?? 0;
  if (d.seq && d.seq <= last) return; // drop duplicado/atrasado
  lastSeqByReq.set(req, d.seq || (last + 1));
  appendTyping(d.text);
}

PASSO 4 ‚Äî Garanta um √∫nico caminho de leitura no front

Se voc√™ est√° usando EventSource:

Use apenas addEventListener("delta"|"cards"|"done") ou apenas onmessage.

N√£o use os dois. Se precisar manter compat, fa√ßa:

let preferNamed = false;

es.addEventListener("delta", (e) => {
  preferNamed = true;
  const d = JSON.parse(e.data); handleDelta(d);
});

es.onmessage = (e) => {
  if (preferNamed) return; // j√° estamos usando eventos nomeados
  const d = JSON.parse(e.data||"{}");
  if (d.type === "delta") handleDelta(d);
  if (d.type === "products") renderCards(d.products, d.query);
  if (d.type === "done" || d.type === "complete" || d.type === "end") finalizeBubble();
};


Se voc√™ est√° usando fetch + ReadableStream com parser pr√≥prio: n√£o processe duas vezes o mesmo bloco (quando vier event: e tamb√©m {type:...}). Escolha um dentro do parser.

PASSO 5 ‚Äî Produtos que ‚Äúsomem‚Äù: segure a UI do SSE

N√£o rode fetchSuggest() depois que chegou products via SSE no mesmo request.
Use a flag:

const haveProductsInThisRequestRef = useRef(false);

// quando chegar products:
haveProductsInThisRequestRef.current = true;

// antes de chamar fetchSuggest:
if (haveProductsInThisRequestRef.current) return; // n√£o sobrescreve a UI


Confirme que o requestId √© o mesmo em delta, products e done. Se products vier com outro requestId, o front vai ignorar (e parecer que ‚Äúsumiu‚Äù).

PASSO 6 ‚Äî Seguran√ßa final (n√£o trava em ‚Äúdigitando‚Ä¶‚Äù)

Backend: sempre mande um primeiro delta (curto) e sempre finalize com done (ou complete).

Front: s√≥ desligue ‚Äúdigitando‚Ä¶‚Äù no primeiro delta; e tenha um timeout de 7‚Äì10s que gera uma frase de presen√ßa se nada chegar.

Checklist de 1 minuto

 SSE_COMPAT=false OU front s√≥ processa um canal.

 Apenas Responses API emite delta (sem Chat Completions junto).

 Deltas com seq e front com dedupe por (requestId, seq).

 fetchSuggest() n√£o roda ap√≥s products do SSE no mesmo request.

 done/complete sempre emitido.

 Teste com curl -N ‚Üí ver delta ‚Ä¶ delta ‚Ä¶ products ‚Ä¶ done.