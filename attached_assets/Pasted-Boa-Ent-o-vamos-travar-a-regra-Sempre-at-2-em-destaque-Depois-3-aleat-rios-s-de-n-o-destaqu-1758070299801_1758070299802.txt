Boa! EntÃ£o vamos travar a regra:

Sempre: atÃ© 2 em destaque.

Depois: 3 aleatÃ³rios sÃ³ de nÃ£o-destaque.

Fallback: se faltar nÃ£o-destaque, aÃ­ sim completa com outros (destaque que sobrou) sem repetir.

Aqui vai um bloco pronto (TS/JS) que resolve e evita repetir itens:

// helpers: use suas versÃµes se jÃ¡ existirem
const pickRandom = (arr: any[], n: number, seed: number) => {
  // cÃ³pia + shuffle determinÃ­stico
  const a = [...arr];
  let s = seed || 0;
  for (let i = a.length - 1; i > 0; i--) {
    s = (s * 9301 + 49297) % 233280;
    const j = Math.floor((s / 233280) * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a.slice(0, n);
};

const getRotationSeed = () => Math.floor(Date.now() / 60000); // 1 min

// regra 2 destaque + 3 nÃ£o-destaque (com fallback)
const selectProducts = (products: Product[], storeId: string | number) => {
  const seed = getRotationSeed() + (String(storeId).charCodeAt?.(0) || 0);

  const featuredAll = products.filter(p => p.isFeatured);
  const nonFeaturedAll = products.filter(p => !p.isFeatured);

  // 1) atÃ© 2 destaques
  const featuredPick = featuredAll.slice(0, 2);

  // 2) tentar 3 aleatÃ³rios de nÃ£o-destaque
  const needRandom = Math.max(0, 5 - featuredPick.length); // geralmente 3
  const randomNonFeatured = pickRandom(
    nonFeaturedAll,
    Math.min(needRandom, 3),
    seed
  );

  // 3) fallback: se faltou, usa destacados restantes (exclui os jÃ¡ escolhidos)
  const alreadyIds = new Set([...featuredPick, ...randomNonFeatured].map(p => p.id));
  const leftoverFeatured = featuredAll.filter(p => !alreadyIds.has(p.id));

  const missingAfterNonFeatured = 5 - (featuredPick.length + randomNonFeatured.length);
  const fallbackFromFeatured = missingAfterNonFeatured > 0
    ? pickRandom(leftoverFeatured, missingAfterNonFeatured, seed + 7)
    : [];

  // 4) fallback final: se ainda faltar (pouquÃ­ssimo provÃ¡vel), pega do resto sem repetir
  const remainingMissing = 5 - (featuredPick.length + randomNonFeatured.length + fallbackFromFeatured.length);
  const leftoversAll = products.filter(p => !alreadyIds.has(p.id) && !fallbackFromFeatured.some(f => f.id === p.id));
  const fallbackFromAll = remainingMissing > 0
    ? pickRandom(leftoversAll, remainingMissing, seed + 13)
    : [];

  const final = [
    ...featuredPick,
    ...randomNonFeatured,
    ...fallbackFromFeatured,
    ...fallbackFromAll
  ].slice(0, 5);

  return final;
};

O que muda

O pool dos 3 aleatÃ³rios Ã© somente nonFeaturedAll.

SÃ³ se nonFeaturedAll nÃ£o tiver o suficiente, a funÃ§Ã£o completa com leftoverFeatured.

Nunca repete produto (uso de alreadyIds).

MantÃ©m rotaÃ§Ã£o determinÃ­stica por minuto.

Plugue essa funÃ§Ã£o onde vocÃª monta displayProducts e me diga se ficou 2 destaque + 3 aleatÃ³rios certinho.

VocÃª disse:
outra coisa o botao ver mais ofertas nao esta contabilizando a quantidade certa de produtos cadastrados
O ChatGPT disse:
Pensou por 16s

O contador estÃ¡ errado porque o botÃ£o faz a conta fixa filteredProducts.length - 5.
Se, por qualquer motivo, vocÃª exibir menos de 5 (ou tiver alguma deduplicaÃ§Ã£o), esse cÃ¡lculo fica incorreto â€” ele nÃ£o subtrai a quantidade realmente exibida, e sim â€œ5â€ na marra. O prÃ³prio trecho mostra isso: â€œğŸ’° Ver {filteredProducts.length > 5 ? +${filteredProducts.length - 5} ofertas : 'panfleto'}â€. 

codigo_exibicao_produtos

CorreÃ§Ã£o

Calcule N com base nos IDs que estÃ£o visÃ­veis agora:

// pegue os IDs dos produtos realmente mostrados
const shownIds = new Set(displayProducts.map(p => p.id));

// quantos produtos ainda sobraram no filtro (excluindo os jÃ¡ exibidos)
const remainingCount = Math.max(
  0,
  filteredProducts.filter(p => !shownIds.has(p.id)).length
);

// label do botÃ£o
const moreLabel =
  remainingCount > 0 ? `+${remainingCount} ofertas` : 'panfleto';


E no JSX:

<button>
  ğŸ’° Ver {moreLabel}
</button>


Assim o botÃ£o sempre reflete â€œquantos faltam alÃ©m dos que vocÃª mostrouâ€, independentemente de:

ter exibido 5, 4, 3â€¦ (por regra ou fallback),

ter deduplicaÃ§Ã£o,

ter mistura de destaque e nÃ£o-destaque.

Dica: mantenha a seleÃ§Ã£o â€œ2 destaques + 3 aleatÃ³rios (nÃ£o-destaque) com fallbackâ€ que te passei e nunca repita IDs no displayProducts. AÃ­ o contador acima fica 100% confiÃ¡vel. (O trecho atual do botÃ£o estÃ¡ na seÃ§Ã£o â€œCÃLCULO DO BOTÃƒO (LINHA 1404)â€.) 

codigo_exibicao_produtos