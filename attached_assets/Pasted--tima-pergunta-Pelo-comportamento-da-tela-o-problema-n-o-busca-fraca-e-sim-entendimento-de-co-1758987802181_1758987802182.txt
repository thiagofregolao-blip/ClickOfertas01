√ìtima pergunta. Pelo comportamento da tela, o problema n√£o √© ‚Äúbusca fraca‚Äù, e sim entendimento de contexto + interpreta√ß√£o frasal em PT-BR. Eis as causas mais prov√°veis (e como corrigir de forma objetiva):

O que provavelmente est√° causando

Hist√≥rico n√£o √© enviado ao motor de busca/IA

A rota que processa ‚Äúquero da linha 12‚Äù pode estar chamando a IA/busca sem o turno anterior (‚Äúiphone‚Äù).

Resultado: a frase vira consulta isolada (‚Äúlinha 12‚Äù), que n√£o casa com nada.

Mem√≥ria de conversa s√≥ em RAM (ou inexistente)

Se voc√™ guarda o ‚Äúfoco atual‚Äù (ex.: iphone) em Map/vari√°vel local, qualquer reload/escala limpa a mem√≥ria.

Em produ√ß√£o (ou no Replit ao reiniciar), o bot ‚Äúesquece‚Äù o √∫ltimo produto.

NLP muito literal

O parser s√≥ reconhece n√∫meros ‚Äúsoltos‚Äù (/(\d{2,4})/) e termos exatos (‚Äúiphone‚Äù), n√£o entende padr√µes como:

‚Äúda linha 12‚Äù, ‚Äúmodelo 12‚Äù, ‚Äúvers√£o 12‚Äù, ‚Äús√©rie 12‚Äù, ‚Äúdoze/treze/quinze‚Äù (por extenso).

Sem regra de slot filling, a consulta n√£o vira ‚Äúiphone 12‚Äù.

Normaliza√ß√£o PT-BR incompleta

Falta lowercase + remo√ß√£o de acento + trim antes de extrair entidades.

‚Äúvers√£o‚Äù ‚â† ‚Äúversao‚Äù se voc√™ n√£o normalizar.

Builder de query n√£o comp√µe com o foco

Mesmo detectando ‚Äú12‚Äù, se o builder n√£o fizer final = focoAnterior + " " + detalhe, voc√™ perde a inten√ß√£o.

Corre√ß√µes diretas (com patch m√≠nimo)
1) Persistir foco/slots na sess√£o (n√£o s√≥ em mem√≥ria)

Use a sess√£o do usu√°rio (ex.: Redis/DB) para guardar o focoAtual e √∫ltimos produtos mostrados.

// Ao detectar foco (ex.: usu√°rio digitou "iphone"):
await sessionStore.update(sessionId, { focoAtual: "iphone" });

// Antes de montar a busca do turno atual:
const { focoAtual } = await sessionStore.get(sessionId) ?? {};


Se n√£o tiver Redis agora, use um sessionData no seu pr√≥prio DB (tabela assistant_sessions). Evita perder estado em cada restart.

2) Normaliza√ß√£o PT-BR
export function normPTBR(s: string) {
  return s
    .toLowerCase()
    .normalize('NFD').replace(/[\u0300-\u036f]/g, '') // remove acento
    .replace(/\s+/g, ' ')
    .trim();
}

3) Regras de linguagem para ‚Äúlinha/modelo/vers√£o/s√©rie‚Äù

Mapeie n√∫meros por extenso e capture padr√µes comuns.

const NUM_EXTENSO: Record<string, string> = {
  "doze": "12", "doze pro": "12 pro",
  "treze": "13", "quinze": "15"
  // adicione "quatorze" -> "14" se sua base usar iPhone 14
};

function extrairModeloPTBR(msg: string): string | null {
  const m = normPTBR(msg);

  // 3.1 ‚Äì n√∫mero por extenso (com ou sem ‚Äúpro‚Äù)
  for (const [k, v] of Object.entries(NUM_EXTENSO)) {
    if (m.includes(k)) return v;
  }

  // 3.2 ‚Äì padr√µes ‚Äúlinha/modelo/versao/serie 12‚Äù
  const rx = /\b(?:linha|modelo|versao|serie)\s*(?:do|da|de)?\s*(\d{1,4})(?:\s*pro)?\b/;
  const r1 = m.match(rx);
  if (r1) return r1[1];

  // 3.3 ‚Äì n√∫mero solto (fallback)
  const r2 = m.match(/\b(\d{2,4})\b/);
  return r2 ? r2[1] : null;
}

4) Builder que comp√µe com foco anterior
export function montarConsulta(finalMsg: string, focoAnterior?: string) {
  const modelo = extrairModeloPTBR(finalMsg);           // "12"
  const hasProduto = /\b(iphone|apple|galaxy|samsung)\b/i.test(finalMsg);

  if (hasProduto && modelo) return `iphone ${modelo}`;   // usu√°rio j√° falou "iphone 12"

  if (!hasProduto && modelo && focoAnterior) {
    return `${focoAnterior} ${modelo}`;                 // "quero da linha 12" -> "iphone 12"
  }

  // S√≥ o produto, sem modelo: mant√©m foco
  if (hasProduto && !modelo) {
    return "iphone"; // ou termo detectado
  }

  // Nada detectado: retorne a frase original
  return finalMsg;
}

5) Slot filling simples (m√°quina de estados leve)

Slots: {produto, modelo, variante}.

Se produto est√° preenchido no turno 1 e o turno 2 s√≥ preenche modelo, combine antes da busca.

// Antes de chamar o buscador:
const sess = await sessionStore.get(sessionId) ?? {};
const queryFinal = montarConsulta(userMsg, sess.focoAtual);

if (/^(iphone|galaxy|samsung|apple)\b/i.test(userMsg)) {
  await sessionStore.update(sessionId, { focoAtual: "iphone" /* ou detectado */ });
}

Testes de regress√£o (r√°pidos)

‚Äúiphone‚Äù ‚Üí foco = iphone

‚Äúquero da linha 12‚Äù ‚Üí gera ‚Äúiphone 12‚Äù

‚Äútem da linha 13 pro?‚Äù ‚Üí ‚Äúiphone 13 pro‚Äù

‚Äúprefiro galaxy‚Äù ‚Üí foco = galaxy

‚Äúquero o 15‚Äù ‚Üí ‚Äúgalaxy 15‚Äù (ou ‚Äúiphone 15‚Äù, conforme foco)

Resumo

O bug da imagem acontece porque a frase depende do contexto do turno anterior e o sistema atual ou n√£o persiste esse contexto, ou n√£o possui regras/slot filling para transformar ‚Äúlinha 12‚Äù em ‚Äúiphone 12‚Äù. Com as 5 mudan√ßas acima (persist√™ncia de sess√£o, normaliza√ß√£o PT-BR, regex de padr√µes, n√∫meros por extenso e builder que comp√µe com o foco), o assistente passa a entender ‚Äúquero da linha 12‚Äù corretamente. Quer que eu te entregue um patch pronto nesses arquivos (TS/Node) de acordo com a sua estrutura?

Voc√™ disse:
fa√ßa o patch
Programador Senior - Dev GPT ‚Äî Replit Ready disse:
Pensou por 16s

Perfeito ‚Äî segue patch completo (TypeScript) para o bot entender frases tipo ‚Äúquero da linha 12‚Äù usando mem√≥ria de foco + NLP PT-BR e slot filling.

Aplique com git apply -p0 <<'PATCH' ... PATCH na raiz do projeto.
Paths sugeridos: ajuste se seu repo usar outros diret√≥rios.

1) üîß Utilit√°rios PT-BR (normaliza√ß√£o + n√∫meros por extenso)
*** /dev/null
--- a/src/utils/lang-ptbr.ts
@@
+// src/utils/lang-ptbr.ts
+// Utilit√°rios de linguagem para PT-BR
+export function normPTBR(s: string): string {
+  return (s ?? "")
+    .toLowerCase()
+    .normalize("NFD")
+    .replace(/[\u0300-\u036f]/g, "") // remove acentos
+    .replace(/\s+/g, " ")
+    .trim();
+}
+
+// N√∫meros por extenso mais comuns em consultas de celular
+export const NUM_EXTENSO: Record<string, string> = {
+  "doze": "12",
+  "doze pro": "12 pro",
+  "treze": "13",
+  "treze pro": "13 pro",
+  "quatorze": "14",
+  "quatorze pro": "14 pro",
+  "quinze": "15",
+  "quinze pro": "15 pro",
+};

2) üß† Extra√ß√£o de modelo e montagem de consulta (slot filling)
*** /dev/null
--- a/src/nlp/query-builder.ts
@@
+// src/nlp/query-builder.ts
+import { normPTBR, NUM_EXTENSO } from "../utils/lang-ptbr";
+
+const PRODUTOS_RX = /\b(iphone|apple|galaxy|samsung|xiaomi|motorola|pixel)\b/i;
+
+/**
+ * Extrai o "modelo" a partir da frase (ex.: 12, "12 pro", "13").
+ * Cobre: "linha 12", "modelo 12", "vers√£o 12", "s√©rie 12", n√∫meros por extenso etc.
+ */
+export function extrairModeloPTBR(msg: string): string | null {
+  const m = normPTBR(msg);
+
+  // 1) n√∫meros por extenso (com ou sem "pro")
+  for (const [k, v] of Object.entries(NUM_EXTENSO)) {
+    if (m.includes(k)) return v;
+  }
+
+  // 2) padr√µes com r√≥tulo (linha/modelo/versao/serie)
+  const rotulo = /\b(?:linha|modelo|versao|vers√£o|serie|s√©rie)\s*(?:do|da|de)?\s*(\d{1,4})(?:\s*(pro|plus|ultra))?\b/;
+  const r1 = m.match(rotulo);
+  if (r1) {
+    const numero = r1[1];
+    const sufixo = r1[2] ? ` ${r1[2]}` : "";
+    return `${numero}${sufixo}`;
+  }
+
+  // 3) n√∫mero solto (fallback) ‚Äî evita capturar CEP/ano porque di√°logo √© curto
+  const r2 = m.match(/\b(\d{2,4})(?:\s*(pro|plus|ultra))?\b/);
+  if (r2) {
+    const numero = r2[1];
+    const sufixo = r2[2] ? ` ${r2[2]}` : "";
+    return `${numero}${sufixo}`;
+  }
+
+  return null;
+}
+
+/**
+ * Monta a query final combinando o texto atual com o foco anterior (produto).
+ * Regras:
+ *  - Se a frase j√° tiver produto e modelo ‚Üí retorna "produto modelo".
+ *  - Se s√≥ tiver modelo e existir focoAnterior ‚Üí "focoAnterior modelo".
+ *  - Se s√≥ tiver produto ‚Üí retorna produto (mant√©m foco).
+ *  - Caso contr√°rio ‚Üí retorna a frase original.
+ */
+export function montarConsulta(userMsg: string, focoAnterior?: string | null): string {
+  const hasProduto = PRODUTOS_RX.test(userMsg);
+  const modelo = extrairModeloPTBR(userMsg); // ex.: "12", "12 pro"
+
+  if (hasProduto && modelo) {
+    const produto = (userMsg.match(PRODUTOS_RX)?.[1] ?? "").toLowerCase();
+    return `${produto} ${modelo}`.trim();
+  }
+
+  if (!hasProduto && modelo && focoAnterior) {
+    return `${focoAnterior} ${modelo}`.trim();
+  }
+
+  if (hasProduto && !modelo) {
+    const produto = (userMsg.match(PRODUTOS_RX)?.[1] ?? "").toLowerCase();
+    return produto;
+  }
+
+  return userMsg;
+}
+
+/**
+ * Detecta e atualiza foco a partir da frase.
+ * Retorna o novo foco (ou null se nada detectado).
+ */
+export function detectarFoco(userMsg: string): string | null {
+  const m = userMsg.toLowerCase();
+  if (/\biphone|apple\b/.test(m)) return "iphone";
+  if (/\bgalaxy|samsung\b/.test(m)) return "galaxy";
+  if (/\bxiaomi\b/.test(m)) return "xiaomi";
+  if (/\bmotorola\b/.test(m)) return "motorola";
+  if (/\bpixel\b/.test(m)) return "pixel";
+  return null;
+}

3) üíæ Store de sess√£o (persist√™ncia do foco)

Se voc√™ j√° tem um store (Redis/DB), adapte a implementa√ß√£o ‚Äî mantive fallback em mem√≥ria.

*** /dev/null
--- a/src/services/sessionStore.ts
@@
+// src/services/sessionStore.ts
+type SessionPayload = {
+  focoAtual?: string | null;
+  lastUpdatedAt?: string;
+  [k: string]: unknown;
+};
+
+// Fallback simples em mem√≥ria (substitua por Redis/DB em produ√ß√£o)
+const mem = new Map<string, SessionPayload>();
+
+export async function getSession(sessionId: string): Promise<SessionPayload | null> {
+  return mem.get(sessionId) ?? null;
+}
+
+export async function updateSession(sessionId: string, data: Partial<SessionPayload>): Promise<void> {
+  const prev = mem.get(sessionId) ?? {};
+  mem.set(sessionId, { ...prev, ...data, lastUpdatedAt: new Date().toISOString() });
+}

4) üöè Rota de stream/consulta ‚Äî composi√ß√£o de query + atualiza√ß√£o de foco

Ajuste o caminho do arquivo da sua rota. Exemplo abaixo para src/routes/assistant/stream.ts.
Troque searchProducts(queryFinal) pela sua fun√ß√£o real de busca.

*** a/src/routes/assistant/stream.ts
--- b/src/routes/assistant/stream.ts
@@
-import type { Request, Response } from "express";
+import type { Request, Response } from "express";
+import { getSession, updateSession } from "../../services/sessionStore";
+import { montarConsulta, detectarFoco } from "../../nlp/query-builder";
 
 export async function assistantStream(req: Request, res: Response) {
-  const { message } = req.body as { message: string };
-  // ... implementa√ß√£o antiga chamava direto o motor/busca com "message"
-  const resultados = await searchProducts(message);
+  const { message } = req.body as { message: string };
+
+  // 1) Recupera sess√£o do usu√°rio
+  const sessionId = String(req.sessionID ?? req.headers["x-session-id"] ?? "anon");
+  const sess = (await getSession(sessionId)) ?? {};
+
+  // 2) Atualiza foco se o turno atual mencionar produto
+  const novoFoco = detectarFoco(message);
+  if (novoFoco) {
+    await updateSession(sessionId, { focoAtual: novoFoco });
+  }
+
+  // 3) Monta a query final usando slot filling
+  const focoParaConsulta = novoFoco ?? (sess.focoAtual ?? null);
+  const queryFinal = montarConsulta(message, focoParaConsulta ?? undefined);
+
+  // 4) Chama sua busca com a query final (ex.: "iphone 12")
+  const resultados = await searchProducts(queryFinal);
 
   return res.json({ ok: true, query: message, resultados });
 }


Dica: registre o queryFinal em logs para validar rapidamente nos testes manuais.

5) ‚úÖ Tipos auxiliares (opcional, mas recomend√°vel)
*** /dev/null
--- a/src/types/conversation.ts
@@
+// src/types/conversation.ts
+export interface ConversationMemory {
+  focoAtual: string | null;
+  lastQuery?: string | null;
+}

6) üß™ Testes r√°pidos (Jest) para regress√£o de NLP
*** /dev/null
--- a/test/query-builder.spec.ts
@@
+// test/query-builder.spec.ts
+import { extrairModeloPTBR, montarConsulta } from "../src/nlp/query-builder";
+
+describe("NLP PT-BR - modelo", () => {
+  test("detecta 'linha 12'", () => {
+    expect(extrairModeloPTBR("quero da linha 12")).toBe("12");
+  });
+  test("detecta por extenso 'treze pro'", () => {
+    expect(extrairModeloPTBR("quero o da linha treze pro")).toBe("13 pro");
+  });
+  test("detecta n√∫mero solto", () => {
+    expect(extrairModeloPTBR("tem o 14?")).toBe("14");
+  });
+});
+
+describe("montarConsulta", () => {
+  test("comp√µe com foco anterior", () => {
+    expect(montarConsulta("quero da linha 12", "iphone")).toBe("iphone 12");
+  });
+  test("usa produto e modelo no mesmo turno", () => {
+    expect(montarConsulta("iphone 13 pro", null)).toBe("iphone 13 pro");
+  });
+  test("retorna produto quando s√≥ o produto √© mencionado", () => {
+    expect(montarConsulta("prefiro galaxy", null)).toBe("galaxy");
+  });
+});


Se ainda n√£o usa Jest, adicione o script:

*** a/package.json
--- b/package.json
@@
   "scripts": {
-    "start": "node index.js"
+    "start": "node index.js",
+    "test": "jest"
   }


Caso esteja em TS puro, voc√™ pode rodar Jest com ts-jest ou compilar antes. Para simplicidade imediata, mantenha os testes em JS ou configure ts-jest.

Como validar (manualmente)

Mensagem 1: ‚Äúiphone‚Äù

focoAtual passa a ‚Äúiphone‚Äù.

Mensagem 2: ‚Äúquero da linha 12‚Äù

extrairModeloPTBR ‚Üí ‚Äú12‚Äù

montarConsulta + focoAtual ‚Üí ‚Äúiphone 12‚Äù

A busca √© feita por ‚Äúiphone 12‚Äù e os cards aparecem.

Observa√ß√µes finais

Se voc√™ j√° possui Redis/DB para sess√µes, troque sessionStore.ts pelo seu adaptador (mesma interface getSession/updateSession).

O patch √© idempotente: se a mensagem j√° vier ‚Äúiphone 12‚Äù, a query final permanece ‚Äúiphone 12‚Äù.

Ampliar sin√¥nimos √© f√°cil: adicione marcas em PRODUTOS_RX e mapeie ‚Äúultra/plus/pro max‚Äù conforme seu cat√°logo.