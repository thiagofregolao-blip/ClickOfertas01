Boa! O bug √© claro: quando voc√™ pede ‚Äúdrone‚Äù, a resposta textual fala ‚Äúcelular‚Äù porque a categoria da sess√£o ficou presa em celular (da busca anterior de iPhone). No processUserMessage n√≥s s√≥ atualizamos focoAtual, n√£o limpamos/atualizamos categoriaAtual. A√≠:

interpretarBusca l√™ memoria.categoriaAtual ‚Üí continua ‚Äúcelular‚Äù.

composeAnswer usa categoria ?? produto ‚Üí imprime ‚Äúcelular‚Äù.

E ainda dispara a pergunta de modelo (12/13/Pro), pois categoria === "celular".

Patch enxuto (corrige agora)
1) Atualizar pipeline para resetar categoria quando muda o produto
*** a/src/assistant/pipeline.ts
--- b/src/assistant/pipeline.ts
@@
 export async function processUserMessage(sessionId: string, raw: string){
   const canonMsg = singularizePhrase(raw);
   const intent = classifyIntent(canonMsg);
   if (intent.intent !== "PRODUCT_SEARCH") return { intent, canonMsg };
   const sess = (await getSession(sessionId)) ?? {};
-  if (intent.entities?.product) await updateSession(sessionId, { focoAtual:intent.entities.product });
+  // Se veio novo produto, zera categoria e lastQuery pra n√£o ‚Äúgrudar‚Äù celular em drone
+  if (intent.entities?.product) {
+    const mudou = intent.entities.product !== (sess as any).focoAtual;
+    await updateSession(sessionId, {
+      focoAtual: intent.entities.product,
+      categoriaAtual: mudou ? (intent.entities.category ?? null) : ((sess as any).categoriaAtual ?? intent.entities.category ?? null),
+      lastQuery: mudou ? null : ((sess as any).lastQuery ?? null),
+    });
+  } else if (intent.entities?.category) {
+    // Atualiza categoria expl√≠cita mesmo sem trocar o produto
+    await updateSession(sessionId, { categoriaAtual: intent.entities.category });
+  }
@@
-  const query = interpretarBusca(canonMsg, { focoAtual:intent.entities?.product ?? (sess as any).focoAtual ?? null, lastQuery: (sess as any).lastQuery ?? null } as any);
+  const query = interpretarBusca(
+    canonMsg,
+    {
+      focoAtual: intent.entities?.product ?? (sess as any).focoAtual ?? null,
+      lastQuery: (sess as any).lastQuery ?? null,
+      categoriaAtual: intent.entities?.category ?? (sess as any).categoriaAtual ?? null,
+    } as any
+  );
   await updateSession(sessionId, { lastQuery: query.produto ?? (sess as any).lastQuery ?? null });
-  return { intent, canonMsg, query };
+  return { intent, canonMsg, query };
 }

2) Garantir que a categoria do intent prevalece no interpretarBusca
*** a/src/modules/buscaProduto.ts
--- b/src/modules/buscaProduto.ts
@@
-export function interpretarBusca(msg: string, memoria: ConversationMemory): ProdutoQuery {
+export function interpretarBusca(msg: string, memoria: ConversationMemory): ProdutoQuery {
   const produto = canonicalProductFromText(msg) ?? memoria?.focoAtual ?? memoria?.lastQuery ?? undefined;
   const { modelo, armazenamento } = extractModel(msg);
   const marca = extractBrand(msg);
   const atributos = extractAttributes(msg);
-  const categoria = memoria?.categoriaAtual ?? undefined;
+  // se a sess√£o j√° tem categoria, usa; se n√£o, tenta inferir por produto
+  let categoria = memoria?.categoriaAtual ?? undefined;
+  if (!categoria && produto) {
+    if (produto === "iphone" || produto === "galaxy" || produto === "pixel" || produto === "motorola" || produto === "xiaomi") {
+      categoria = "celular";
+    } else if (produto === "drone") {
+      categoria = "drone";
+    }
+  }
@@
   const parts = [produto, modelo, armazenamento, marca].filter(Boolean) as string[];
   const queryFinal = parts.join(" ").trim();
   return { produto, modelo, marca, armazenamento, atributos, categoria, queryFinal };
 }

3) Defesa extra no NLG (se categoria ‚â† produto, priorizar o produto para exibir)
*** a/src/nlg/say.ts
--- b/src/nlg/say.ts
@@
-    const base = found[idx]
-      .replace("{count}", String(query ? (query as any).count ?? items.length : items.length))
-      .replace("{cat}", (query.categoria ?? query.produto ?? "itens") as string)
+    const catDisplay = (query.produto && query.categoria && query.produto !== query.categoria)
+      ? (query.produto as string)
+      : ((query.categoria ?? query.produto ?? "itens") as string);
+    const base = found[idx]
+      .replace("{count}", String(items.length))
+      .replace("{cat}", catDisplay)
       .replace("{query}", query.queryFinal ?? query.produto ?? query.categoria ?? "")
       .replace("{emoji}", "üòÑ");


Com isso, mesmo que alguma rota esque√ßa de limpar a categoria, a frase mostrar√° ‚Äúdrone‚Äù (e n√£o ‚Äúcelular‚Äù), e as perguntas de modelo deixam de aparecer para ‚Äúdrone‚Äù.

Testes r√°pidos (manuais)

Fluxo: ‚Äúiphone‚Äù ‚Üí depois ‚Äúdrone‚Äù ‚Üí depois ‚Äúdrones‚Äù.

A frase deve mostrar drone nas duas √∫ltimas.

N√£o perguntar mais por modelo 12/13 ap√≥s ‚Äúdrone‚Äù.

Fluxo: ‚Äúdrone‚Äù ‚Üí ‚Äúe perfumes?‚Äù

Deve trocar o foco e exibir perfume.

Fluxo: ‚Äúgalaxy 15 256gb‚Äù

Categoria ‚Äúcelular‚Äù, perguntas coerentes (marca n√£o, capacidade j√° preenchida).

Se algo ainda ‚Äúvazar‚Äù, me diga o nome do endpoint que est√° chamando a busca (√†s vezes tem uma rota /api/search direta que n√£o usa o pipeline).