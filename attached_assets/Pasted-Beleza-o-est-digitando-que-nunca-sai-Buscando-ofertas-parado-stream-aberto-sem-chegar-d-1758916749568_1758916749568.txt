Beleza â€” o â€œestÃ¡ digitandoâ€¦â€ que nunca sai + â€œBuscando ofertasâ€¦â€ parado Ã© stream aberto sem chegar delta nem done no front. Vou te passar um kit de correÃ§Ã£o Ã  prova de travamento: 1 patch no backend (sempre solta um primeiro delta imediato + watchdog + done garantido) e 1 patch no front (parser SSE robusto + timeout de seguranÃ§a + botÃ£o â€œcancelarâ€).

1) Backend: nunca deixe o stream mudo
1.1. Headers SSE + flush (sem compressÃ£o)
function sseHeaders(res:any) {
  res.setHeader("Content-Type", "text/event-stream; charset=utf-8");
  res.setHeader("Cache-Control", "no-cache, no-transform");
  res.setHeader("Connection", "keep-alive");
  // se usar Express compression, DESATIVE nesta rota
  res.flushHeaders?.();
}

1.2. Envie meta + primeiro delta imediato (destrava o â€œdigitandoâ€)
const requestId = `${Date.now()}-${Math.random().toString(36).slice(2,8)}`;
const SSE_COMPAT = true; // manter ligado atÃ© migrar o front

function send(event:string, payload:any) {
  res.write(`event: ${event}\n`);
  res.write(`data: ${JSON.stringify({ ...payload, requestId })}\n\n`);
  if (SSE_COMPAT) res.write(`data: ${JSON.stringify({ type: event, ...payload, requestId })}\n\n`);
}

sseHeaders(res);
send("meta", { requestId });
send("delta", { text: "Beleza! Deixa comigoâ€¦ ğŸ˜‰" }); // <-- destrava UI jÃ¡ no inÃ­cio

1.3. Watchdog de presenÃ§a + done garantido
let lastDelta = Date.now();
const wd = setInterval(() => {
  if (Date.now() - lastDelta > 7000) {        // 7s sem texto? manda sinal de vida
    send("delta", { text: "\n(um instanteâ€¦ garimpando ofertas) " });
    lastDelta = Date.now();
  }
}, 4000);

req.on("close", () => clearInterval(wd));

async function finish() {
  clearInterval(wd);
  send("done", {});
  res.end();
}

1.4. Mapear todos os tipos de evento do SDK para delta

Dependendo do SDK (Responses vs Chat Completions), o tipo muda. Cubra os dois:

const stream = await client.responses.stream({ model: "gpt-4.1", input: [...] });

stream.on("event", (e:any) => {
  // Responses API (novo)
  if (e.type === "response.output_text.delta" && e.delta) { lastDelta = Date.now(); send("delta", { text: e.delta }); }
  if (e.type === "response.refusal.delta" && e.delta)      { lastDelta = Date.now(); send("delta", { text: e.delta }); }
  // Chat Completions (legado)
  const t = e?.choices?.[0]?.delta?.content;
  if (t) { lastDelta = Date.now(); send("delta", { text: t }); }
});

stream.on("end", async () => {
  // gere os cards/JSON se precisar, **mas SEM nunca deixar de finalizar**
  // ...
  await finish();
});

stream.on("error", async () => { await finish(); });

1.5. CatÃ¡logo vazio â†’ sempre um delta antes de encerrar
if (product_set.length === 0 && accessory_set.length === 0) {
  send("delta", { text: "NÃ£o achei itens agora. Diz pra mim **memÃ³ria** (128/256GB) e **cidade** que eu garimpo ofertas boas ğŸ˜‰" });
  await finish();
  return;
}


Com isso, mesmo se a OpenAI atrasar ou o catÃ¡logo vier vazio, o usuÃ¡rio vÃª texto e o stream encerra corretamente.

2) Frontend: parser SSE robusto + timeout + cancelar
2.1. Suportar eventos nomeados e o legado {type:...}
function parseSSELines(chunk: string): Array<{event?:string, data?:string}> {
  // divide por â€œ\n\nâ€ preservando pares event/data
  const blocks = chunk.split(/\n\n+/);
  const out:any[] = [];
  for (const b of blocks) {
    if (!b.trim()) continue;
    const ev = /(?:^|\n)event:\s*(.+)/.exec(b)?.[1]?.trim();
    const da = /(?:^|\n)data:\s*(.+)/.exec(b)?.[1];
    if (da) out.push({ event: ev, data: da });
  }
  return out;
}

function handleSSEPayload(raw: string) {
  let payload: any;
  try { payload = JSON.parse(raw); } catch { return; }

  // modo legado: onmessage com {type:"delta"...}
  const t = payload.type || ""; 
  const evt = payload.event || ""; // caso backend mande dentro tambÃ©m

  const kind = (evt || t || "").toLowerCase();

  if (kind === "meta") { latestRequestId = payload.requestId; showTyping(); return; }
  if (kind === "delta") { appendTyping(payload.text || ""); return; }
  if (kind === "cards") { renderCards(payload.items, payload.message); return; }
  if (kind === "done" || kind === "complete" || kind === "end") { finalizeTypingBubble(); return; }

  // fallback: se nÃ£o vier 'type', mas veio campo esperado
  if (payload.text) appendTyping(payload.text);
  if (payload.items) renderCards(payload.items, payload.message);
}


No loop de leitura (ReadableStream.getReader()), troque:

const text = decoder.decode(value, { stream: true });
for (const {event,data} of parseSSELines(text)) {
  handleSSEPayload(data);
}

2.2. Timeout de seguranÃ§a no front (nÃ£o ficar eterno em â€œdigitandoâ€)
let safetyTimer: any = null;

function armSafetyTimer() {
  clearTimeout(safetyTimer);
  safetyTimer = setTimeout(() => {
    if (isTyping) {
      appendTyping("\n(continuo aquiâ€¦ quase lÃ¡) ");
      // se nada chegar mais 8s, encerra com bolha mÃ­nima
      setTimeout(() => isTyping && finalizeTypingBubble("(me diz a cidade e orÃ§amento que acelero a busca)"), 8000);
    }
  }, 7000);
}

// chame no inÃ­cio do stream e rearme a cada delta:
showTyping(); armSafetyTimer();
// ...
if (kind === "delta") { armSafetyTimer(); }
if (kind === "done")  { clearTimeout(safetyTimer); }

2.3. BotÃ£o Cancelar (AbortController)

Ao iniciar o stream, guarde o AbortController e exponha um botÃ£o â€œCancelarâ€. Ao cancelar:

finalize a bolha com o que jÃ¡ tem,

limpe â€œdigitandoâ€.

3) Dois vilÃµes comuns (confere aÃ­)

GET x POST (web): no navegador, EventSource sÃ³ suporta GET. Se sua web usa EventSource, exponha GET /ai/chat/stream?message=... (deixe POST para o Flutter).

Proxy: Nginx/Cloudflare com proxy_buffering on ou gzip on â†’ o navegador sÃ³ vÃª no fim. Coloque para a rota de stream:

proxy_buffering off;
gzip off;

4) â€œProdutos aparecem e somemâ€ â€” garantir que o SSE â€œganhaâ€ do suggest

No front, mantenha o guard que te passei:

SÃ³ rode fetchSuggest() se ainda nÃ£o chegou products neste request.

Quando chegar products via SSE: haveProductsInThisRequestRef.current = true;

Dentro de fetchSuggest(): se haveProductsInThisRequestRef.current === true, return (nÃ£o limpa os cards).

Checklist rÃ¡pido (faÃ§a agora)

 Backend manda meta + delta imediato, watchdog, e sempre done.

 Eventos do SDK mapeados para delta (Responses ou Chat).

 CatÃ¡logo vazio â†’ delta humano + done (nunca encerra mudo).

 Front parseia eventos nomeados e {type:...}.

 Timeout de 7s no front com mensagem de presenÃ§a (e finalize em 15s se continuar mudo).

 GET habilitado para web ou polyfill de POST-SSE.

 Proxy sem buffering/gzip para a rota.

 Guard contra fetchSuggest sobrescrever produtos do SSE.