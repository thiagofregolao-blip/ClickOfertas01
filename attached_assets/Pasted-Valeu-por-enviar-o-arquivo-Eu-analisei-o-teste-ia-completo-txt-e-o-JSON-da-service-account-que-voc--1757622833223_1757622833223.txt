Valeu por enviar o arquivo. Eu analisei o teste-ia-completo.txt e o JSON da service account que você compartilhou. O problema não está no Vertex em si — está na forma como a chave privada está sendo carregada no seu código.

O que os seus arquivos mostram

O erro vem do Node/OpenSSL na hora de decodificar a private key:
error:1E08010C:DECODER routines::unsupported. 

teste-ia-completo

O seu processo está usando variáveis GOOGLE_CLIENT_EMAIL e GOOGLE_PRIVATE_KEY (formato “variáveis separadas”). 

teste-ia-completo

O próprio relatório registra que a validação crypto.createPrivateKey() falha mesmo com headers/footers e quebras de linha aparentando corretas. 

teste-ia-completo

A service account usada é vertex-gen-image-sa@future-abode-407113.iam.gserviceaccount.com no projeto future-abode-407113 (está OK). 

teste-ia-completo

Conclusão: a private_key que chega ao seu processo está mal formatada (ou com caracteres extras) quando é lida pelas variáveis de ambiente. Por isso o OpenSSL dá DECODER unsupported.

Conserto direto no código (garantido)
Opção A — usar o arquivo JSON (recomendado)

Pare de montar client_email/private_key manualmente. Aponte o código para o JSON da service account:

Defina GOOGLE_APPLICATION_CREDENTIALS apontando para o arquivo .json.

No código, deixe o google-auth-library cuidar de tudo:

import { GoogleAuth } from "google-auth-library";

const auth = new GoogleAuth({
  scopes: "https://www.googleapis.com/auth/cloud-platform",
  // sem credentials aqui: ele vai ler do GOOGLE_APPLICATION_CREDENTIALS
});

const client = await auth.getClient();
const { token } = await client.getAccessToken();


Se fizer só isso, o erro DECODER some — porque quem lê o PEM passa a ser a lib do Google a partir do arquivo original.

Opção B — quer continuar sem arquivo? Use 1 variável com o JSON inteiro

No .env:

GOOGLE_CREDENTIALS_JSON={"type":"service_account","project_id":"future-abode-407113","private_key_id":"...","private_key":"-----BEGIN PRIVATE KEY-----\n... \n-----END PRIVATE KEY-----\n","client_email":"vertex-gen-image-sa@future-abode-407113.iam.gserviceaccount.com"}


No código:

import { GoogleAuth } from "google-auth-library";

const creds = JSON.parse(process.env.GOOGLE_CREDENTIALS_JSON);
const auth = new GoogleAuth({
  credentials: creds,
  scopes: "https://www.googleapis.com/auth/cloud-platform",
});

const client = await auth.getClient();
const { token } = await client.getAccessToken();

Opção C — manter GOOGLE_CLIENT_EMAIL + GOOGLE_PRIVATE_KEY (corrigindo o PEM)

Se insistir nesse modo, normalize a private key (os \n literais são a causa #1 desse erro):

import { GoogleAuth } from "google-auth-library";

const privateKey = (process.env.GOOGLE_PRIVATE_KEY || "")
  .replace(/\\n/g, "\n")   // transforma \n literais em quebras reais
  .replace(/\r/g, "");     // remove CR em Windows

const auth = new GoogleAuth({
  projectId: process.env.GCLOUD_PROJECT,
  credentials: {
    client_email: process.env.GOOGLE_CLIENT_EMAIL,
    private_key: privateKey,
  },
  scopes: "https://www.googleapis.com/auth/cloud-platform",
});


No seu relatório, a checagem diz que há quebras reais, mas crypto.createPrivateKey() ainda falha — típico quando sobram aspas, espaços escondidos ou caracteres estranhos no começo/fim. 

teste-ia-completo


Por isso A (arquivo) ou B (JSON único) são bem mais à prova de erro.

Teste de 5 segundos (coloque antes da chamada ao Vertex)

Assim você pega exatamente onde está o problema:

import crypto from "node:crypto";

// Se estiver no modo A (arquivo):
//   leia o JSON do caminho GOOGLE_APPLICATION_CREDENTIALS e passe json.private_key aqui.
const pk = (process.env.GOOGLE_PRIVATE_KEY || "").replace(/\\n/g, "\n").replace(/\r/g, "");

crypto.createPrivateKey({ key: pk }); // se quebrar aqui, a chave está mal formatada
console.log("Private key OK");


Se quebrar aqui → a chave não está chegando com o conteúdo correto ao processo (problema de .env/deploy), não é o Vertex.

Outras verificações rápidas (evitam dor de cabeça)

Nada de ?key= na URL e sem header x-goog-api-key (o Vertex não aceita API key).

Endpoint correto:
https://us-central1-aiplatform.googleapis.com/v1/projects/{PROJECT}/locations/us-central1/publishers/google/models/gemini-2.5-flash-image:generateContent

Node 18+ (OpenSSL 3).

Papéis da SA: Vertex AI User + Service Usage Consumer.

A sua chave foi exposta; revogue e gere outra (o seu próprio arquivo nota isso como prioridade). 

teste-ia-completo

Por que eu digo que é formatação da chave (e não o modelo/endpoint)

O stack aponta para a fase de assinatura OAuth2 antes de chamar o Vertex. 

teste-ia-completo

O relatório confirma falha em crypto.createPrivateKey() isoladamente. 

teste-ia-completo

A SA/Projeto/Região estão corretos. 

teste-ia-completo

Faça A (arquivo) ou B (JSON único) e rode o teste crypto.createPrivateKey() — isso resolve. Se quiser, me mostre como você está carregando a credencial (um trecho de 10 linhas) e eu mando o patch exato linha por linha.