Abaixo vai um desenho prático do que implementar (lado servidor + cliente), com critérios claros e prazos sugeridos. Não vou cuspir código—só contrato/fluxo e formatos de payload para você plugar no que já tem.

Objetivo

O card de raspadinha não pode aparecer toda vez que a página recarrega — só quando o usuário estiver elegível segundo regras.

Quando o usuário raspar e revelar o desconto, ele fica disponível por um tempo (contagem regressiva real, validada no servidor), e depois expira.

Tudo server-side authoritative (o cliente não manda na regra), e o front só espelha o estado.

Regras de elegibilidade (sugestões práticas)
Por usuário (ou visitante anônimo)

Cooldown global: 1 raspadinha a cada 24h por usuário (ou anonId).

Cooldown por produto/campanha: 1 a cada 7 dias por produto (para evitar farm em um item só).

Chance de exibição (opcional): exiba para 30–50% dos elegíveis para reduzir fadiga/abuso.

Engajamento mínimo (opcional): só liberar depois de N segundos na página (ex.: 8s) ou após o usuário rolar 50% da viewport.

Por campanha/produto

Janela de campanha: datas de início e término.

Cap de estoque/orçamento: só exibir enquanto houver cota (por dia/total).

Segmentação (opcional): limitar por geo (País: PY), dispositivo, origem de tráfego, etc.

Observação: como você já retorna expiresAt no POST de scratch, mantenha o prazo de uso do desconto no servidor e apenas reflita no front.

Prazos sugeridos (reveal & redeem)

Tempo de disponibilidade do desconto após raspar (reveal TTL):

Descontos pequenos (< US$10): 20–30 min

Médios (US$10–50): 45–60 min

Grandes (> US$50): 2 horas

Grace period: 5 minutos extras para concluir o checkout se o usuário já iniciou.

Cooldown pós-expiração: mantém o cooldown de 24h mesmo se a pessoa não comprar (evita raspar repetido até “sair melhor”).

Fluxo de API (simples e seguro)
1) Checar elegibilidade (antes de renderizar o card)

GET /api/scratch/offers?product_id=...

Resposta (exemplo):

{
  "eligible": true,
  "offer_id": "off_9b2...",
  "show": true,
  "cooldown_until": "2025-08-28T15:00:00Z",
  "prob_bucket": 0.42,
  "reveal_ttl_sec": 1800,
  "token": "eyJhbGciOiJI..."  // token assinado (HMAC/JWT), curto, single-use
}


Servidor decide tudo (eligível, probabilidade, cooldown, TTL).

Se eligible=false ou show=false, o front não renderiza a raspadinha.

2) Revelar (quando atingir 70% raspado)

POST /api/scratch/offers/:offer_id/reveal

Body: { "token": "..." } (o mesmo da elegibilidade)
Resposta:

{
  "status": "revealed",
  "discount_price": "99.90",
  "expiresAt": "2025-08-27T19:10:00Z",  // para o seu timer
  "claim_id": "clm_12a...",
  "redeem_token": "short-lived-nonce"
}


expiresAt vem do servidor (fonte da verdade).

Guarde claim_id e expiresAt no cliente (localStorage/IndexedDB) só para UI.

O desconto de verdade é aplicado no checkout validando claim_id no servidor.

3) Aplicar no checkout

POST /api/checkout/apply-scratch

{ "claim_id": "clm_12a...", "redeem_token": "short-lived-nonce" }


Servidor valida: claim não expirado, não usado, pertence ao mesmo user/anon, produto coincide, IP/user-agent plausível, etc.

Marca como redeemed e aplica o preço especial.

Estado no cliente (evitar reaparecimento no refresh)

Gere/guarde um anonId (UUID) em cookie httpOnly no primeiro acesso (para não depender de login).

Para UX, você pode guardar somente:

scratch:active:{offer_id} → { expiresAt, claim_id }

scratch:cooldown:{anonId} → cooldown_until

scratch:cooldown:{anonId}:{productId} → cooldown_until

Esses valores não têm poder sobre o desconto em si; só evitam re-render desnecessário. A verdade está no servidor.

Sincronize entre abas com BroadcastChannel (evita duas abas mostrarem raspadinha ao mesmo tempo).

Anti-abuso (leve e eficiente)

Token de elegibilidade assinado (HMAC/JWT) com TTL curto (ex.: 10 min) e single-use (marque como usado quando revelar).

Rate limit por IP/anonId: ex. 60/min em endpoints de elegibilidade e 10/min em reveal.

Bot guard: invisível reCAPTCHA no reveal ou heurística de gesto (raspar precisa durar ≥120ms e ter velocidade/variação humanas).

Amarração ao checkout: claim_id precisa bater com anonId/userId da sessão e com product_id.

Hash de IP + user-agent (com salt) para detectar abuso grosseiro (sem guardar IP limpo).

Tabela de estados (servidor)

hidden → não elegível/no-show

eligible → oferta criada, aguardando scratch (offer_id, token)

revealed → desconto liberado, expiresAt ativo

expired → passou o prazo

redeemed → usado no checkout

cooldown → próximo horário permitido

Bancos / modelos (sugestão de campos)

scratch_offers: id, user_id/anon_id, product_id, status, created_at, reveal_deadline_at, redeem_deadline_at, cooldown_until, eligibility_token_hash, reveal_token_hash, source, user_agent, ip_hash

scratch_campaigns: id, product_id, start_at, end_at, daily_cap, per_user_cooldown_sec, per_product_cooldown_sec, show_probability, reveal_ttl_sec, redeem_grace_sec

(Você já tem o POST de scratch; é basicamente adicionar a etapa 1 de elegibilidade e a etapa 3 de aplicação no checkout.)

Integração com o que você já tem

Você já consome expiresAt no onSuccess da mutation. Perfeito.

Antes de renderizar o <ScratchCard>, faça o GET de elegibilidade. Se vier eligible=false ou show=false, nem renderize o card; mostre o card tradicional.

Se o usuário raspar e sair da página, ao voltar você:

Checa no servidor o estado do offer_id/claim_id (ou usa os dados do localStorage para acelerar) e renderiza direto no estado revelado com o timer.

Valores padrão (se quiser algo pronto pra testar)

per_user_cooldown_sec: 86.400 (24h)

per_product_cooldown_sec: 604.800 (7d)

show_probability: 0.4 (40%)

reveal_ttl_sec: 1.800 (30 min)

redeem_grace_sec: 300 (5 min)