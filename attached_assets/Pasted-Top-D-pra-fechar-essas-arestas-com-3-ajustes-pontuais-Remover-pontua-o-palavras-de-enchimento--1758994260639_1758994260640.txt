Top! D√° pra fechar essas arestas com 3 ajustes pontuais:

Remover pontua√ß√£o/‚Äúpalavras de enchimento‚Äù antes de classificar ‚Üí ‚Äúe perfumes?‚Äù, ‚Äúquero ver alguns drones‚Äù passam a virar perfume, drone.

Regras de continua√ß√£o: frases come√ßando com ‚Äúe‚Äù, ‚Äútamb√©m‚Äù, ‚Äúmais‚Äù trocam o foco para o novo produto/categoria.

Small talk/comandos b√°sicos: ‚Äúqual seu nome‚Äù, ‚Äúajuda‚Äù, ‚Äúmenu‚Äù, ‚Äúque horas s√£o‚Äù n√£o caem na busca.

Aplique os diffs abaixo (compat√≠veis com seus patches anteriores).

1) src/utils/lang-ptbr.ts ‚Äî normaliza√ß√£o com pontua√ß√£o + stopwords
*** a/src/utils/lang-ptbr.ts
--- b/src/utils/lang-ptbr.ts
@@
 export function normPTBR(s: string): string {
-  const base = (s ?? "")
+  const base = (s ?? "")
     .toLowerCase()
     .normalize("NFD")
     .replace(/[\u0300-\u036f]/g, "") // remove acentos
+    .replace(/[^\p{L}\p{N}\s]/gu, " ") // remove pontua√ß√£o ?!.,:
     .replace(/\s+/g, " ")
     .trim();
   return base
     .replace(/\bvc\b/g, "voce")
     .replace(/\bvcs\b/g, "voces")
     .replace(/\bq\b/g, "que")
     .replace(/\bpra\b/g, "para")
     .replace(/\btv's\b/g, "tvs")
     .replace(/\biphone's\b/g, "iphones");
 }
 
+// Palavras de enchimento que n√£o definem inten√ß√£o
+const STOPWORDS = new Set([
+  "e","tambem","tamb√©m","mais","por","favor","pf","porfa",
+  "quero","queria","gostaria","mostra","mostrar","me","ver",
+  "algum","alguns","alguma","algumas","tem","temos","voc","voce","voces",
+  "de","do","da","os","as","um","uma","uns","umas","ai","a√≠","porfavor"
+]);
+
 export function tokenizePTBR(msg: string): string[] {
-  return normPTBR(msg).split(/\s+/g);
+  return normPTBR(msg).split(/\s+/g).filter(t => t && !STOPWORDS.has(t));
 }


Isso sozinho resolve ‚Äúe perfumes?‚Äù (vira token perfumes ‚Üí can√¥nico perfume) e ‚Äúquero ver alguns drones‚Äù (vira drones ‚Üí drone).

2) src/nlp/intent.ts ‚Äî melhorar inten√ß√£o (PT), ‚Äúqual seu nome‚Äù, ‚Äúajuda‚Äù
*** a/src/nlp/intent.ts
--- b/src/nlp/intent.ts
@@
-import { normPTBR, canonicalProductFromText, canonicalCategoryFromText } from "./../utils/lang-ptbr";
+import { normPTBR, canonicalProductFromText, canonicalCategoryFromText } from "./../utils/lang-ptbr";
 
 export type Intent =
   | "PRODUCT_SEARCH"
   | "SMALL_TALK"
   | "TIME_QUERY"
+  | "WHOAMI"
   | "OUT_OF_DOMAIN"
   | "HELP"
   | "UNKNOWN";
@@
-const SMALL_TALK_RX = /\b(oi|ol[a√°]|bom dia|boa tarde|boa noite|tudo bem|como vai|e ai|e a√≠)\b/;
-const HELP_RX = /\b(ajuda|como funciona|o que voc[e√™] faz|dica|sugest[a√£]o)\b/;
-const TIME_RX = /\b(que horas s[a√£]o|hor[a√°]rio|agora)\b/;
+const SMALL_TALK_RX = /\b(oi|ol[a√°]|bom dia|boa tarde|boa noite|tudo bem|como vai|e ai|e a√≠)\b/;
+const HELP_RX = /\b(ajuda|como funciona|o que voc[e√™] faz|menu|dica|sugest[a√£]o)\b/;
+const TIME_RX = /\b(que horas s[a√£]o|hor[a√°]rio|agora)\b/;
+const WHOAMI_RX = /\b(qual seu nome|quem √© voc[e√™]|quem e voc[e√™]|sua fun[c√ß][a√£]o)\b/;
@@
   if (m.length < 2) return { intent: "UNKNOWN" };
   if (TIME_RX.test(m)) return { intent: "TIME_QUERY" };
   if (SMALL_TALK_RX.test(m)) return { intent: "SMALL_TALK" };
   if (HELP_RX.test(m)) return { intent: "HELP" };
+  if (WHOAMI_RX.test(m)) return { intent: "WHOAMI" };
 
   const productCanon = canonicalProductFromText(m);
   const categoryCanon = canonicalCategoryFromText(m);

3) src/services/smalltalk.ts ‚Äî respostas b√°sicas
*** a/src/services/smalltalk.ts
--- b/src/services/smalltalk.ts
@@
 export function replyHelp(): string {
   return "Me diga o produto ou categoria (ex.: iPhone 12, Galaxy 15, drone com c√¢mera). Posso filtrar por pre√ßo, marca e modelo. üòâ";
 }
 
 export function replyTime(): string {
   const now = new Date();
   const hh = String(now.getHours()).padStart(2, "0");
   const mm = String(now.getMinutes()).padStart(2, "0");
   return `Agora s√£o ${hh}:${mm} ‚è∞`;
 }
 
 export function replyOutOfDomain(exemplo?: string): string {
   return `Ainda n√£o consigo ajudar com isso. ${exemplo ?? "Me diz um produto (ex.: iPhone, drone, perfume) que eu busco pra voc√™ üòä"}`;
 }
+
+export function replyWhoAmI(): string {
+  return "Eu sou o Gemini Assistant. Te ajudo a encontrar produtos por conversa: pode pedir ‚Äúdrones‚Äù, ‚Äúperfumes‚Äù, ‚ÄúiPhone 12 128GB‚Äù, etc.";
+}

4) src/services/conversation.ts ‚Äî roteamento + troca de foco em ‚Äúe perfumes?‚Äù
*** a/src/services/conversation.ts
--- b/src/services/conversation.ts
@@
-import { replyHelp, replyOutOfDomain, replySmallTalk, replyTime } from "./smalltalk";
+import { replyHelp, replyOutOfDomain, replySmallTalk, replyTime, replyWhoAmI } from "./smalltalk";
+import { canonicalProductFromText, tokenizePTBR } from "../utils/lang-ptbr";
@@
   if (intent.intent === "SMALL_TALK") {
     return { kind: "SMALL_TALK", text: replySmallTalk() };
   }
   if (intent.intent === "HELP") {
     return { kind: "HELP", text: replyHelp() };
   }
   if (intent.intent === "TIME_QUERY") {
     return { kind: "TIME", text: replyTime() };
   }
+  if (intent.intent === "WHOAMI") {
+    return { kind: "SMALL_TALK", text: replyWhoAmI() };
+  }
@@
-  const novoFoco = detectarFoco(userMsg);
+  // Regra de continua√ß√£o: se come√ßa com "e" / "tamb√©m" e tiver novo produto, troca foco
+  const toks = tokenizePTBR(userMsg);
+  const startsWithAnd = toks[0] === "e" || toks[0] === "tambem" || toks[0] === "tamb√©m";
+  const novoProduto = canonicalProductFromText(userMsg);
+  const novoFoco = startsWithAnd && novoProduto ? novoProduto : detectarFoco(userMsg);
   if (novoFoco) await updateSession(sessionId, { focoAtual: novoFoco });
   const foco = novoFoco ?? (sess as any).focoAtual ?? null;

5) (Opcional) src/routes/assistant.ts ‚Äî sempre mostrar texto can√¥nico no debug
*** a/src/routes/assistant.ts
--- b/src/routes/assistant.ts
@@
-  const resposta = `Achei ${resultados.length} op√ß√£o(√µes) para "${display}". Quer ver os detalhes?`;
-  return res.json({ text: resposta, debug: { query: { ...query, queryFinal: display } }, produtos: resultados });
+  const resposta = `Achei ${resultados.length} op√ß√£o(√µes) para "${display}". Quer ver os detalhes?`;
+  return res.json({ text: resposta, debug: { original: message, canon: query.queryFinal, query }, produtos: resultados });

O que isso corrige nas suas telas

‚Äúe perfumes?‚Äù: agora vira produto perfume (pontua√ß√£o removida + stopwords) e muda o foco; retorna resultados.

‚Äúquero ver alguns drones‚Äù: stopwords removidas, ‚Äúdrones‚Äù can√¥nico ‚Üí drone.

‚Äúqual seu nome‚Äù: cai em WHOAMI e responde amig√°vel, ao inv√©s de tentar buscar produto.

Pesquisas espec√≠ficas continuam boas: ‚Äúiphone 16‚Äù, ‚Äúiphone 12 pro 256gb‚Äù etc.

Se ainda aparecer a mensagem ‚ÄúN√£o encontrei produtos para texto inteiro‚Äù, √© porque algum endpoint est√° bypassando o orquestrador. Garanta que todas as rotas usem o mesmo pipeline (tokenizePTBR ‚Üí can√¥nico ‚Üí runAssistant/interpretarBusca).