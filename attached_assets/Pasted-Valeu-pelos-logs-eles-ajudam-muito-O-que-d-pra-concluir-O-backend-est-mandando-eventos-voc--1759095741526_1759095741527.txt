Valeu pelos logs â€” eles ajudam muito. O que dÃ¡ pra concluir:

O backend estÃ¡ mandando eventos (vocÃª recebeu produtos para â€œiphoneâ€ e â€œstream concluÃ­doâ€ pros dois turnos).

O front estÃ¡ montando/re-montando o componente muitas vezes (â€œComponente inicializadoâ€ dezenas/centenas de vezes). Isso costuma acontecer por:

useEffect sem guarda (StrictMode chama 2x) + setState no efeito â†’ loop.

â€œregistrar listenersâ€ a cada render.

Na consulta â€œquero um mais baratoâ€, o stream terminou mas nenhum texto do servidor foi mostrado (apenas o fallback). Precisamos garantir que o text do backend seja usado e que os listeners do SSE sejam registrados apenas 1x.

Abaixo vÃ£o dois patches de frontend (sÃ³ JS/TSX) que resolvem o que os logs mostram. Eles sÃ£o â€œcola e substituiâ€ dentro do seu GeminiAssistantBar.tsx (ajuste nomes se diferirem). NÃ£o mexem em layout, sÃ³ em ciclo de vida, stream e texto.

PATCH Front-01 â€” SessÃ£o + efeito inicial estÃ¡vel (elimina re-render/loop)

Coloque no topo do componente (logo apÃ³s os imports):

// Evita setup duplicado em React StrictMode e loops de render
const didInitRef = React.useRef(false);

// Estado que vocÃª jÃ¡ deve ter:
const [sessionId, setSessionId] = React.useState<string | null>(null);


Substitua o seu useEffect de setup de sessÃ£o/listeners por este (uma Ãºnica execuÃ§Ã£o):

React.useEffect(() => {
  // StrictMode chamarÃ¡ 2x em dev; evitamos repetir
  if (didInitRef.current) return;
  didInitRef.current = true;

  console.log("ğŸ¤– [GeminiAssistantBar] Componente inicializado");

  // SessÃ£o persistida
  const sidKey = "gemini.sessionId";
  let sid = localStorage.getItem(sidKey);
  if (!sid) {
    sid = `web_${Math.random().toString(36).slice(2)}${Date.now().toString(36)}`;
    localStorage.setItem(sidKey, sid);
  }
  setSessionId(sid);
  console.log("âœ… [GeminiAssistantBar] SessÃ£o criada/sincronizada:", { sid });

  // Se vocÃª registra listeners globais, faÃ§a aqui e lembre o cleanup:
  // window.addEventListener("visibilitychange", ...);

  return () => {
    // window.removeEventListener("visibilitychange", ...);
  };
}, []); // <<< deps vazias


Isso remove o loop (seu log mostrava dezenas/centenas de montagens).
ObservaÃ§Ã£o: o 401 /api/auth/user nÃ£o Ã© o causador do loop; Ã© sÃ³ uma chamada do seu app sem auth. Pode ignorar por ora.

PATCH Front-02 â€” Stream/SSE: sempre usar text do backend e registrar 1x

No mÃ©todo que dispara a busca (ex.: startGeminiStream), garanta que usa sempre a mesma sessÃ£o:

async function startGeminiStream(message: string) {
  if (!sessionId) {
    console.warn("â³ Sem sessionId ainda â€” adiando envio");
    return;
  }
  console.log("ğŸš€ start stream", { message, sessionId });

  // Mostra a mensagem do usuÃ¡rio no chat
  setChatMessages(prev => [...prev, { type: "user", text: message }]);

  const resp = await fetch("/api/assistant/query/stream", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ message, sessionId, lang: "pt" })
  });

  const reader = resp.body?.getReader();
  const decoder = new TextDecoder();

  let assistantBuffer = ""; // acumula o texto vindo do backend

  while (reader) {
    const { value, done } = await reader.read();
    if (done) break;

    const chunk = decoder.decode(value, { stream: true });
    // cada linha JSON por evento
    for (const line of chunk.split("\n")) {
      const s = line.trim();
      if (!s) continue;
      try {
        const evt = JSON.parse(s);
        console.log("ğŸ“¨ SSE evento >", evt);

        // Se o backend mandar text, acumulamos
        if (evt.text) assistantBuffer += (assistantBuffer ? " " : "") + String(evt.text).trim();

        // Opcional: guardar produtos quando vierem
        if (Array.isArray(evt.items)) {
          console.log("ğŸ“¦ [GeminiAssistantBar] Produtos Gemini recebidos:", evt.items.length);
          // setProducts(evt.items)  // se vocÃª mantÃ©m lista Ã  direita
        }

        if (evt.done || evt.provider) {
          console.log("ğŸ [GeminiAssistantBar] Gemini stream marcado como completo");
        }

      } catch (e) {
        console.warn("âš ï¸ SSE parse falhou:", e, s);
      }
    }
  }

  // Final do stream â€” se o backend nÃ£o mandou text por qualquer motivo, manda algo neutro
  const finalText =
    assistantBuffer.trim() ||
    "Beleza! Posso filtrar por preÃ§o (mais barato), capacidade (64/128/256GB) ou modelo. O que prefere? ğŸ™‚";

  setChatMessages(prev => [...prev, { type: "assistant", text: finalText }]);
  console.log("âœ… [GeminiAssistantBar] Gemini stream concluÃ­do");
}

Por que isso resolve?

O texto do servidor (ex.: â€œAchei X iPhonesâ€¦ quer o mais barato?â€) nÃ£o Ã© substituÃ­do por nenhum fallback local baseado em items.length.

Qualquer verificaÃ§Ã£o tipo â€œse items.length===0 entÃ£o escreve mensagem fixaâ€ deve ser removida. Confie no evt.text do backend.

Listener e sessÃ£o ficam estÃ¡veis (sem mÃºltiplas execuÃ§Ãµes).