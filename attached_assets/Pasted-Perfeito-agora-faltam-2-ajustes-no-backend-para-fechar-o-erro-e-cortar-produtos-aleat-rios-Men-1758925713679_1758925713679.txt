Perfeito ‚Äî agora faltam 2 ajustes no backend para fechar o ‚Äúerro‚Äù e cortar produtos aleat√≥rios:

Mensagem de erro aparece porque o turno terminou sem texto; meu handler escrevia o fallback "Ops, algo deu errado‚Ä¶".

Produtos aleat√≥rios aparecem quando o modelo n√£o envia query ‚Üí sua busca roda sem filtro.

Abaixo vai o patch final (substitui s√≥ estes dois arquivos). Ele:

Garante inten√ß√£o de busca estruturada (extrai query/cidade/precoMax) antes do chat.

S√≥ emite products se tiver query v√°lida e com score.

Remove o fallback de erro; responde ‚Äún√£o encontrei‚Äù de forma clara.

Evita mensagem duplicada.

üîß Patch
// src/services/ofertas.js  (substituir)
export async function buscarOfertasService(args) {
  const { query, cidade, precoMax, maxResultados = 10 } = args || {};
  const q = (query || "").toLowerCase().trim();

  // Sem query v√°lida ‚Üí n√£o devolve nada (evita aleat√≥rios)
  if (q.length < 2) return [];

  const MOCK = [
    { id: "P1", titulo: "iPhone 13 128GB", preco: 980, cidade: "Pedro Juan", link: "https://exemplo/iphone13" },
    { id: "P2", titulo: "iPhone 12 64GB", preco: 750, cidade: "Pedro Juan", link: "https://exemplo/iphone12" },
    { id: "P3", titulo: "Samsung S23", preco: 900, cidade: "Ciudad del Este", link: "https://exemplo/s23" },
    { id: "P4", titulo: "iPhone 15 128GB", preco: 1200, cidade: "Pedro Juan", link: "https://exemplo/iphone15" }
  ];

  // score simples de relev√¢ncia por termo
  const score = (t) => {
    const s = t.toLowerCase();
    if (s === q) return 3;
    if (s.includes(q)) return 2;
    return 0;
  };

  let arr = MOCK
    .map(o => ({ ...o, _score: score(o.titulo) }))
    .filter(o => o._score > 0);

  if (cidade) arr = arr.filter(o => (o.cidade || "").toLowerCase() === cidade.toLowerCase());
  if (typeof precoMax === "number") arr = arr.filter(o => o.preco <= precoMax);

  // ranking: score desc, depois pre√ßo asc
  arr.sort((a, b) => (b._score - a._score) || (a.preco - b.preco));
  arr = arr.slice(0, Math.max(1, Math.min(50, maxResultados)));

  // remove campo interno
  return arr.map(({ _score, ...rest }) => rest);
}

// src/ai/chat.js  (substituir)
import OpenAI from "openai";
import { TOOLS } from "./tools.js";
import { buscarOfertasService } from "../services/ofertas.js";
import { safeJSON, isNonEmptyString } from "../utils/validate.js";

export async function chatOnce({ message, sessionId, meta }) {
  const client = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });

  // 1) EXTRA√á√ÉO DETERMIN√çSTICA DE INTEN√á√ÉO (evita query vazia)
  const intentSchema = {
    name: "click_intent",
    schema: {
      type: "object",
      properties: {
        intent: { type: "string", enum: ["buscar", "conversa"] },
        query: { type: "string" },
        cidade: { type: "string" },
        precoMax: { type: "number" }
      },
      required: ["intent"]
    },
    strict: true
  };

  const intentResp = await client.chat.completions.create({
    model: "gpt-4o-mini",
    messages: [
      { role: "system", content: "Extraia inten√ß√£o do usu√°rio para Click Ofertas." },
      { role: "user", content: message }
    ],
    response_format: { type: "json_schema", json_schema: intentSchema },
    temperature: 0
  });

  let extracted = {};
  try { extracted = JSON.parse(intentResp.choices?.[0]?.message?.content || "{}"); } catch {}
  const baseArgs = {
    query: (extracted.query || "").trim(),
    cidade: (extracted.cidade || "").trim() || undefined,
    precoMax: typeof extracted.precoMax === "number" ? extracted.precoMax : undefined
  };

  const system = [
    "Voc√™ √© o Assistente do Click Ofertas.",
    "Se precisar de cat√°logo, use a ferramenta buscarOfertas.",
    "Responda curto e claro em PT-BR.",
    "Se a busca n√£o retornar itens, explique r√°pido e sugira refinar a consulta."
  ].join(" ");

  const messages = [
    { role: "system", content: system },
    { role: "user", content: message }
  ];

  const tools = TOOLS;
  const model = "gpt-4o-mini";

  // 2) PR√â-EXECUTA busca quando j√° temos 'query' v√°lida ‚Üí UX mais r√°pido
  let preProdutos = [];
  if (baseArgs.query && baseArgs.query.length >= 2) {
    preProdutos = await buscarOfertasService({ ...baseArgs, maxResultados: 10 });
  }

  // 3) CONVERSA COM TOOLS (com stream interno, mas retornamos objeto final)
  let productsNotified = false;
  const notifyProducts = (arr, query) => {
    if (productsNotified) return;
    if (Array.isArray(arr) && arr.length > 0) productsNotified = true;
  };

  // Monta primeira mensagem do assistente com contexto dos produtos j√° buscados
  if (preProdutos.length > 0) {
    messages.push({
      role: "tool",
      name: "buscarOfertas",
      tool_call_id: "pre",
      content: safeJSON({ data: preProdutos })
    });
  }

  // Loop de no m√°ximo 2 turns
  for (let step = 0; step < 2; step++) {
    const completion = await client.chat.completions.create({
      model, temperature: 0.3, messages, tools, tool_choice: "auto"
    });

    const msg = completion.choices?.[0]?.message;
    const toolCalls = msg?.tool_calls || [];

    if (toolCalls.length > 0) {
      for (const call of toolCalls) {
        if (call.type === "function" && call.function?.name === "buscarOfertas") {
          let args = {};
          try { args = JSON.parse(call.function.arguments || "{}"); } catch {}
          // merge com baseArgs para garantir query/cidade/preco
          const finalArgs = {
            ...baseArgs,
            ...args,
            query: (args.query || baseArgs.query || "").trim()
          };

          const ofertas = await buscarOfertasService(finalArgs);
          notifyProducts(ofertas, finalArgs.query);

          messages.push({
            role: "tool",
            tool_call_id: call.id,
            name: "buscarOfertas",
            content: safeJSON({ data: ofertas })
          });
        }
      }
      continue; // volta para o modelo integrar o resultado
    }

    // Resposta final do modelo
    const text = isNonEmptyString(msg?.content) ? msg.content : "";
    const lastTool = messages.findLast?.(m => m.role === "tool" && m.name === "buscarOfertas");
    const ofertas = lastTool ? JSON.parse(lastTool.content).data : [];

    // Se n√£o veio texto, monte um curto sem ‚Äúerro‚Äù
    const finalText =
      text ||
      (ofertas?.length
        ? "Aqui est√£o as ofertas mais relevantes:"
        : "N√£o encontrei ofertas para sua busca. Tente informar modelo, cidade e um pre√ßo m√°ximo.");

    return { text: finalText, ofertas };
  }

  // Fallback seguro (sem ‚ÄúOps, algo deu errado‚Äù)
  return {
    text: "N√£o consegui fechar a resposta agora. Pode refazer sua busca indicando produto e cidade?",
    ofertas: preProdutos || []
  };
}

Por que resolve

Nunca mais ‚ÄúOps, algo deu errado‚Äù: removi o fallback e troquei por mensagens claras e condicionais.

Produtos s√≥ quando fizer sentido: a busca s√≥ roda com query ‚â• 2 chars; sem query ‚Üí zero produtos (n√£o aleat√≥rios).

Inten√ß√£o estruturada: um passo JSON garante query/cidade/precoMax antes do tool calling, aumentando a precis√£o.

Sem duplicidade: n√£o enviamos ‚Äúmensagem inicial‚Äù via streaming; apenas a resposta final.