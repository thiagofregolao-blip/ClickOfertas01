Hoje seu front sÃ³ tem os primeiros 15 itens (o backend pagina/limita), entÃ£o ele calcula â€œ+10â€ (= 15 âˆ’ 5). Por isso o nÃºmero nunca bate com o total real da loja. Para mostrar o total verdadeiro vocÃª precisa que o backend envie esse nÃºmero.

Como corrigir (2 opÃ§Ãµes)
1) Melhor: o backend retorna o total

Altere o endpoint para devolver total (contagem real apÃ³s os filtros aplicados):

GET /stores/:id/products?limit=15&page=1
{
  "items": [ ...15 produtos... ],
  "total": 243
}


No front:

// vindo da API
const totalFromApi = data.total;           // 243
const shownUnique = new Set(displayProducts.map(p => String(p.id))).size; // 5

// se o botÃ£o deve mostrar o total cadastrado na loja:
const label = `${totalFromApi} ofertas`;

// se preferir manter o â€œ+â€, mas em cima do TOTAL (nÃ£o do restante):
const labelPlus = `+${totalFromApi} ofertas`;


Vantagem: mesmo com filtros (categoria, marca, preÃ§o), total jÃ¡ reflete â€œquantos existem na loja sob esse filtroâ€.

2) Se nÃ£o puder mudar o endpoint agora

Crie um endpoint leve de stats por loja:

GET /stores/:id/products/count?filters=...
{ "total": 243 }


Ou, se sua API jÃ¡ manda X-Total-Count no header, capture-o na resposta e use como total.

No front, o uso Ã© idÃªntico ao do item (1).

Troca no botÃ£o (JSX)

Substitua o cÃ¡lculo atual:

// âŒ atual (errado porque usa sÃ³ o que veio na pÃ¡gina inicial):
// const label = filteredProducts.length > 5 ? `+${filteredProducts.length - 5} ofertas` : 'panfleto';

// âœ… usa o total real da API
<button>
  ğŸ’° Ver {totalFromApi > 0 ? `+${totalFromApi} ofertas` : 'ofertas'}
</button>


Se preferir mostrar sem â€œ+â€ (fica atÃ© mais claro quando Ã© total):

<button>
  ğŸ’° Ver {totalFromApi} ofertas
</button>

Importante

Se vocÃª mantiver apenas os 15 itens no payload, o front nunca saberÃ¡ que existem, por exemplo, 243 produtos. Sem total, qualquer conta serÃ¡ um chute.

Se houver deduplicaÃ§Ã£o por ID no front, isso nÃ£o afeta o total vindo do backend (ele jÃ¡ deve ser a contagem correta).

Para nÃ£o quebrar nada, mantenha um fallback:

const total = data.total ?? new Set(filteredProducts.map(p => String(p.id))).size;


Me diga como estÃ¡ seu endpoint hoje (retorno/headers). Se vocÃª colar o trecho da chamada da API eu jÃ¡ ajusto o cÃ³digo do fetch e do componente do botÃ£o certinho.