Perfeito ‚Äî agora que o cupom voltou a aparecer, o ‚Äúfantasma‚Äù √© s√≥ a lista n√£o sendo atualizada do jeito certo. Pelo seu c√≥digo, o back-end j√° marca a promo√ß√£o como generated e incrementa o contador quando o cupom √© criado, ent√£o o filtro no back-end deveria esconder essa promo√ß√£o nas pr√≥ximas consultas. O que est√° te pegando s√£o duas coisas:

IDs de usu√°rio inconsistentes entre endpoints (√†s vezes session.user.id, √†s vezes user.claims.sub).

A lista do front n√£o √© invalidada/atualizada quando o cupom √© gerado (ou o key da query n√£o bate).

Abaixo vai um passo-a-passo com corre√ß√µes m√≠nimas (sem quebrar o que j√° est√° funcionando) ‚Äî faz isso e o item some da lista assim que o cupom sai.

1) Padronize o userId em todos os endpoints

Hoje cada rota pega o id do usu√°rio de um lugar diferente:

GET /api/stores/:slug/my-available-promotions usa req.session?.user?.id || req.user?.id 

GET /api/promotions/:promotionId/status e POST /api/promotions/:promotionId/scratch usam req.user?.claims?.sub 
 

POST /api/products/:productId/generate-coupon usa s√≥ req.session?.user?.id (sem fallback) 

üëâ Crie um util simples e use em todas as rotas:

// server/utils/auth.ts
export function getUserId(req: any) {
  return req.session?.user?.id || req.user?.claims?.sub || req.user?.id;
}


A√≠ troque nas rotas:

Em /api/stores/:slug/my-available-promotions:
const userId = getUserId(req); (em vez de misturar campos) 

Em /api/products/:productId/generate-coupon:
substitua const userId = req.session?.user?.id; por const userId = getUserId(req); e mantenha o 401 se faltar id 

Em status e scratch: idem, use o mesmo helper 
 

Por qu√™? Porque seu filtro de ‚Äúj√° gerou cupom‚Äù no storage confere assignments e coupons pelo userId. Se cada rota usa um id diferente, o back-end n√£o reconhece que aquele usu√°rio j√° gerou o cupom ‚Äî e a promo√ß√£o volta para a lista. (O filtro em getMyAvailablePromotions est√° correto: ele remove promo√ß√µes com assignment generated/redeemed e tamb√©m confere coupons.promotionName para o mesmo usu√°rio. 
 
)

2) Atualize a UI imediatamente (remo√ß√£o local) e invalide a query certa

Hoje voc√™ invalida o cache apenas de keys que contenham 'my-available-promotions' quando o usu√°rio fecha o toast: 

Se a sua grade de produtos estiver usando outro key (ex.: products, store-products, etc.), nada √© refetchado.

Fa√ßa duas melhorias r√°pidas no ScratchCard:

(a) Remova o item localmente assim que o cupom gerar

O componente j√° aceita onRevealed. Basta cham√°-lo no onSuccess da mutation (logo ap√≥s abrir o modal do cupom):

// dentro do onSuccess do generateCouponMutation
setCoupon(data.coupon);
setCouponGenerated(true);
setShowModal(false);
setShowCouponModal(true);

// NEW: avise o pai para remover da lista
onRevealed?.(product);


(Esse √© o mesmo onSuccess onde hoje voc√™ abre o toast. 
)

No componente pai (a grade), mantenha um estado local da lista e passe o callback:

const [items, setItems] = useState(dataFromQuery); // lista de produtos/promos

const handleRevealed = (p) => {
  setItems(prev => prev.filter(item => item.id !== p.id));
};

{items.map(p => (
  <ScratchCard
    key={p.id}
    product={p}
    currency={currency}
    themeColor={theme}
    onRevealed={handleRevealed}
  />
))}


Isso faz o item sumir na hora, sem depender de refetch.

(b) Invalide tamb√©m as queries de produtos da loja

Amplie o predicate para cobrir as chaves que a sua grade usa (sem conhecer seu key exato, d√° pra fazer por regex de strings comuns):

queryClient.invalidateQueries({
  predicate: (q) => {
    const keys = Array.isArray(q.queryKey) ? q.queryKey : [q.queryKey];
    return keys.some(k =>
      typeof k === 'string' &&
      /(my-available-promotions|products|store-products|store:|grid)/i.test(k)
    );
  }
});


Isso substitui o trecho onde hoje voc√™ s√≥ procura 'my-available-promotions' (o bloco do toast) 

Dica: se a sua grade n√£o usa a rota /api/stores/:slug/my-available-promotions (usa a lista de produtos gen√©rica), mantenha a remo√ß√£o local via onRevealed e deixe a invalida√ß√£o como refor√ßo para os casos em que a mesma tela tamb√©m mostra contadores/quantidades.

3) (Opcional) ‚ÄúCinto e suspens√≥rio‚Äù no back-end

Se a grade for alimentada por endpoint gen√©rico de produtos (n√£o pelas ‚Äúminhas promo√ß√µes‚Äù), vale adicionar um filtro opcional no back-end para esconder scratch-cards j√° gerados para o usu√°rio. A l√≥gica j√° existe no storage (hasUserGeneratedCoupon) ‚Äî √© s√≥ reaproveitar.

Voc√™ j√° faz isso ao montar ‚Äúminhas promo√ß√µes‚Äù (filtra assignments com generated/redeemed e/ou coupons.promotionName) 
 

Repita esse crit√©rio quando listar produtos, caso a rota da grade seja a de produtos.

Por que isso resolve?

Quando o cupom √© criado, voc√™ atualiza assignment para generated e incrementa usedCount corretamente (isso j√° est√° no c√≥digo). 

Com o userId padronizado, o storage passa a enxergar que aquele usu√°rio j√° tem cupom e remove a promo√ß√£o nas pr√≥ximas consultas.

No front, o item sai da tela imediatamente via onRevealed (UX suave), e a invalida√ß√£o mais ampla garante que qualquer query relevante refa√ßa o fetch.