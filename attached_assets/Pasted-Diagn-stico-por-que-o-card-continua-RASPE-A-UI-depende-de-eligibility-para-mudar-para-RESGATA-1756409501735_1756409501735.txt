DiagnÃ³stico (por que o card continua â€œRASPE!â€)

A UI depende de eligibility para mudar para â€œRESGATADOâ€, masâ€¦

tua useQuery nÃ£o tem queryFn â†’ em muitos setups ela nunca busca nada.

mesmo quando gera o cupom com sucesso, vocÃª nÃ£o refaz a consulta de elegibilidade (sÃ³ dÃ¡ refetch no onError).

resultado: o componente continua no estado â€œelegÃ­velâ€ (RASPE!) atÃ© um reload, enquanto o backend jÃ¡ marcou como ativo â€” por isso, ao clicar de novo, o servidor responde â€œjÃ¡ pegou o cupomâ€.

Loop de rAF e canvas seguem ativos apÃ³s o reveal.
Visualmente o overlay some, mas o â€œcard-baseâ€ ainda Ã© o de raspadinha; como eligibility nÃ£o muda, vocÃª vÃª exatamente a imagem que mandou (opacidade e badge â€œRASPE!â€).

PossÃ­vel cache do endpoint de elegibilidade.
Se algum proxy/navegador cachear, a resposta â€œainda elegÃ­velâ€ volta mesmo apÃ³s emitir cupom.

CorreÃ§Ã£o mÃ­nima (sem refatorar fluxo)
1) FaÃ§a a useQuery realmente buscar
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";

const qc = useQueryClient();

const { data: eligibility, isLoading: checkingEligibility } = useQuery({
  queryKey: ['/api/scratch/offers', product.id, 'eligibility'],
  queryFn: async () => {
    const r = await apiRequest(`/api/scratch/offers/${product.id}/eligibility`);
    return r.json();
  },
  enabled: !!product?.id,
  staleTime: 15_000,
});

2) Atualize a UI na hora que o cupom Ã© gerado

No onSuccess do generateCouponMutation, faÃ§a otimista + invalidaÃ§Ã£o:

onSuccess: (data: any) => {
  if (data?.success && data?.coupon) {
    setCoupon(data.coupon);
    setCouponGenerated(true);
    setShowModal(false);
    setShowCouponModal(true);

    // 2a) Atualiza o cache para este produto imediatamente
    qc.setQueryData(
      ['/api/scratch/offers', product.id, 'eligibility'],
      (prev) => ({
        eligible: false,
        hasActive: true,
        activeOffer: {
          // se o back nÃ£o retorna offer, derive um mÃ­nimo:
          productId: product.id,
          status: 'revealed',
          expiresAt: data.coupon.expiresAt, // ou Date.now()+30*60*1000 se preferir TTL curto
        },
      })
    );

    // 2b) E ainda dispara um refetch real para confirmar com o servidor
    qc.invalidateQueries({ queryKey: ['/api/scratch/offers', product.id, 'eligibility'] });

    toast({ title: "ğŸ‰ Cupom gerado!", description: "Veja os detalhes do seu cupom!", duration: 3000 });
  }
}


Isso faz o card trocar na mesma hora para o bloco â€œRESGATADOâ€, e depois confirma com o backend.

3) Garanta que o endpoint nÃ£o seja cacheado

No backend da elegibilidade:

app.get('/api/scratch/offers/:productId/eligibility', async (req, res) => {
  res.set('Cache-Control', 'no-store'); // <â€” evita resposta velha
  // ... resto da lÃ³gica
});

4) Pare o loop e desative o overlay apÃ³s reveal

Quando isFading/isRevealed ficar true:

cancelAnimationFrame(rafId.current) e zere rafId.current.

Coloque pointer-events: none no <canvas> enquanto ele some (vocÃª jÃ¡ aplica a transiÃ§Ã£o; falta cortar eventos).

Ex. no JSX do canvas:

className={`absolute inset-0 w-full h-full transition-all duration-200 ${isFading ? 'opacity-0 scale-105 pointer-events-none' : 'opacity-100 scale-100'}`}


E num useEffect:

useEffect(() => {
  if (isRevealed && rafId.current) {
    cancelAnimationFrame(rafId.current);
    rafId.current = null;
  }
  return () => { if (rafId.current) cancelAnimationFrame(rafId.current); };
}, [isRevealed]);

5) (Opcional, mas recomendado) Mostre â€œLogin para pegarâ€ para guest

Hoje a elegibilidade retorna { eligible: true, guestMode: true } para nÃ£o logados. Renderize um aviso/CTA antes da raspagem para evitar frustraÃ§Ã£o (o back exige login no POST /generate-coupon).

Checklist rÃ¡pido de validaÃ§Ã£o

 Gerar cupom â†’ imediatamente o card muda para â€œRESGATADOâ€ (sem reload).

 Reabrir a lista / navegar entre telas â†’ continua â€œRESGATADOâ€.

 Clicar de novo no card nÃ£o tenta raspar; abre a visualizaÃ§Ã£o do cupom/aviso.

 Endpoint de elegibilidade retorna valores atuais (sem cache).

 rAF e AudioContext param/congelam apÃ³s reveal (sem CPU extra).