Fix de Parser p/ Respostas da IA (produtos)

Stack & vers√£o: Node 18+

A tua IA est√° respondendo com TEXTO + um bloco JSON no meio. Se o teu backend tenta fazer JSON.parse() direto na mensagem inteira, vai quebrar justamente ‚Äúaqui‚Äù:

‚ÄúBoa noite! üòä Como posso ajudar‚Ä¶‚Äù ‚Ä¶ e depois vem o JSON.

A solu√ß√£o: extrair com seguran√ßa o primeiro objeto JSON que comece com {"type":"products" da mensagem, validar o schema e normalizar campos (ex.: imageUrl relativo ‚Üí absoluto, recommendations:null ‚Üí []).

Abaixo te entrego um mini-projeto Replit plug√°vel no teu app. Ele exp√µe uma fun√ß√£o parseAssistantProducts(message, baseUrl?) que:

Encontra o JSON mesmo se houver texto antes/depois.

Faz valida√ß√£o de shape e te diz exatamente onde est√° o erro.

Normaliza:

imageUrl relativo ‚Üí absoluto (usando baseUrl).

focusedProduct/recommendations null ‚Üí valores seguros.

Remove itens sem campos m√≠nimos (id, title, category, priceUSD, storeName).

Retorna { type, products, query, focusedProduct, recommendations }.

√Årvore de diret√≥rios
replit-ia-products-fixer/
‚îú‚îÄ package.json                # Scripts e deps (nenhuma extra)
‚îú‚îÄ index.js                    # Biblioteca + CLI de teste
‚îú‚îÄ parser.js                   # Fun√ß√µes puras de parsing/valida√ß√£o
‚îú‚îÄ sample.txt                  # Mensagem igual √† que voc√™ colou (para teste)
‚îú‚îÄ .replit                     # Comando de execu√ß√£o no Replit
‚îî‚îÄ replit.nix                  # Ambiente Node 18 no Replit

// package.json
{
  "name": "replit-ia-products-fixer",
  "version": "1.0.0",
  "type": "module",
  "description": "Extrai e valida o bloco JSON de produtos da resposta da IA (texto + JSON).",
  "scripts": {
    "start": "node index.js",
    "dev": "node --watch index.js",
    "test": "node index.js --test"
  }
}

# .replit
run = "npm install && npm run start"

# replit.nix
{ pkgs }: {
  deps = [
    pkgs.nodejs-18_x
    pkgs.nodePackages.npm
  ];
}

// sample.txt
Boa noite! üòä Como posso ajudar voc√™ hoje? Tem algo espec√≠fico que est√° procurando ou alguma categoria em mente? Estou aqui para entender suas necessidades e encontrar a melhor solu√ß√£o para voc√™!
quero um iphone
√ìtimo! Vamos encontrar a melhor op√ß√£o de iPhone para voc√™. Aqui est√£o tr√™s sugest√µes que equilibram pre√ßo e qualidade:

1. **iPhone 13 (Modelo Bom)**  
   - **Benef√≠cios**: C√¢mera dupla, √≥timo desempenho com chip A15, e boa dura√ß√£o de bateria.  
{"type":"products","products":[{"id":"bank_8303c62e-d2d3-4e72-8263-7f4fc6aafaea","title":"Apple IPHONE 12 PRO MAX A2411 256GB SILVER CPO","category":"Celulares","priceUSD":450,"premium":false,"storeName":"Atacado Store","storeSlug":"atacado-store","imageUrl":"/uploads/product-banks/images/1758670053905-zp5jh0r1o.jpeg","name":"Apple IPHONE 12 PRO MAX A2411 256GB SILVER CPO"},{"id":"bank_ed505ca0-9ebf-4d41-9eb2-606c060e7ff0","title":"Apple IPHONE 13 128GB STARLIGHT","category":"Celulares","priceUSD":450,"premium":false,"storeName":"Atacado Store","storeSlug":"atacado-store","imageUrl":"/uploads/product-banks/images/1758670054182-0o9jhpaux.jpeg","name":"Apple IPHONE 13 128GB STARLIGHT"},{"id":"store_cell-001","title":"iPhone 15 128GB","category":"Celulares","priceUSD":350,"premium":true,"storeName":"Cell Shop Importados","storeSlug":"cell-shop-importados","imageUrl":"https://cellshop.com/media/catalog/product/3/0/3032732_1_1.jpg","name":"iPhone 15 128GB"},{"id":"bank_f0924973-6bee-4198-9e92-ca82ee2e0f95","title":"Apple IPHONE 13 PRO MAX 128GB GRAPHITE CPO","category":"Celulares","priceUSD":450,"premium":false,"storeName":"Atacado Store","storeSlug":"atacado-store","imageUrl":"/uploads/product-banks/images/1758670054320-bg9w8b8tt.jpeg","name":"Apple IPHONE 13 PRO MAX 128GB GRAPHITE CPO"},{"id":"store_776775aa-ce8c-41d5-b14d-d6203661ca1c","title":"Apple IPHONE 12 PRO MAX A2411 256GB GOLD CPO","category":"Celulares","priceUSD":350,"premium":true,"storeName":"Atacado Store","storeSlug":"atacado-store","imageUrl":"/uploads/product-banks/images/1758670053765-ichhhc2mf.jpeg","name":"Apple IPHONE 12 PRO MAX A2411 256GB GOLD CPO"},{"id":"store_c22c3992-7b1b-49d1-b264-01eae7eca7e5","title":"Apple IPHONE 13 128GB MIDNIGHT","category":"Celulares","priceUSD":350,"premium":true,"storeName":"Atacado Store","storeSlug":"atacado-store","imageUrl":"/uploads/product-banks/images/1758670054045-otigfo1rs.jpeg","name":"Apple IPHONE 13 128GB MIDNIGHT"}],"query":"quero um iphone","focusedProduct":null,"recommendations":null}

// parser.js
/** Utilit√°rios para extrair e validar o JSON de produtos enviado pela IA. */

/** Encontra o primeiro objeto JSON que comece com {"type":"products" ...} */
export function extractProductsJson(message) {
  if (typeof message !== 'string') {
    throw new Error('A mensagem deve ser string.');
  }
  const startIdx = message.indexOf('{"type":"products"');
  if (startIdx === -1) {
    throw new Error('Bloco {"type":"products"...} n√£o encontrado na mensagem.');
  }

  // Varredura balanceada de chaves para achar o fim correto do JSON
  let depth = 0;
  let endIdx = -1;
  for (let i = startIdx; i < message.length; i++) {
    const ch = message[i];
    if (ch === '{') depth++;
    else if (ch === '}') {
      depth--;
      if (depth === 0) {
        endIdx = i;
        break;
      }
    }
  }
  if (endIdx === -1) {
    throw new Error('JSON de produtos parece incompleto (chaves n√£o balanceadas).');
  }
  const jsonSlice = message.slice(startIdx, endIdx + 1);
  return jsonSlice;
}

/** Valida minimally o payload retornado pela IA. */
export function validatePayload(payload) {
  if (!payload || typeof payload !== 'object') throw new Error('Payload inv√°lido.');
  if (payload.type !== 'products') throw new Error('type diferente de "products".');

  if (!Array.isArray(payload.products)) throw new Error('Campo "products" deve ser array.');

  const errors = [];
  const valid = [];
  for (const p of payload.products) {
    const errs = [];
    if (!p || typeof p !== 'object') { errors.push('Item n√£o √© objeto.'); continue; }
    if (!p.id) errs.push('id ausente');
    if (!p.title) errs.push('title ausente');
    if (!p.category) errs.push('category ausente');
    if (typeof p.priceUSD !== 'number') errs.push('priceUSD deve ser number');
    if (!p.storeName) errs.push('storeName ausente');
    if (!p.imageUrl) errs.push('imageUrl ausente');

    if (errs.length) {
      errors.push(`Produto ${p.id || '(sem id)'} com problemas: ${errs.join(', ')}`);
      continue;
    }
    valid.push(p);
  }

  return { errors, valid };
}

/** Normaliza campos e garante valores seguros. */
export function normalizePayload(payload, baseUrl) {
  const out = {
    type: 'products',
    query: String(payload.query || '').trim(),
    products: [],
    focusedProduct: payload.focusedProduct || null,
    recommendations: Array.isArray(payload.recommendations) ? payload.recommendations : []
  };

  // Normalizar URLs relativas
  const absolutize = (url) => {
    try {
      if (!url) return url;
      // se j√° √© absoluta
      if (/^https?:\/\//i.test(url)) return url;
      if (!baseUrl) return url; // sem baseUrl, deixa como veio
      const u = new URL(url, baseUrl);
      return u.href;
    } catch {
      return url;
    }
  };

  out.products = payload.products.map(p => ({
    id: String(p.id),
    title: String(p.title),
    name: p.name ? String(p.name) : String(p.title),
    category: String(p.category),
    priceUSD: Number(p.priceUSD),
    premium: Boolean(p.premium),
    storeName: String(p.storeName),
    storeSlug: p.storeSlug ? String(p.storeSlug) : '',
    imageUrl: absolutize(p.imageUrl)
  }));

  // Se focusedProduct = null mas h√° produtos, define o 1¬∫ como foco (opcional)
  if (!out.focusedProduct && out.products.length > 0) {
    out.focusedProduct = out.products[0];
  }

  return out;
}

/** Pipeline completo: extrai, parseia, valida, normaliza. */
export function parseAssistantProducts(message, baseUrl) {
  const jsonText = extractProductsJson(message);
  let raw;
  try {
    raw = JSON.parse(jsonText);
  } catch (e) {
    // Tenta limpar poss√≠veis lixos (caracteres n√£o imprim√≠veis)
    const cleaned = jsonText.replace(/\u0000/g, '');
    raw = JSON.parse(cleaned);
  }

  const { errors, valid } = validatePayload(raw);
  if (errors.length) {
    // Loga tudo e segue s√≥ com v√°lidos
    console.warn('[parser] Produtos com erro:', errors);
  }
  const safeRaw = { ...raw, products: valid };
  const normalized = normalizePayload(safeRaw, baseUrl);
  return normalized;
}

// index.js
import fs from 'node:fs';
import { parseAssistantProducts } from './parser.js';

/** CLI simples p/ testar no Replit: `npm start` */
function main() {
  const arg = process.argv[2];
  if (arg === '--test') {
    const message = fs.readFileSync('./sample.txt', 'utf8');
    const result = parseAssistantProducts(message, 'https://meudominio.com'); // baseUrl opcional
    console.log('OK ‚úÖ Payload normalizado:\n', JSON.stringify(result, null, 2));
    return;
  }

  // Exemplo de uso program√°tico (simulando integra√ß√£o no teu backend)
  const message = fs.readFileSync('./sample.txt', 'utf8');
  try {
    const payload = parseAssistantProducts(message, 'https://meudominio.com');
    // Aqui voc√™ integraria com o teu fluxo (ex.: render UI, salvar no banco, etc.)
    console.log(`Recebemos ${payload.products.length} produto(s). Primeiro:`, payload.products[0]?.title);
  } catch (e) {
    console.error('Falha ao extrair produtos da resposta da IA:', e.message);
    process.exit(1);
  }
}

main();

Como rodar

Abra no Replit ‚Üí importe esta pasta.

Rode:

npm install
npm run start


Teste dedicado:

npm run test


Voc√™ ver√° o JSON normalizado no console.

Como plugar no teu app

No ponto onde voc√™ recebe a mensagem completa da IA (que hoje vem com texto + JSON):

import { parseAssistantProducts } from './parser.js';

// messageFromLLM = string com a resposta do modelo
const payload = parseAssistantProducts(messageFromLLM, 'https://seu-backend.com');

// payload.products ‚Üí array seguro
// payload.focusedProduct ‚Üí nunca undefined
// payload.recommendations ‚Üí array sempre


Dica: Se o teu fluxo atual fazia JSON.parse(respostaCompleta), troque para usar parseAssistantProducts(respostaCompleta, baseUrl).

Testes

O comando npm run test j√° valida o caso real (teu exemplo).

Voc√™ pode colar novas respostas da IA no sample.txt e repetir.

Notas/Recomenda√ß√µes

Causa prov√°vel do erro: tentativa de JSON.parse() na mensagem inteira (com texto ‚ÄúBoa noite! ‚Ä¶‚Äù), ou schema n√£o padronizado (ex.: recommendations:null).

Boas pr√°ticas p/ o modelo:

Se poss√≠vel, force o modelo a responder somente o bloco JSON (modo function/tool call).

Caso queira manter o texto, sempre envolva o JSON com um marcador claro (ex.: <!--BEGIN_PRODUCTS--> { ... } <!--END_PRODUCTS-->). O nosso parser j√° resolve sem marcador, mas marcadores deixam mais robusto.

URLs relativas: teu payload traz /uploads/... ‚Äì passe baseUrl no parser para gerar URL absoluta.

Higiene de dados: o parser descarta produtos sem campos m√≠nimos e loga mensagens de qual item falhou.