# Implementação Vertex AI - Nano Banana
# Baseado no exemplo fornecido pelo usuário

## Características da Implementação Vertex AI:

### 1. Dependências necessárias:
- express
- node-fetch  
- google-auth-library

### 2. Configuração:
- PROJECT_ID (do Google Cloud)
- LOCATION = "us-central1" 
- MODEL = "gemini-2.5-flash-image" (nome no Vertex AI)
- Autenticação via GoogleAuth com escopo cloud-platform

### 3. Código completo:

```javascript
// server.js
import express from "express";
import fetch from "node-fetch";
import { GoogleAuth } from "google-auth-library";

const app = express();
app.use(express.json());

const PROJECT_ID = process.env.GCLOUD_PROJECT || "SEU_PROJECT_ID";
const LOCATION = "us-central1";
// Modelos disponíveis no Studio (escolha o seu):
// const MODEL = "imagen-4.0-generate-001"; // Imagen 4
const MODEL = "gemini-2.5-flash-image"; // Nano Banana no Vertex AI

const auth = new GoogleAuth({
  scopes: "https://www.googleapis.com/auth/cloud-platform",
});

app.post("/api/gerar-imagem", async (req, res) => {
  try {
    const { prompt } = req.body;
    const client = await auth.getClient();
    const token = await client.getAccessToken();

    const url =
      `https://${LOCATION}-aiplatform.googleapis.com/v1/projects/${PROJECT_ID}` +
      `/locations/${LOCATION}/publishers/google/models/${MODEL}:generateContent`;

    const body = {
      contents: [
        { role: "user", parts: [{ text: prompt }] }
      ],
      // opcional: repetir resultado
      generationConfig: { seed: 123 }, 
    };

    const r = await fetch(url, {
      method: "POST",
      headers: {
        "Authorization": `Bearer ${token.token || token}`,
        "Content-Type": "application/json",
      },
      body: JSON.stringify(body),
    });

    if (!r.ok) {
      const errTxt = await r.text();
      return res.status(r.status).send(errTxt); // 429 -> bateu quota/rajada
    }

    const json = await r.json();
    const parts = json?.candidates?.[0]?.content?.parts || [];
    const imgPart = parts.find(p => p.inlineData && p.inlineData.mimeType?.startsWith("image/"));
    if (!imgPart) return res.status(500).send("Sem imagem no retorno.");

    const b64 = imgPart.inlineData.data;
    const buf = Buffer.from(b64, "base64");
    res.setHeader("Content-Type", imgPart.inlineData.mimeType || "image/png");
    return res.send(buf);
  } catch (e) {
    console.error(e);
    res.status(500).send(String(e));
  }
});

app.listen(3000, () => console.log("API rodando em http://localhost:3000"));
```

## Vantagens da Implementação Vertex AI:

### 1. **Controle Total da API REST**
- Requisições HTTP diretas
- Melhor controle de erros HTTP (429, 500, etc.)
- Headers customizáveis
- Timeouts configuráveis

### 2. **Autenticação Robusta**
- google-auth-library com renovação automática de tokens
- Escopo cloud-platform completo
- Suporte nativo a contas de serviço

### 3. **Tratamento de Erros Melhorado**
- Códigos HTTP específicos (429 para quota)
- Mensagens de erro detalhadas
- Retry strategies mais fáceis de implementar

### 4. **Performance**
- Menos overhead de SDKs
- Controle direto da requisição
- Menor footprint de dependências

### 5. **Configuração de Geração**
- generationConfig com seed para resultados reproduzíveis
- Parâmetros avançados disponíveis
- Controle fino sobre o modelo

## Diferenças da Nossa Implementação Atual:

### Nossa implementação (@google/genai):
```javascript
const response = await ai.models.generateContent({
    model: "gemini-2.5-flash-image-preview",
    contents: [
        { role: "user", parts: [{ text: prompt }] }
    ]
});
```

### Vertex AI (REST):
```javascript
const body = {
  contents: [
    { role: "user", parts: [{ text: prompt }] }
  ],
  generationConfig: { seed: 123 }
};

const response = await fetch(url, {
  method: "POST",
  headers: {
    "Authorization": `Bearer ${token}`,
    "Content-Type": "application/json",
  },
  body: JSON.stringify(body),
});
```

## Considerações para Migração:

### 1. **Configuração Necessária:**
- Definir PROJECT_ID do Google Cloud
- Configurar autenticação (conta de serviço ou ADC)
- Instalar google-auth-library

### 2. **Mudanças no Código:**
- Substituir @google/genai por fetch + google-auth-library
- Adaptar tratamento de respostas
- Implementar renovação de tokens

### 3. **Benefícios Esperados:**
- Melhor controle de quotas e rate limiting
- Tratamento de erros mais granular
- Maior estabilidade em produção
- Suporte oficial do Google Cloud

### 4. **Modelo Correto:**
- Verificar se é "gemini-2.5-flash-image" ou "gemini-2.5-flash-image-preview"
- Confirmar disponibilidade na região us-central1

## Próximos Passos Sugeridos:

1. Testar modelo disponível no Google AI Studio
2. Configurar PROJECT_ID no environment
3. Implementar versão híbrida (fallback)
4. Migrar gradualmente para Vertex AI
5. Implementar retry logic robusto

## Observações de Segurança:

- NUNCA expor chaves de API no frontend
- Usar conta de serviço no servidor
- Implementar rate limiting no backend
- Validar inputs do usuário
- Logs seguros (sem exposição de tokens)