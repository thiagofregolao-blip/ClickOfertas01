# C√ìDIGO COMPLETO: SISTEMA RASPADINHA CLONE VIRTUAL
# ===================================================

## 1. FRONTEND - COMPONENTE SCRATCH CARD (client/src/components/scratch-card.tsx)

```typescript
import { useState, useRef, useEffect } from "react";
import { Card, CardContent } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Clock, Gift, Sparkles, Download, Share2, QrCode, CheckCircle } from "lucide-react";
import { 
  Dialog, 
  DialogContent, 
  DialogHeader, 
  DialogTitle 
} from "@/components/ui/dialog";
import type { Product } from "@shared/schema";
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import { apiRequest } from "@/lib/queryClient";
import { formatBrazilianPrice, formatPriceWithCurrency } from "@/lib/priceUtils";
import jsPDF from "jspdf";
import { useToast } from "@/hooks/use-toast";

interface ScratchCardProps {
  product: Product;
  currency: string;
  themeColor: string;
  onRevealed?: (product: Product) => void;
  onClick?: (product: Product) => void;
  isVirtualClone?: boolean;
  virtualCloneId?: string;
}

interface ScratchArea {
  x: number;
  y: number;
  radius: number;
}

export default function ScratchCard({ 
  product, 
  currency, 
  themeColor, 
  onRevealed, 
  onClick, 
  isVirtualClone = false, 
  virtualCloneId 
}: ScratchCardProps) {
  
  // üîç DEBUG LOGS
  console.log('üéØ ScratchCard renderizado:', {
    productId: product.id,
    productName: product.name,
    isScratchCard: product.isScratchCard,
    isVirtualClone,
    virtualCloneId,
    scratchPrice: product.scratchPrice
  });

  // Estados do componente
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const [isScratching, setIsScratching] = useState(false);
  const [scratchProgress, setScratchProgress] = useState(0);
  const [isRevealed, setIsRevealed] = useState(false);
  const [isFading, setIsFading] = useState(false);
  const [timeLeft, setTimeLeft] = useState<number | null>(null);
  const [showModal, setShowModal] = useState(false);
  const [coupon, setCoupon] = useState<any>(null);
  const [couponGenerated, setCouponGenerated] = useState(false);
  const [showCouponModal, setShowCouponModal] = useState(false);
  const scratchedAreas = useRef<ScratchArea[]>([]);
  const { toast } = useToast();
  const queryClient = useQueryClient();
  
  // Refs para performance
  const audioCtxRef = useRef<AudioContext | null>(null);
  const lastSoundTime = useRef<number>(0);
  const SOUND_COOLDOWN = 120; // ms
  const rafId = useRef<number | null>(null);
  const needsProgressCalc = useRef<boolean>(false);
  const lastPoint = useRef<{ x: number; y: number } | null>(null);

  // QUERY: Verificar clone virtual dispon√≠vel
  const { data: virtualClone, isLoading: loadingClone } = useQuery({
    queryKey: ['virtual-clone', product.id],
    queryFn: async () => {
      console.log('üîç Buscando clone virtual para produto:', product.id);
      const response = await fetch(`/api/virtual-clones/${product.id}/user`, { 
        credentials: 'include' 
      });
      if (!response.ok) {
        console.log('‚ùå Erro ao buscar clone virtual:', response.status);
        if (response.status === 401) return { hasClone: false, clone: null };
        throw new Error('Falha ao carregar clone virtual');
      }
      const result = await response.json();
      console.log('‚úÖ Clone virtual encontrado:', result);
      return result as { hasClone: boolean; clone?: any };
    },
    staleTime: 60_000, // Cache por 1 minuto
    enabled: !isVirtualClone, // S√≥ busca se N√ÉO for j√° um clone virtual
  });

  // MUTATION: Raspar clone virtual
  const scratchVirtualCloneMutation = useMutation({
    mutationFn: async (cloneId: string) => {
      const response = await fetch(`/api/virtual-clones/${cloneId}/scratch`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        credentials: 'include',
      });
      
      if (!response.ok) {
        const error = await response.text();
        throw new Error(`${response.status}: ${error}`);
      }
      
      return await response.json();
    },
    onSuccess: (data: any) => {
      setIsRevealed(true);
      
      // Invalidar caches para refletir mudan√ßas
      queryClient.invalidateQueries({ queryKey: ['virtual-clone', product.id] });
      queryClient.invalidateQueries({ queryKey: ['coupons'] });
      if (onRevealed) onRevealed(product);
      
      // Mostrar cupom diretamente (clone virtual j√° gera cupom automaticamente)
      if (data?.success && data?.coupon) {
        setCoupon(data.coupon);
        setCouponGenerated(true);
        setShowCouponModal(true);
        
        toast({
          title: "üéâ Clone virtual raspado!",
          description: "Seu cupom foi gerado automaticamente!",
          duration: 3000,
        });
      }
    },
    onError: (error: any) => {
      setIsFading(false);
      toast({
        title: 'N√£o foi poss√≠vel raspar o clone',
        description: String(error?.message || 'Tente novamente.'),
        variant: 'destructive',
      });
    }
  });

  // EFEITO: Sincronizar com dados do clone
  useEffect(() => {
    if (virtualClone?.hasClone && virtualClone?.clone) {
      const clone = virtualClone.clone;
      setIsRevealed(clone.isUsed);
      
      if (clone.expiresAt) {
        const expirationTime = new Date(clone.expiresAt).getTime();
        const now = Date.now();
        setTimeLeft(Math.max(0, Math.floor((expirationTime - now) / 1000)));
      }
    } else {
      // Produto sem clone virtual = estado inicial limpo
      setIsRevealed(false);
      setTimeLeft(null);
      setCoupon(null);
      setCouponGenerated(false);
    }
  }, [virtualClone]);

  // FUN√á√ÉO: Verificar se est√° bloqueado
  const blocked = () => {
    const isBlocked = isRevealed || loadingClone;
    console.log('üîí Verificando se est√° bloqueado:', { isRevealed, loadingClone, isBlocked });
    return isBlocked;
  };

  // RENDER: Interface do cart√£o de raspagem
  return (
    <div 
      className="relative isolate z-10 bg-gradient-to-br from-yellow-100 to-orange-100 border-2 border-yellow-400 overflow-hidden group text-center flex flex-col min-h-[200px] sm:min-h-[220px] cursor-pointer select-none"
      onClick={() => {
        if (onClick && !blocked()) {
          onClick(product);
        }
      }}
    >
      <div className="p-0 relative h-full w-full overflow-hidden">
        
        {/* CONTE√öDO DO PRODUTO (sempre vis√≠vel no fundo) */}
        <div className="absolute inset-0 p-3 flex flex-col justify-center items-center bg-white">
          {/* Imagem */}
          <div className="relative mb-2">
            {product.imageUrl ? (
              <img
                src={product.imageUrl}
                alt={product.name}
                className="w-16 h-16 md:w-20 md:h-20 object-cover rounded opacity-30"
              />
            ) : (
              <div className="w-16 h-16 md:w-20 md:h-20 bg-gray-100 flex items-center justify-center rounded opacity-30">
                <div className="w-6 h-6 bg-gray-300 rounded opacity-50"></div>
              </div>
            )}
          </div>
          
          {/* Nome */}
          <h3 className="text-xs sm:text-sm font-bold text-gray-600 text-center opacity-40 line-clamp-2 mb-2">
            {product.name}
          </h3>
          
          {/* Pre√ßo de oferta */}
          <div className="text-lg font-bold text-red-600 opacity-40">
            {formatPriceWithCurrency(product.scratchPrice || '0', currency)}
          </div>
        </div>

        {/* COBERTURA DE RASPAGEM (PROBLEMA ATUAL - N√ÉO APARECE) */}
        {/* DEBUG: Verificar condi√ß√µes */}
        {console.log('üîç CONDI√á√ïES RASPAGEM:', {
          isVirtualClone,
          virtualCloneId,
          product,
          shouldRenderCover: isVirtualClone && virtualCloneId
        })}
        
        {/* TESTE: Cobertura SEMPRE vis√≠vel para clones virtuais */}
        {isVirtualClone && virtualCloneId && (
          <>
            {console.log('‚úÖ RENDERIZANDO COBERTURA PARA CLONE:', virtualCloneId)}
            <div
              className="absolute top-0 left-0 w-full h-full cursor-pointer"
              style={{
                zIndex: 100,
                backgroundColor: '#ff0000', // VERMELHO para debug
                border: '5px solid #00ff00', // VERDE para debug
                opacity: 0.8
              }}
              onClick={(e) => {
                console.log('üé® CLIQUE NA COBERTURA VERMELHA!', { isVirtualClone, virtualCloneId });
                
                // Esconder cobertura imediatamente
                e.currentTarget.style.display = 'none';
                
                // Disparar raspagem
                if (virtualCloneId) {
                  scratchVirtualCloneMutation.mutate(virtualCloneId);
                }
              }}
            />
            
            {/* Texto DEBUG */}
            <div 
              className="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 pointer-events-none"
              style={{ 
                zIndex: 200,
                color: '#ffffff',
                fontWeight: 'bold',
                fontSize: '16px',
                textShadow: '2px 2px 4px rgba(0,0,0,1)',
                backgroundColor: 'rgba(0,0,0,0.8)',
                padding: '5px 10px',
                borderRadius: '5px'
              }}
            >
              üé≤ CLIQUE AQUI DEBUG
            </div>
          </>
        )}

      </div>
    </div>
  );
}
```

## 2. BACKEND - API ROUTES (server/routes.ts - SE√á√ÉO CLONES VIRTUAIS)

```typescript
// ========================================
// SISTEMA DE CLONES VIRTUAIS - RASPADINHA
// ========================================

// 1. Listar clones virtuais do usu√°rio
app.get('/api/virtual-clones/user', isAuthenticated, async (req: any, res) => {
  try {
    const userId = req.user?.claims?.sub || req.user?.id;

    if (!userId) {
      return res.status(401).json({ message: "Usu√°rio n√£o autenticado" });
    }

    const clones = await storage.getUserVirtualClones(userId);

    res.json({
      clones
    });
  } catch (error) {
    console.error("Error fetching user virtual clones:", error);
    res.status(500).json({ message: "Erro ao buscar clones virtuais" });
  }
});

// 2. Verificar se usu√°rio tem clone dispon√≠vel para um produto espec√≠fico
app.get('/api/virtual-clones/:productId/user', isAuthenticated, async (req: any, res) => {
  try {
    const { productId } = req.params;
    const userId = req.user?.claims?.sub || req.user?.id;

    if (!userId) {
      return res.status(401).json({ message: "Usu√°rio n√£o autenticado" });
    }

    const clone = await storage.getUserAvailableClone(userId, productId);

    if (!clone) {
      return res.json({ hasClone: false, clone: null });
    }

    res.json({
      hasClone: true,
      clone
    });
  } catch (error) {
    console.error("Error fetching user clone:", error);
    res.status(500).json({ message: "Erro ao buscar clone do usu√°rio" });
  }
});

// 3. RASPAR CLONE VIRTUAL (ENDPOINT PRINCIPAL)
app.post('/api/virtual-clones/:cloneId/scratch', isAuthenticated, async (req: any, res) => {
  try {
    const { cloneId } = req.params;
    const userId = req.user?.claims?.sub || req.user?.id;

    if (!userId) {
      return res.status(401).json({ message: "Usu√°rio n√£o autenticado" });
    }

    // Buscar clone pelo ID diretamente
    const clone = await storage.getVirtualCloneById(cloneId);
    if (!clone) {
      return res.status(404).json({ message: "Clone n√£o encontrado" });
    }

    // Verificar se o clone pertence ao usu√°rio
    if (clone.assignedUserId !== userId) {
      return res.status(403).json({ message: "Clone n√£o pertence ao usu√°rio" });
    }

    if (clone.isUsed || clone.isExpired) {
      return res.status(400).json({ message: "Clone j√° foi usado ou expirou" });
    }

    // Marcar clone como usado
    await storage.markCloneAsUsed(cloneId);

    // Criar cupom baseado no clone
    const couponCode = `CLONE${Date.now()}${Math.random().toString(36).substr(2, 4).toUpperCase()}`;
    const expiresAt = new Date();
    expiresAt.setDate(expiresAt.getDate() + 7); // Cupom expira em 7 dias

    // Gerar QR Code
    const qrCodeData = JSON.stringify({
      code: couponCode,
      productId: clone.productId,
      storeId: clone.storeId,
      originalPrice: clone.originalPrice,
      discountPrice: clone.discountPrice,
      type: 'virtual_clone'
    });
    const qrCodeBase64 = await QRCode.toDataURL(qrCodeData);

    const couponData = {
      cloneId: cloneId,
      productId: clone.productId,
      storeId: clone.storeId,
      userId: userId,
      userAgent: req.get('User-Agent') || 'unknown',
      ipAddress: req.ip || 'unknown',
      couponCode,
      originalPrice: clone.originalPrice.toString(),
      discountPrice: clone.discountPrice.toString(),
      discountPercentage: clone.campaign?.discountPercentage || "0",
      qrCode: qrCodeBase64,
      expiresAt,
      isRedeemed: false
    };

    const coupon = await storage.createCoupon(couponData);

    res.json({
      success: true,
      coupon: {
        id: coupon.id,
        couponCode: coupon.couponCode,
        discountPercentage: clone.campaign?.discountPercentage || "0",
        originalPrice: clone.originalPrice,
        discountPrice: clone.discountPrice,
        qrCode: qrCodeBase64,
        expiresAt: coupon.expiresAt
      }
    });
  } catch (error) {
    console.error("Error scratching virtual clone:", error);
    res.status(500).json({ message: "Erro ao raspar clone virtual" });
  }
});
```

## 3. BACKEND - STORAGE (server/storage.ts - M√âTODOS CLONES VIRTUAIS)

```typescript
// M√âTODOS DE CLONES VIRTUAIS

// Buscar todos os clones virtuais do usu√°rio
async getUserVirtualClones(userId: string): Promise<VirtualScratchCloneWithDetails[]> {
  const clones = await db
    .select({
      id: virtualScratchClones.id,
      campaignId: virtualScratchClones.campaignId,
      productId: virtualScratchClones.productId,
      storeId: virtualScratchClones.storeId,
      assignedUserId: virtualScratchClones.assignedUserId,
      productName: virtualScratchClones.productName,
      productDescription: virtualScratchClones.productDescription,
      originalPrice: virtualScratchClones.originalPrice,
      discountPrice: virtualScratchClones.discountPrice,
      productImageUrl: virtualScratchClones.productImageUrl,
      productCategory: virtualScratchClones.productCategory,
      isUsed: virtualScratchClones.isUsed,
      isExpired: virtualScratchClones.isExpired,
      notificationSent: virtualScratchClones.notificationSent,
      usedAt: virtualScratchClones.usedAt,
      expiresAt: virtualScratchClones.expiresAt,
      createdAt: virtualScratchClones.createdAt,
      campaign: {
        id: scratchCampaigns.id,
        title: scratchCampaigns.title,
        description: scratchCampaigns.description,
        discountPercentage: scratchCampaigns.discountPercentage,
      },
      product: {
        id: products.id,
        name: products.name,
        description: products.description,
        price: products.price,
        imageUrl: products.imageUrl,
        category: products.category,
      },
      store: {
        id: stores.id,
        name: stores.name,
        logoUrl: stores.logoUrl,
        themeColor: stores.themeColor,
        currency: stores.currency,
        whatsapp: stores.whatsapp,
        slug: stores.slug,
      },
    })
    .from(virtualScratchClones)
    .leftJoin(scratchCampaigns, eq(virtualScratchClones.campaignId, scratchCampaigns.id))
    .leftJoin(products, eq(virtualScratchClones.productId, products.id))
    .leftJoin(stores, eq(virtualScratchClones.storeId, stores.id))
    .where(and(
      eq(virtualScratchClones.assignedUserId, userId),
      eq(virtualScratchClones.isUsed, false),
      eq(virtualScratchClones.isExpired, false),
      gte(virtualScratchClones.expiresAt, new Date())
    ))
    .orderBy(virtualScratchClones.createdAt);

  return clones as VirtualScratchCloneWithDetails[];
}

// Buscar clone virtual por ID
async getVirtualCloneById(cloneId: string): Promise<VirtualScratchCloneWithDetails | undefined> {
  const [clone] = await db
    .select({
      id: virtualScratchClones.id,
      campaignId: virtualScratchClones.campaignId,
      productId: virtualScratchClones.productId,
      storeId: virtualScratchClones.storeId,
      assignedUserId: virtualScratchClones.assignedUserId,
      productName: virtualScratchClones.productName,
      productDescription: virtualScratchClones.productDescription,
      originalPrice: virtualScratchClones.originalPrice,
      discountPrice: virtualScratchClones.discountPrice,
      productImageUrl: virtualScratchClones.productImageUrl,
      productCategory: virtualScratchClones.productCategory,
      isUsed: virtualScratchClones.isUsed,
      isExpired: virtualScratchClones.isExpired,
      notificationSent: virtualScratchClones.notificationSent,
      usedAt: virtualScratchClones.usedAt,
      expiresAt: virtualScratchClones.expiresAt,
      createdAt: virtualScratchClones.createdAt,
      campaign: {
        id: scratchCampaigns.id,
        title: scratchCampaigns.title,
        description: scratchCampaigns.description,
        discountPercentage: scratchCampaigns.discountPercentage,
      },
      product: {
        id: products.id,
        name: products.name,
        description: products.description,
        price: products.price,
        imageUrl: products.imageUrl,
        category: products.category,
      },
      store: {
        id: stores.id,
        name: stores.name,
        logoUrl: stores.logoUrl,
        themeColor: stores.themeColor,
        currency: stores.currency,
        whatsapp: stores.whatsapp,
        slug: stores.slug,
      },
    })
    .from(virtualScratchClones)
    .leftJoin(scratchCampaigns, eq(virtualScratchClones.campaignId, scratchCampaigns.id))
    .leftJoin(products, eq(virtualScratchClones.productId, products.id))
    .leftJoin(stores, eq(virtualScratchClones.storeId, stores.id))
    .where(eq(virtualScratchClones.id, cloneId));

  return clone as VirtualScratchCloneWithDetails | undefined;
}

// Buscar clone dispon√≠vel do usu√°rio para um produto espec√≠fico
async getUserAvailableClone(userId: string, productId: string): Promise<VirtualScratchCloneWithDetails | undefined> {
  const [clone] = await db
    .select({
      id: virtualScratchClones.id,
      campaignId: virtualScratchClones.campaignId,
      productId: virtualScratchClones.productId,
      storeId: virtualScratchClones.storeId,
      assignedUserId: virtualScratchClones.assignedUserId,
      productName: virtualScratchClones.productName,
      productDescription: virtualScratchClones.productDescription,
      originalPrice: virtualScratchClones.originalPrice,
      discountPrice: virtualScratchClones.discountPrice,
      productImageUrl: virtualScratchClones.productImageUrl,
      productCategory: virtualScratchClones.productCategory,
      isUsed: virtualScratchClones.isUsed,
      isExpired: virtualScratchClones.isExpired,
      notificationSent: virtualScratchClones.notificationSent,
      usedAt: virtualScratchClones.usedAt,
      expiresAt: virtualScratchClones.expiresAt,
      createdAt: virtualScratchClones.createdAt,
      campaign: {
        id: scratchCampaigns.id,
        title: scratchCampaigns.title,
        description: scratchCampaigns.description,
        discountPercentage: scratchCampaigns.discountPercentage,
      },
      product: {
        id: products.id,
        name: products.name,
        description: products.description,
        price: products.price,
        imageUrl: products.imageUrl,
        category: products.category,
      },
      store: {
        id: stores.id,
        name: stores.name,
        logoUrl: stores.logoUrl,
        themeColor: stores.themeColor,
        currency: stores.currency,
        whatsapp: stores.whatsapp,
        slug: stores.slug,
      },
    })
    .from(virtualScratchClones)
    .leftJoin(scratchCampaigns, eq(virtualScratchClones.campaignId, scratchCampaigns.id))
    .leftJoin(products, eq(virtualScratchClones.productId, products.id))
    .leftJoin(stores, eq(virtualScratchClones.storeId, stores.id))
    .where(and(
      eq(virtualScratchClones.assignedUserId, userId),
      eq(virtualScratchClones.productId, productId),
      eq(virtualScratchClones.isUsed, false),
      eq(virtualScratchClones.isExpired, false),
      gte(virtualScratchClones.expiresAt, new Date())
    ))
    .orderBy(desc(virtualScratchClones.createdAt));

  return clone as VirtualScratchCloneWithDetails | undefined;
}

// Marcar clone como usado
async markCloneAsUsed(cloneId: string): Promise<void> {
  await db
    .update(virtualScratchClones)
    .set({
      isUsed: true,
      usedAt: new Date(),
    })
    .where(eq(virtualScratchClones.id, cloneId));
}
```

## 4. SCHEMA - TABELAS DO BANCO (shared/schema.ts - SE√á√ÉO CLONES VIRTUAIS)

```typescript
// Tabela de campanhas de raspadinha
export const scratchCampaigns = pgTable("scratch_campaigns", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  storeId: varchar("store_id").notNull().references(() => stores.id, { onDelete: "cascade" }),
  productId: varchar("product_id").notNull().references(() => products.id, { onDelete: "cascade" }),
  title: varchar("title").notNull(),
  description: text("description"),
  discountPercentage: varchar("discount_percentage").notNull(), // Ex: "30"
  isActive: boolean("is_active").notNull().default(true),
  totalClones: integer("total_clones").notNull().default(100), // Quantos clones criar
  clonesGenerated: integer("clones_generated").notNull().default(0), // Quantos j√° foram criados
  expiresAt: timestamp("expires_at").notNull(), // Quando a campanha expira
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});

// Tabela de clones virtuais individuais
export const virtualScratchClones = pgTable("virtual_scratch_clones", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  campaignId: varchar("campaign_id").notNull().references(() => scratchCampaigns.id, { onDelete: "cascade" }),
  productId: varchar("product_id").notNull().references(() => products.id, { onDelete: "cascade" }),
  storeId: varchar("store_id").notNull().references(() => stores.id, { onDelete: "cascade" }),
  assignedUserId: varchar("assigned_user_id"), // ID do usu√°rio que ganhou o clone (pode ser null se n√£o foi distribu√≠do)
  
  // Dados do produto no momento da cria√ß√£o (para hist√≥rico)
  productName: varchar("product_name").notNull(),
  productDescription: text("product_description"),
  originalPrice: decimal("original_price", { precision: 10, scale: 2 }).notNull(),
  discountPrice: decimal("discount_price", { precision: 10, scale: 2 }).notNull(),
  productImageUrl: varchar("product_image_url"),
  productCategory: varchar("product_category"),
  
  // Estados do clone
  isUsed: boolean("is_used").notNull().default(false),
  isExpired: boolean("is_expired").notNull().default(false),
  notificationSent: boolean("notification_sent").notNull().default(false),
  
  // Timestamps
  usedAt: timestamp("used_at"),
  expiresAt: timestamp("expires_at").notNull(), // Individual expiration
  createdAt: timestamp("created_at").defaultNow(),
});

// Tipos TypeScript derivados
export type ScratchCampaign = typeof scratchCampaigns.$inferSelect;
export type InsertScratchCampaign = typeof scratchCampaigns.$inferInsert;
export type VirtualScratchClone = typeof virtualScratchClones.$inferSelect;
export type InsertVirtualScratchClone = typeof virtualScratchClones.$inferInsert;

// Tipo com dados relacionados para frontend
export interface VirtualScratchCloneWithDetails extends VirtualScratchClone {
  campaign?: ScratchCampaign;
  product?: Product;
  store?: Store;
}
```

## 5. PROBLEMA ATUAL IDENTIFICADO

**PROBLEMA:** A cobertura de raspagem n√£o aparece visualmente.

**CAUSA RAIZ:** Conflito de CSS layering
- Elemento cobertura: `position: absolute, z-index: 100`
- Elemento conte√∫do: `position: absolute, background: white` (mesmo n√≠vel)
- O conte√∫do aparece DEPOIS no DOM, ent√£o sobrep√µe a cobertura

**SOLU√á√ÉO:** Mover a cobertura para DEPOIS do conte√∫do no DOM ou aumentar z-index para 9999+

**STATUS:**
- ‚úÖ Backend 100% funcional (APIs, banco, autentica√ß√£o)
- ‚úÖ Frontend l√≥gica correta (logs confirmam renderiza√ß√£o)
- ‚ùå Frontend CSS layering (cobertura n√£o vis√≠vel)

**PR√ìXIMO PASSO:** Corrigir posicionamento CSS da cobertura de raspagem.