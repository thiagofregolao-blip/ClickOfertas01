// =============================================
// C√ìDIGO COMPLETO DA BARRA GEMINI ASSISTANT
// =============================================
// Arquivo: server/routes.ts
// Rota: POST /api/assistant/gemini/stream
// Descri√ß√£o: Assistente Gemini com comportamento "show-then-ask"

// POST /api/assistant/gemini/stream - Gemini Assistant with "show-then-ask" behavior
app.post('/api/assistant/gemini/stream', async (req: any, res) => {
  const { message, sessionId } = req.body;
  const user = req.user || req.session?.user;

  if (!message || !sessionId) {
    return res.status(400).json({ error: 'Message and sessionId required' });
  }

  // Configura√ß√£o SSE
  res.setHeader('Content-Type', 'text/event-stream; charset=utf-8');
  res.setHeader('Cache-Control', 'no-cache, no-transform');
  res.setHeader('Connection', 'keep-alive');
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.flushHeaders?.();

  const send = (event: string, payload: any) => {
    res.write(`event: ${event}\n`);
    res.write(`data: ${JSON.stringify(payload)}\n\n`);
  };

  // Persist√™ncia
  try {
    let session = await storage.getAssistantSession(sessionId);
    if (!session) {
      session = await storage.createAssistantSession({
        id: sessionId,
        userId: user?.id || null,
        metadata: { createdAt: new Date().toISOString(), provider: 'gemini' },
      });
    }
    
    await storage.createAssistantMessage({ 
      sessionId, 
      role: 'user', 
      content: message, 
      metadata: { timestamp: new Date().toISOString(), provider: 'gemini' } 
    });
  } catch (error) {
    console.warn('Erro ao salvar mensagem Gemini:', error);
  }

  // Tool: buscarOfertas (reutilizar a mesma fun√ß√£o)
  async function buscarOfertas(args: { query: string; maxResultados?: number; }) {
    const { query, maxResultados = 12 } = args || {};
    
    const q = String(query || "").toLowerCase().trim();
    if (!q) return [];
    
    try {
      const { searchSuggestions } = await import('./lib/tools.js');
      const searchResult = await searchSuggestions(q);
      
      let products = searchResult.products || [];
      
      // Ranking simples por pre√ßo
      products.sort((a: any, b: any) => (a.price?.USD || 0) - (b.price?.USD || 0));
      const sorted = products.slice(0, Math.max(1, Math.min(50, maxResultados)));
      
      if (sorted.length > 0) {
        send('products', {
          products: sorted.map((p: any) => ({ ...p, name: p.title })),
          query,
          hardGrounding: true,
          provider: 'gemini'
        });
      }
      
      return sorted;
    } catch (error) {
      console.error('Erro na busca Gemini:', error);
      return [];
    }
  }

  // =============== MENSAGENS EXATAS GEMINI (templates) =================

  // 1) Quando a consulta √© gen√©rica (ex.: "iphone", "perfumes", "drone")
  function msgGenericFoundGemini(segmento: string) {
    return `Boa! Separei alguns ${segmento} que est√£o valendo a pena. Quer focar em algum modelo espec√≠fico? üòâ`;
  }

  // 2) Quando encontrou itens espec√≠ficos (ex.: "iphone 13")
  function msgSpecificFoundGemini() {
    return "Achei op√ß√µes e deixei nos resultados abaixo. Quer que eu refine por armazenamento/cor?";
  }

  // 3) Quando n√£o encontrou nada
  function msgNoResultsGemini(originalQuery?: string) {
    if (originalQuery && /\b(modelo|vers√£o|linha)\s*\d+\b/i.test(originalQuery)) {
      return "N√£o achei esse modelo espec√≠fico. Que tal tentar 'iphone 13' ou 'samsung s24'? üôÇ";
    }
    return "N√£o achei itens com esse termo. Me diga o modelo exato para eu buscar certinho üôÇ";
  }

  // 4) Pergunta leve (m√°x 1) depois de mostrar ‚Äì opcional
  function msgSoftQuestionGemini(tema: string) {
    return `Prefere ${tema}? Posso ajustar os resultados.`;
  }

  // 5) Sanitiza√ß√£o de qualquer texto do modelo (garantia dupla no chat)
  function sanitizeChatGemini(text = "") {
    return String(text)
      .replace(/!\[[^\]]*\]\([^)]+\)/g, "")        // imagens
      .replace(/\[([^\]]+)\]\(([^)]+)\)/g, "$1")   // links ‚Üí s√≥ texto
      .replace(/https?:\/\/\S+/g, "")             // URLs cruas
      .replace(/\s{2,}/g, " ")
      .trim();
  }

  // 6) Dedu√ß√µes simples para frase gen√©rica
  function segmentoDaQueryGemini(query: string, ofertas: any[] = []) {
    const q = (query || "").toLowerCase();
    const marcas = new Set(ofertas.map(o => (o.marca || "").toLowerCase()));
    const tem = (s: string) => q.includes(s) || [...marcas].some(m => m.includes(s));
    if (tem("iphone") || tem("apple")) return "aparelhos da Apple";
    if (tem("samsung") || tem("galaxy")) return "aparelhos Samsung";
    if (tem("drone")) return "drones";
    if (tem("perfume")) return "perfumes";
    return "esses produtos";
  }

  send('meta', { ok: true, provider: 'gemini' });

  try {
    let userQuery = String(message || "").trim();

    // 1) CONTEXTO INTELIGENTE: Enriquecer query vaga com hist√≥rico
    let finalQuery = userQuery;
    
    // Detectar queries vagas com modelo/n√∫mero (regex robusta do arquiteto)
    const vagueModelMatch = userQuery.match(/(quero|procuro|tem|modelo|vers[√£a]o|o|a|esse|este)?\s*(?:modelo|vers[√£a]o)?\s*(\d{1,3})(?:\s*(pro\s*max|pro\s*|max|plus|mini|se|promax))?/i);
    const numericOnlyMatch = userQuery.match(/^\d{1,3}(?:\s*(pro\s*max|pro|max|plus|mini|se))?$/i);
    
    const needsContext = (vagueModelMatch || numericOnlyMatch) && !/\b(iphone|samsung|xiaomi|apple|perfume|drone|celular|smartphone)\b/i.test(userQuery);
    
    if (needsContext) {
      try {
        const messages = await storage.getAssistantMessages(sessionId);
        // Buscar nas √∫ltimas 10 mensagens do usu√°rio por contexto de marca
        const recentUserMessages = messages
          .filter(m => m.role === 'user')
          .slice(-10)
          .reverse();
        
        const contextMatch = recentUserMessages.find(m => 
          /\b(iphone|apple|samsung|galaxy|xiaomi|perfume|drone|celular|smartphone)\b/i.test(m.content)
        );
        
        if (contextMatch) {
          const anchor = contextMatch.content.match(/\b(iphone|apple|samsung|galaxy|xiaomi|perfume|drone|celular|smartphone)\b/i)?.[0];
          if (anchor) {
            // Extrair s√≥ a parte do modelo (n√∫mero + variante)
            let modelString = '';
            if (vagueModelMatch) {
              const number = vagueModelMatch[2];
              const variant = vagueModelMatch[3] || '';
              modelString = `${number} ${variant}`.trim();
            } else if (numericOnlyMatch) {
              modelString = numericOnlyMatch[0];
            }
            
            finalQuery = `${anchor} ${modelString}`.replace(/\s+/g, ' ').trim();
            console.log('üß† [Context] Enriquecendo query:', `"${userQuery}" ‚Üí "${finalQuery}" usando anchor "${anchor}"`);
          }
        } else {
          console.log('üß† [Context] Nenhum contexto encontrado nas √∫ltimas mensagens');
        }
      } catch (error) {
        console.warn('‚ùå Erro ao buscar contexto:', error);
      }
    }

    // 2) Mostra primeiro (prefetch com a query enriquecida) - SEMPRE
    const ofertas = finalQuery ? await buscarOfertas({ query: finalQuery, maxResultados: 12 }) : [];
    console.log('üîç [Final Search] Buscando com query final:', `"${finalQuery}"`);
    console.log('‚úÖ [Final Search] Encontrados', ofertas.length, 'produtos');

    // 2) Decide mensagem "exata" a partir do contexto (Heur√≠stica simples)
    let text;
    if (ofertas.length === 0) {
      text = msgNoResultsGemini(message); // Passa a query original para contexto
    } else {
      // Heur√≠stica: se a query tem 1‚Äì2 palavras => gen√©rico; caso contr√°rio espec√≠fico
      const tokens = userQuery.split(/\s+/).filter(Boolean);
      if (tokens.length <= 2) {
        text = msgGenericFoundGemini(segmentoDaQueryGemini(userQuery, ofertas));
      } else {
        text = msgSpecificFoundGemini();
      }
    }

    // 3) Resposta espec√≠fica baseada nos produtos encontrados
    let finalMessage;
    if (ofertas.length > 0) {
      // Se h√° produtos, for√ßar resposta espec√≠fica baseada nos dados reais
      const topProducts = ofertas.slice(0, 3);
      const productList = topProducts.map(p => 
        `${p.title} por $${p.price?.USD || 'consultar'} na ${p.storeName}`
      ).join(', ');
      
      try {
        // Importar Gemini
        const { GoogleGenerativeAI } = await import('@google/generative-ai');
        const geminiAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY || '');
        
        const model = geminiAI.getGenerativeModel({ model: 'gemini-2.0-flash-exp' });
        
        const simplePrompt = `Responda como vendedor amig√°vel. Mencione EXATAMENTE estes produtos: ${productList}. Use 1 emoji. M√°ximo 2 frases.`;

        const result = await model.generateContent(simplePrompt);
        finalMessage = sanitizeChatGemini(result.response.text() || `Encontrei: ${productList} üì±`);
      } catch (geminiError) {
        console.error('Erro no Gemini:', geminiError);
        // Fallback INTELIGENTE com dados espec√≠ficos dos produtos
        const count = ofertas.length;
        const firstProduct = topProducts[0];
        if (count === 1) {
          finalMessage = `Achei ${firstProduct.title} por $${firstProduct.price?.USD || 'consultar'} na ${firstProduct.storeName}! üì±`;
        } else if (count <= 3) {
          finalMessage = `Encontrei ${count} op√ß√µes: ${productList}. Qual te interessa? üì±`;
        } else {
          finalMessage = `Separei ${count} op√ß√µes de ${segmentoDaQueryGemini(userQuery, ofertas)}. Primeiros: ${productList} üì±`;
        }
      }
    } else {
      // Se n√£o h√° produtos, usar template direto
      finalMessage = msgNoResultsGemini(message);
    }

    // 4) (Opcional) 1 pergunta leve ap√≥s mostrar
    let pergunta = "";
    if (ofertas.length > 0) {
      // Exemplos de temas espec√≠ficos
      if (/iphone|apple/i.test(userQuery)) pergunta = msgSoftQuestionGemini("linha 13 ou 15");
      else if (/drone/i.test(userQuery)) pergunta = msgSoftQuestionGemini("compacto ou c√¢mera mais parruda");
      else if (/perfume/i.test(userQuery)) pergunta = msgSoftQuestionGemini("marcas favoritas (Dior, Calvin Klein...)");
    }
    const finalText = sanitizeChatGemini([finalMessage, pergunta].filter(Boolean).join(" "));

    // 5) Entrega: chat curto + ofertas para o painel
    send('delta', { text: finalText });
    
    try {
      await storage.createAssistantMessage({
        sessionId,
        role: 'assistant',
        content: finalText,
        metadata: { streamed: true, timestamp: new Date().toISOString(), provider: 'gemini', showThenAsk: true }
      });
    } catch (error) {
      console.warn('Erro ao salvar resposta Gemini:', error);
    }

  } catch (error) {
    console.error('Erro no chat Gemini:', error);
    send('delta', { text: "Me diga o nome do produto (ex.: 'iphone') que eu listo pra voc√™!" });
  }

  send('complete', { provider: 'gemini' });
  res.end();
});

// =============================================
// AN√ÅLISE DO C√ìDIGO GEMINI
// =============================================

/*
FUNCIONALIDADES PRINCIPAIS:

1. CONTEXTO INTELIGENTE:
   - Detecta queries vagas como "modelo 12", "quero o 15"
   - Busca contexto nas √∫ltimas 10 mensagens do usu√°rio
   - Combina contexto + query vaga = query espec√≠fica
   - Exemplo: "iphone" + "modelo 12" = "iphone modelo 12"

2. BUSCA DE PRODUTOS:
   - Usa searchSuggestions() para buscar produtos
   - Ordena por pre√ßo (menor primeiro)
   - Limita resultados (m√°x 50)
   - Envia produtos para painel via SSE

3. TEMPLATES DE RESPOSTA:
   - msgGenericFoundGemini(): Consultas gen√©ricas
   - msgSpecificFoundGemini(): Consultas espec√≠ficas  
   - msgNoResultsGemini(): Nenhum resultado
   - msgSoftQuestionGemini(): Pergunta opcional

4. INTEGRA√á√ÉO GEMINI API:
   - Usa Google Generative AI (gemini-2.0-flash-exp)
   - Prompt espec√≠fico com dados reais dos produtos
   - Fallback inteligente se API falhar
   - Sanitiza√ß√£o de texto (remove links/imagens)

5. SISTEMA SHOW-THEN-ASK:
   - Sempre mostra produtos primeiro
   - Chat curto (m√°x 2 frases)
   - Pergunta opcional depois de mostrar
   - Nunca bloqueia pedindo informa√ß√µes

PONTOS FORTES:
‚úÖ Contexto conversacional funcional
‚úÖ Fallbacks robustos para API failures
‚úÖ Respostas espec√≠ficas com dados reais
‚úÖ Sanitiza√ß√£o completa de texto
‚úÖ Sistema show-then-ask implementado

PONTOS FRACOS:
‚ùå Dependente do Google Gemini API (pode dar 503)
‚ùå Regex de contexto ainda pode ser melhorada
‚ùå Busca de produtos n√£o √© tokenizada/normalizada
‚ùå N√£o tem guard anti-duplicidade
‚ùå Mem√≥ria de contexto n√£o √© persistente

SUGEST√ïES DE MELHORIA:
1. Implementar busca robusta com tokeniza√ß√£o
2. Adicionar guard anti-duplicidade
3. Melhorar persist√™ncia de contexto
4. Fallbacks mais inteligentes para Gemini API
5. Logs mais detalhados para debug

DIFEREN√áAS vs BARRA AZUL (OpenAI):
- Gemini: Usa Google Generative AI + fallbacks espec√≠ficos
- OpenAI: Usa GPT + sistema de contexto por sess√£o
- Gemini: Templates mais espec√≠ficos por categoria
- OpenAI: Busca robusta com normaliza√ß√£o/tokeniza√ß√£o
- Gemini: Logs de debug detalhados
- OpenAI: Guard anti-duplicidade implementado
*/