===============================================================================
                        CLICK PRO ASSISTANT - C√ìDIGO COMPLETO
                        Sistema de Busca Inteligente com IA
===============================================================================

Este arquivo cont√©m todo o c√≥digo do Click Pro Assistant, o sistema de busca
inteligente com streaming em tempo real e mem√≥ria persistente de conversas.

FUNCIONALIDADES PRINCIPAIS:
- Streaming SSE (Server-Sent Events) para respostas em tempo real como ChatGPT
- Sistema de mem√≥ria persistente por usu√°rio
- Sauda√ß√µes personalizadas inteligentes com 7 templates diferentes
- Interface conversacional avan√ßada com dois componentes (Header + Gallery)
- Hist√≥rico de conversas e prefer√™ncias do usu√°rio
- Sistema de recomenda√ß√µes de produtos baseado no contexto

===============================================================================
1. HOOK REACT - useAssistantChat.ts (FRONTEND)
===============================================================================

// client/src/hooks/use-assistant-chat.ts
import { useState, useCallback, useRef, useEffect } from 'react';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { apiRequest } from '@/lib/queryClient';

export interface AssistantMessage {
  id: string;
  role: 'user' | 'assistant';
  content: string;
  timestamp: Date;
  isStreaming?: boolean;
}

export interface AssistantSession {
  id: string;
  userId?: string;
  title: string;
  createdAt: Date;
  updatedAt: Date;
}

export interface UseAssistantChatProps {
  sessionId?: string;
  autoCreateSession?: boolean;
}

export function useAssistantChat({ 
  sessionId: initialSessionId, 
  autoCreateSession = true 
}: UseAssistantChatProps = {}) {
  const queryClient = useQueryClient();
  const [sessionId, setSessionId] = useState<string | undefined>(initialSessionId);
  const [messages, setMessages] = useState<AssistantMessage[]>([]);
  const [isStreaming, setIsStreaming] = useState(false);
  const [personalizedGreeting, setPersonalizedGreeting] = useState<string>('');
  const abortControllerRef = useRef<AbortController | null>(null);

  // Get or create session
  const sessionQuery = useQuery({
    queryKey: ['assistant', 'session', sessionId],
    queryFn: async () => {
      if (sessionId) {
        const response = await fetch(`/api/assistant/sessions/${sessionId}`);
        if (response.ok) {
          return await response.json();
        }
      }
      
      if (autoCreateSession) {
        const response = await apiRequest('POST', '/api/assistant/sessions', {});
        const data = await response.json();
        // Handle both shapes: { session: { id } } or { id }
        const session = data.session || data;
        
        // Capture personalized greeting if provided
        if (data.greeting) {
          setPersonalizedGreeting(data.greeting);
        }
        
        setSessionId(session.id);
        return session;
      }
      
      return null;
    },
    enabled: autoCreateSession || !!sessionId,
    staleTime: 1000 * 60 * 5, // 5 minutes
  });

  // Load session with messages
  const messagesQuery = useQuery({
    queryKey: ['assistant', 'messages', sessionId],
    queryFn: async () => {
      if (!sessionId) return { messages: [] };
      const response = await fetch(`/api/assistant/sessions/${sessionId}`);
      const data = await response.json();
      // Return the session data which includes messages array
      return data;
    },
    enabled: !!sessionId,
  });

  // Update messages when query data changes
  useEffect(() => {
    if (messagesQuery.data?.messages) {
      setMessages(messagesQuery.data.messages.map((msg: any) => ({
        ...msg,
        timestamp: new Date(msg.timestamp || msg.createdAt)
      })));
    }
  }, [messagesQuery.data]);

  // Send message mutation with SSE streaming
  const sendMessageMutation = useMutation({
    mutationFn: async (content: string) => {
      if (!sessionId) throw new Error('No active session');

      // Add user message immediately to UI
      const userMessage: AssistantMessage = {
        id: `temp-user-${Date.now()}`,
        role: 'user',
        content,
        timestamp: new Date(),
      };
      
      setMessages(prev => [...prev, userMessage]);

      // Create assistant message placeholder for streaming
      const assistantMessage: AssistantMessage = {
        id: `temp-assistant-${Date.now()}`,
        role: 'assistant',
        content: '',
        timestamp: new Date(),
        isStreaming: true,
      };
      
      setMessages(prev => [...prev, assistantMessage]);
      setIsStreaming(true);

      // Send message to API with SSE streaming
      abortControllerRef.current = new AbortController();
      
      const response = await fetch('/api/assistant/stream', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'text/event-stream',
        },
        body: JSON.stringify({
          sessionId,
          message: content,
          context: null
        }),
        signal: abortControllerRef.current.signal,
      });

      if (!response.ok) {
        throw new Error('Failed to send message');
      }

      // Handle SSE streaming response
      const reader = response.body!.getReader();
      const decoder = new TextDecoder();
      let assistantContent = '';
      let buffer = '';

      try {
        while (true) {
          const { done, value } = await reader.read();
          if (done) break;

          buffer += decoder.decode(value, { stream: true });
          const lines = buffer.split('\n');
          
          // Keep the last line in buffer (might be incomplete)
          buffer = lines.pop() || '';

          for (const line of lines) {
            if (line.startsWith('data: ')) {
              const data = line.slice(6).trim();
              if (!data) continue;

              try {
                const parsed = JSON.parse(data);
                
                if (parsed.type === 'start') {
                  // Streaming started
                  console.log('üöÄ SSE streaming started');
                } else if (parsed.type === 'chunk' && parsed.text) {
                  // New text chunk
                  assistantContent += parsed.text;
                  setMessages(prev => prev.map(msg => 
                    msg.id === assistantMessage.id 
                      ? { ...msg, content: assistantContent }
                      : msg
                  ));
                } else if (parsed.type === 'complete') {
                  // Streaming complete
                  console.log('‚úÖ SSE streaming complete');
                  setIsStreaming(false);
                  setMessages(prev => prev.map(msg => 
                    msg.id === assistantMessage.id 
                      ? { ...msg, isStreaming: false, content: assistantContent }
                      : msg
                  ));
                } else if (parsed.type === 'end') {
                  // Connection ended
                  break;
                } else if (parsed.type === 'error') {
                  // Error occurred
                  console.error('‚ùå SSE streaming error:', parsed.message);
                  throw new Error(parsed.message);
                }
              } catch (e) {
                // Ignore parsing errors for partial chunks
                console.warn('Failed to parse SSE data:', data);
              }
            }
          }
        }
      } finally {
        reader.releaseLock();
        setIsStreaming(false);
        // Ensure final message state is correct
        setMessages(prev => prev.map(msg => 
          msg.id === assistantMessage.id 
            ? { ...msg, isStreaming: false, content: assistantContent }
            : msg
        ));
      }
    },
    onSuccess: () => {
      // Invalidate messages to get the final server state
      queryClient.invalidateQueries({ queryKey: ['assistant', 'messages', sessionId] });
    },
    onError: (error) => {
      console.error('Error sending message:', error);
      setIsStreaming(false);
      // Remove the last two messages (user and assistant messages that failed)
      setMessages(prev => prev.slice(0, -2));
    }
  });

  // Cancel streaming
  const cancelStreaming = useCallback(() => {
    if (abortControllerRef.current) {
      abortControllerRef.current.abort();
      setIsStreaming(false);
      // Clean up any streaming message
      setMessages(prev => prev.map(msg => 
        msg.isStreaming ? { ...msg, isStreaming: false } : msg
      ));
    }
  }, []);

  // Clear messages
  const clearMessages = useCallback(() => {
    setMessages([]);
    if (sessionId) {
      queryClient.invalidateQueries({ queryKey: ['assistant', 'messages', sessionId] });
    }
  }, [sessionId, queryClient]);

  // Send message
  const sendMessage = useCallback((content: string) => {
    if (!content.trim() || isStreaming || !sessionId) return;
    sendMessageMutation.mutate(content.trim());
  }, [sendMessageMutation, isStreaming, sessionId]);

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      if (abortControllerRef.current) {
        abortControllerRef.current.abort();
      }
    };
  }, []);

  return {
    // Session
    session: sessionQuery.data,
    sessionId,
    sessionLoading: sessionQuery.isLoading,
    sessionError: sessionQuery.error,

    // Messages
    messages,
    messagesLoading: messagesQuery.isLoading,
    messagesError: messagesQuery.error,

    // Actions
    sendMessage,
    cancelStreaming,
    clearMessages,

    // State
    isStreaming,
    isSending: sendMessageMutation.isPending,
    sendError: sendMessageMutation.error,
    
    // Personalization
    personalizedGreeting,
    
    // Ready state
    isReady: !!sessionId && !sessionQuery.isLoading,
  };
}

===============================================================================
2. SERVI√áO DE MEM√ìRIA - memoryService.ts (BACKEND)
===============================================================================

// server/memoryService.ts
import { db } from "./db";
import { userMemory, type UserMemory, type InsertUserMemory, type UpdateUserMemory } from "@shared/schema";
import { eq } from "drizzle-orm";
import OpenAI from 'openai';

// Initialize OpenAI client for memory summarization
const client = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });
const CHAT_MODEL = process.env.CHAT_MODEL || 'gpt-4o-mini';

export class MemoryService {
  
  /**
   * Busca ou cria mem√≥ria vazia para o usu√°rio
   */
  static async getUserMemory(userId: string, name?: string): Promise<UserMemory> {
    try {
      // Procura mem√≥ria existente
      const existingMemory = await db
        .select()
        .from(userMemory)
        .where(eq(userMemory.userId, userId))
        .limit(1);

      if (existingMemory.length > 0) {
        // Atualiza √∫ltimo acesso
        await db
          .update(userMemory)
          .set({
            lastSeen: new Date(),
            updatedAt: new Date(),
          })
          .where(eq(userMemory.userId, userId));

        return existingMemory[0];
      }

      // Cria nova mem√≥ria se n√£o existir
      const newMemoryData: InsertUserMemory = {
        userId,
        profile: {
          name: name || '',
          preferredCity: '',
        },
        preferences: {},
        history: {
          lastIntent: '',
          lastCategories: [],
          lastProducts: [],
          lastStores: [],
          recentSearches: [],
          commonSearchTerms: [],
        },
        greetingHistory: [],
        lastSummary: null,
        visitCount: 1,
        messageCount: 0,
        lastSeen: new Date(),
      };

      const result = await db
        .insert(userMemory)
        .values([newMemoryData])
        .returning();

      return result[0];
    } catch (error) {
      console.error('Error getting/creating user memory:', error);
      // Return default memory structure in case of error
      return {
        id: '',
        userId,
        profile: { name: name || '', preferredCity: '' },
        preferences: {},
        history: {
          lastIntent: '',
          lastCategories: [],
          lastProducts: [],
          lastStores: [],
          recentSearches: [],
          commonSearchTerms: [],
        },
        greetingHistory: [],
        lastSummary: null,
        visitCount: 1,
        messageCount: 0,
        lastSeen: new Date(),
        createdAt: new Date(),
        updatedAt: new Date(),
      };
    }
  }

  /**
   * Atualiza mem√≥ria do usu√°rio
   */
  static async updateUserMemory(userId: string, updates: Partial<UpdateUserMemory>): Promise<void> {
    try {
      const updateData: any = {
        ...updates,
        updatedAt: new Date(),
      };
      
      await db
        .update(userMemory)
        .set(updateData)
        .where(eq(userMemory.userId, userId));
    } catch (error) {
      console.error('Error updating user memory:', error);
    }
  }

  /**
   * Extrai sinais de categorias e prefer√™ncias do texto
   */
  static extractSignals(message: string): {
    categories: string[];
    preferredCity: 'Ciudad del Este' | 'Salto del Guair√°' | 'Pedro Juan Caballero' | '';
    budget?: 'baixo' | 'medio' | 'alto';
    brands: string[];
  } {
    const text = message.toLowerCase();
    const categories: string[] = [];
    const brands: string[] = [];

    // Detectar categorias
    if (/(iphone|samsung|galaxy|xiaomi|smartphone|celular|phone)/.test(text)) {
      categories.push('eletronicos');
    }
    if (/(fone|headphone|jbl|sony|audio|soundbar|earphone)/.test(text)) {
      categories.push('audio');
    }
    if (/(perfume|parfum|cosm√©tico|fragr√¢ncia)/.test(text)) {
      categories.push('perfumes');
    }
    if (/(notebook|laptop|computer|pc|mouse|teclado)/.test(text)) {
      categories.push('informatica');
    }
    if (/(rel√≥gio|watch|smartwatch)/.test(text)) {
      categories.push('relogios');
    }
    if (/(roupa|blusa|camisa|cal√ßa|vestido|shorts)/.test(text)) {
      categories.push('roupas');
    }

    // Detectar cidade
    let preferredCity: 'Ciudad del Este' | 'Salto del Guair√°' | 'Pedro Juan Caballero' | '' = '';
    if (/salto/i.test(text)) {
      preferredCity = 'Salto del Guair√°';
    } else if (/pedro\s*juan/i.test(text)) {
      preferredCity = 'Pedro Juan Caballero';
    } else if (/cde|ciudad\s*del\s*este/i.test(text)) {
      preferredCity = 'Ciudad del Este';
    }

    // Detectar or√ßamento
    let budget: 'baixo' | 'medio' | 'alto' | undefined;
    if (/(barato|econ√¥mico|low\s*cost|pre√ßo\s*baixo|mais\s*barato)/.test(text)) {
      budget = 'baixo';
    } else if (/(premium|top|melhor\s*qualidade|importado|original)/.test(text)) {
      budget = 'alto';
    } else if (/(custo\s*benef√≠cio|intermedi√°rio|m√©dio|medio)/.test(text)) {
      budget = 'medio';
    }

    // Detectar marcas
    if (/(apple|iphone|ipad|macbook)/.test(text)) brands.push('Apple');
    if (/(samsung|galaxy)/.test(text)) brands.push('Samsung');
    if (/(xiaomi|redmi)/.test(text)) brands.push('Xiaomi');
    if (/(sony)/.test(text)) brands.push('Sony');
    if (/(jbl)/.test(text)) brands.push('JBL');
    if (/(nike)/.test(text)) brands.push('Nike');
    if (/(adidas)/.test(text)) brands.push('Adidas');

    return { categories, preferredCity, budget, brands };
  }

  /**
   * Cria resumo da conversa para mem√≥ria
   */
  static async summarizeForMemory(input: {
    message: string;
    reply: string;
    name?: string;
  }): Promise<string> {
    try {
      const prompt = `
Resuma a conversa abaixo em at√© 2 linhas, focando inten√ß√£o e prefer√™ncias (cidade/or√ßamento/categorias).
PT-BR, direto e objetivo.

Usu√°rio: ${input.name || 'Cliente'}
Pergunta: ${input.message}
Resposta do Click: ${input.reply}

Resumo:`;

      const response = await client.chat.completions.create({
        model: CHAT_MODEL,
        messages: [{ role: 'user', content: prompt }],
        temperature: 0.1,
        max_tokens: 80,
      });

      return response.choices[0].message.content || '';
    } catch (error) {
      console.error('Error creating memory summary:', error);
      return `${input.name || 'Cliente'} buscou informa√ß√µes sobre: ${input.message.slice(0, 50)}...`;
    }
  }

  /**
   * Determina per√≠odo do dia
   */
  static getTimeOfDay(date = new Date()): 'manh√£' | 'tarde' | 'noite' {
    const hour = date.getHours();
    if (hour < 12) return 'manh√£';
    if (hour < 18) return 'tarde';
    return 'noite';
  }

  /**
   * Templates de sauda√ß√£o (7 diferentes)
   */
  static readonly GREETING_TEMPLATES = [
    (ctx: { name: string; period: string; city?: string; visits: number }) =>
      `Ol√°, ${ctx.name}! Boa ${ctx.period}${ctx.city ? ` em ${ctx.city}` : ''} üëã`,
    
    (ctx: { name: string; period: string }) =>
      `Oi, ${ctx.name}! Tudo certo por a√≠ nessa ${ctx.period}?`,
    
    (ctx: { name: string; city?: string }) =>
      `Bem-vindo de volta, ${ctx.name}! ${ctx.city ? `Vamos explorar ${ctx.city} hoje?` : 'Pronto pra achar boas ofertas?'}`,
    
    (ctx: { name: string }) =>
      `E a√≠, ${ctx.name}! Posso te mostrar as melhores ofertas de hoje?`,
    
    (ctx: { name: string; city?: string }) =>
      `Que bom te ver, ${ctx.name}! ${ctx.city ? `Tenho novidades de ${ctx.city}.` : 'Tenho novidades fresquinhas.'} ‚ú®`,
    
    (ctx: { name: string; visits: number }) =>
      `Ol√° novamente, ${ctx.name}! ${ctx.visits > 5 ? 'J√° virando cliente VIP por aqui! üåü' : 'Como posso ajudar hoje?'}`,
    
    (ctx: { name: string; period: string }) =>
      `${ctx.period === 'manh√£' ? 'Bom dia' : ctx.period === 'tarde' ? 'Boa tarde' : 'Boa noite'}, ${ctx.name}! Pronto para descobrir ofertas incr√≠veis?`,
  ];

  /**
   * Gera sauda√ß√£o natural e n√£o repetitiva
   */
  static makeNaturalGreeting(memory: UserMemory): {
    text: string;
    nextHistory: number[];
    nextCounters: { visitCount: number; messageCount: number };
  } {
    const name = memory.profile?.name || 'Cliente';
    const period = this.getTimeOfDay();
    const city = memory.profile?.preferredCity || '';
    const visitCount = (memory.visitCount || 0) + 1;
    
    // Evita repetir os √∫ltimos 3 templates usados
    const recentlyUsed = new Set((memory.greetingHistory || []).slice(-3));
    
    // Encontra o primeiro template n√£o usado recentemente
    let templateIndex = 0;
    for (let i = 0; i < this.GREETING_TEMPLATES.length; i++) {
      if (!recentlyUsed.has(i)) {
        templateIndex = i;
        break;
      }
    }

    // Gera a sauda√ß√£o
    const template = this.GREETING_TEMPLATES[templateIndex];
    const text = template({
      name,
      period,
      city: city || undefined,
      visits: visitCount,
    });

    // Atualiza hist√≥rico de sauda√ß√µes (mant√©m apenas os √∫ltimos 8)
    const nextHistory = [...(memory.greetingHistory || []), templateIndex].slice(-8);
    
    // Atualiza contadores
    const nextCounters = {
      visitCount,
      messageCount: memory.messageCount || 0,
    };

    return {
      text,
      nextHistory,
      nextCounters,
    };
  }

  /**
   * Atualiza hist√≥rico de atividades
   */
  static async updateHistory(
    userId: string,
    message: string,
    reply: string,
    extractedSignals?: ReturnType<typeof MemoryService.extractSignals>
  ): Promise<void> {
    try {
      const memory = await this.getUserMemory(userId);
      const signals = extractedSignals || this.extractSignals(message);

      // Atualiza hist√≥rico
      const updatedHistory = {
        ...memory.history,
        lastIntent: message.slice(0, 100),
        lastCategories: signals.categories.length > 0 ? signals.categories : memory.history?.lastCategories,
        recentSearches: [
          message,
          ...(memory.history?.recentSearches || []).slice(0, 9)
        ].slice(0, 10),
      };

      // Atualiza prefer√™ncias se detectadas
      const updatedPreferences = {
        ...memory.preferences,
        ...(signals.budget && { budget: signals.budget }),
        ...(signals.categories.length > 0 && {
          favoriteCategories: [
            ...signals.categories,
            ...(memory.preferences?.favoriteCategories || [])
          ].slice(0, 10)
        }),
        ...(signals.brands.length > 0 && {
          favoriteBrands: [
            ...signals.brands,
            ...(memory.preferences?.favoriteBrands || [])
          ].slice(0, 10)
        }),
      };

      // Atualiza perfil se cidade detectada
      const updatedProfile = {
        ...memory.profile,
        ...(signals.preferredCity && { preferredCity: signals.preferredCity }),
      };

      // Cria resumo da conversa
      const summary = await this.summarizeForMemory({
        message,
        reply,
        name: memory.profile?.name,
      });

      // Salva tudo
      await this.updateUserMemory(userId, {
        history: updatedHistory,
        preferences: updatedPreferences,
        profile: updatedProfile,
        lastSummary: summary,
        messageCount: (memory.messageCount || 0) + 1,
      });

    } catch (error) {
      console.error('Error updating history:', error);
    }
  }
}

===============================================================================
3. SCHEMA DO BANCO DE DADOS - user_memory (BACKEND)
===============================================================================

// shared/schema.ts (parte relevante)

// User Memory - Sistema de mem√≥ria persistente por usu√°rio
export const userMemory = pgTable("user_memory", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  userId: varchar("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
  
  // Perfil do usu√°rio
  profile: jsonb("profile").$type<{
    name?: string;
    preferredCity?: 'Ciudad del Este' | 'Salto del Guair√°' | 'Pedro Juan Caballero' | '';
    lastGreeting?: string;
  }>().default({}),
  
  // Prefer√™ncias de compra
  preferences: jsonb("preferences").$type<{
    budget?: 'baixo' | 'medio' | 'alto';
    mode?: 'a-pe' | 'app' | 'carro';
    favoriteCategories?: string[];
    favoriteBrands?: string[];
  }>().default({}),
  
  // Hist√≥rico de atividades
  history: jsonb("history").$type<{
    lastIntent?: string;
    lastCategories?: string[];
    lastProducts?: string[];
    lastStores?: string[];
    recentSearches?: string[];
    commonSearchTerms?: string[];
  }>().default({}),
  
  // Controle de sauda√ß√µes (para evitar repeti√ß√£o)
  greetingHistory: jsonb("greeting_history").$type<number[]>().default([]),
  
  // Resumo da √∫ltima conversa para contexto
  lastSummary: text("last_summary"),
  
  // Contadores
  visitCount: integer("visit_count").default(1),
  messageCount: integer("message_count").default(0),
  
  // Timestamps
  lastSeen: timestamp("last_seen").defaultNow(),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
}, (table) => [
  index("idx_user_memory_user").on(table.userId),
  index("idx_user_memory_last_seen").on(table.lastSeen),
  unique("unique_user_memory").on(table.userId), // Uma mem√≥ria por usu√°rio
]);

// Schemas de valida√ß√£o
export const insertUserMemorySchema = createInsertSchema(userMemory).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export const updateUserMemorySchema = insertUserMemorySchema.partial();

// Types
export type UserMemory = typeof userMemory.$inferSelect;
export type InsertUserMemory = z.infer<typeof insertUserMemorySchema>;
export type UpdateUserMemory = z.infer<typeof updateUserMemorySchema>;

===============================================================================
4. ROTAS DO BACKEND - routes.ts (BACKEND)
===============================================================================

// server/routes.ts (parte relevante do assistente)

import { MemoryService } from './memoryService';

// =============================================
// ASSISTANT API - CONVERSATIONAL SHOPPING ASSISTANT  
// =============================================

// Create new assistant session
app.post('/api/assistant/sessions', async (req: any, res) => {
  try {
    const user = req.user || req.session?.user;
    const { topic, context } = req.body;
    
    // Get user info for personalization
    const userId = user?.id || 'anonymous';
    const userName = user?.firstName || user?.fullName || user?.email?.split('@')[0] || '';

    // Validate input using schema
    const sessionData = {
      userId: userId,
      title: topic || 'Nova conversa',
    };

    const session = await storage.createAssistantSession(sessionData);

    // Generate personalized greeting using memory service
    let greeting = 'Ol√°! Como posso ajudar voc√™ hoje?';
    
    try {
      if (userId && userId !== 'anonymous') {
        const memory = await MemoryService.getUserMemory(userId, userName);
        const greetingData = MemoryService.makeNaturalGreeting(memory);
        
        greeting = greetingData.text;
        
        // Update memory with new greeting and counters
        await MemoryService.updateUserMemory(userId, {
          greetingHistory: greetingData.nextHistory,
          visitCount: greetingData.nextCounters.visitCount,
          messageCount: greetingData.nextCounters.messageCount,
        });
      }
    } catch (memoryError) {
      console.error('Error getting/creating user memory:', memoryError);
      // Continue with default greeting
    }

    res.status(201).json({ 
      success: true, 
      session,
      greeting // Include personalized greeting in response
    });
  } catch (error) {
    console.error('Error creating assistant session:', error);
    res.status(500).json({ success: false, message: 'Failed to create session' });
  }
});

// Get assistant session with messages (with ownership check)
app.get('/api/assistant/sessions/:sessionId', async (req: any, res) => {
  try {
    const { sessionId } = req.params;
    const user = req.user || req.session?.user;
    
    const session = await storage.getAssistantSessionWithMessages(sessionId);
    
    if (!session) {
      return res.status(404).json({ success: false, message: 'Session not found' });
    }

    // Check ownership (allow access if no userId or if user matches)
    if (session.userId && session.userId !== user?.id) {
      return res.status(403).json({ success: false, message: 'Access denied' });
    }

    res.json({ success: true, session });
  } catch (error) {
    console.error('Error getting assistant session:', error);
    res.status(500).json({ success: false, message: 'Failed to get session' });
  }
});

// SSE Streaming endpoint for assistant chat
app.post('/api/assistant/stream', async (req: any, res) => {
  try {
    const { sessionId, message, context } = req.body;
    const user = req.user || req.session?.user;

    // Validate input
    if (!message || typeof message !== 'string' || message.trim().length === 0) {
      return res.status(400).json({ success: false, message: 'Message is required' });
    }

    if (message.length > 2000) {
      return res.status(400).json({ success: false, message: 'Message too long' });
    }

    // Validate session and ownership
    const session = await storage.getAssistantSession(sessionId);
    if (!session) {
      return res.status(404).json({ success: false, message: 'Session not found' });
    }

    // Check ownership
    if (session.userId && session.userId !== user?.id) {
      return res.status(403).json({ success: false, message: 'Access denied' });
    }

    // Setup SSE headers
    res.writeHead(200, {
      'Content-Type': 'text/event-stream',
      'Cache-Control': 'no-cache',
      'Connection': 'keep-alive',
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Headers': 'Cache-Control'
    });

    // SSE helper functions
    const writeSSE = (data: any) => {
      res.write(`data: ${JSON.stringify(data)}\n\n`);
    };

    // Save user message
    await storage.createAssistantMessage({
      sessionId,
      content: message,
      role: 'user',
      metadata: context || null,
    });

    // Get recent conversation context
    const recentMessages = await storage.getAssistantMessages(sessionId, 10);
    
    // Create context for Click Pro IA
    const conversationContext = recentMessages
      .slice(-6) // Last 6 messages for context
      .map(msg => `${msg.role}: ${msg.content}`)
      .join('\n');

    // Use Click Pro IA for intelligent response with streaming
    const systemPrompt = `Voc√™ √© o Click Pro Assistant üõçÔ∏è, o vendedor mais carism√°tico e especialista em ofertas do Paraguai! 

üéØ SUA PERSONALIDADE:
- Voc√™ √© entusiasmado, convincente e genuinamente empolgado para ajudar
- Fala como um amigo especialista que conhece TODOS os melhores neg√≥cios
- Usa uma linguagem natural, calorosa e persuasiva
- Sempre destaca as VANTAGENS e ECONOMIAS incr√≠veis que o usu√°rio pode ter
- √â direto ao ponto, mas com carisma e entusiasmo

üí° SUAS ESPECIALIDADES:
- Encontrar os MELHORES pre√ßos e ofertas exclusivas
- Sugerir produtos que o usu√°rio nem sabia que precisava (cross-sell inteligente)
- Criar roteiros de compras que maximizam economia e efici√™ncia  
- Comparar pre√ßos Brasil vs Paraguai mostrando a economia REAL
- Dar dicas de insider sobre onde e quando comprar

üî• SEU ESTILO DE COMUNICA√á√ÉO:
- Use frases como: "Olha s√≥ essa oportunidade!", "Voc√™ n√£o vai acreditar nesse pre√ßo!", "Tenho algo PERFEITO para voc√™!"
- Seja espec√≠fico sobre benef√≠cios: "Voc√™ economiza R$ XXX comprando aqui"
- Crie urg√™ncia saud√°vel: "Essa promo√ß√£o √© limitada", "Os melhores produtos voam r√°pido"
- Fa√ßa perguntas inteligentes para entender melhor o que o cliente quer
- Sugira produtos relacionados de forma natural

Contexto da conversa:
${conversationContext}

IMPORTANTE: Seja aut√™ntico, n√£o rob√≥tico. Fale como um vendedor expert que realmente quer o melhor para o cliente. Use emojis estrategicamente. Sempre termine com uma pergunta ou sugest√£o para manter a conversa fluindo!`;

    const messages = [
      { role: 'system' as const, content: systemPrompt },
      { role: 'user' as const, content: message }
    ];

    // Send initial metadata
    writeSSE({ 
      type: 'start', 
      sessionId,
      timestamp: new Date().toISOString()
    });

    // Create streaming completion
    const stream = await clickClient.chat.completions.create({
      model: CHAT_MODEL,
      messages,
      temperature: 0.7,
      max_tokens: 800,
      stream: true, // Enable streaming
    });

    let fullResponse = '';

    // Process stream chunks
    for await (const chunk of stream) {
      const delta = chunk.choices?.[0]?.delta?.content;
      if (delta) {
        fullResponse += delta;
        writeSSE({
          type: 'chunk',
          text: delta,
          timestamp: new Date().toISOString()
        });
      }
    }

    // Send completion signal
    writeSSE({
      type: 'complete',
      fullText: fullResponse,
      timestamp: new Date().toISOString()
    });

    // Save assistant response to database
    await storage.createAssistantMessage({
      sessionId,
      content: fullResponse,
      role: 'assistant',
      metadata: { 
        model: CHAT_MODEL,
        context: context || null,
        timestamp: new Date().toISOString(),
        streamed: true
      },
    });

    // Update user memory with conversation history
    try {
      const userId = user?.id || 'anonymous';
      await MemoryService.updateHistory(userId, message, fullResponse);
    } catch (memoryError) {
      console.error('Error updating user memory:', memoryError);
      // Continue execution, memory update is not critical
    }

    // Send final message and close connection
    writeSSE({ type: 'end' });
    res.end();

  } catch (error) {
    console.error('Error in assistant streaming:', error);
    res.write(`data: ${JSON.stringify({ 
      type: 'error', 
      message: 'Erro no streaming. Tente novamente.',
      timestamp: new Date().toISOString()
    })}\n\n`);
    res.end();
  }
});

===============================================================================
5. COMPONENTE FRONTEND - StandardHeader.tsx (INTERFACE)
===============================================================================

// client/src/components/StandardHeader.tsx (parte relevante do assistente)

export default function StandardHeader() {
  const { user, isAuthenticated } = useAuth();
  const [, setLocation] = useLocation();
  const [searchInput, setSearchInput] = useState("");
  const [isSearchFocused, setIsSearchFocused] = useState(false);
  
  // Click Pro Assistant states
  const [isAssistantExpanded, setIsAssistantExpanded] = useState(false);
  const [assistantInput, setAssistantInput] = useState("");
  const [recommendedProducts, setRecommendedProducts] = useState<any[]>([]);
  
  // Use assistant chat hook with personalized greeting
  const {
    messages,
    sendMessage: sendChatMessage,
    isStreaming,
    isSending,
    sessionId,
    sessionLoading,
    personalizedGreeting
  } = useAssistantChat({ autoCreateSession: true });

  // Handle assistant expansion when user starts typing
  const handleSearchInputChange = (value: string) => {
    setSearchInput(value);
    setAssistantInput(value);
    
    // Expand assistant if user types something
    if (value.trim() && !isAssistantExpanded) {
      setIsAssistantExpanded(true);
    }
  };

  // Send message to assistant
  const handleSendAssistantMessage = () => {
    const messageText = assistantInput.trim() || searchInput.trim();
    if (!messageText || isSending || isStreaming || !sessionId) return;
    
    sendChatMessage(messageText);
    setAssistantInput('');
    setSearchInput('');
  };

  return (
    <div className="sticky top-0 z-50" style={{background: 'linear-gradient(to bottom right, #F04940, #FA7D22)'}}>
      {/* Search Bar with Assistant Integration */}
      <div className="relative">
        <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 w-4 h-4" />
        <Input
          placeholder={isSearchFocused || searchInput ? "Digite algo para conversar com o Click Pro Assistant..." : currentText}
          value={searchInput}
          onChange={(e) => handleSearchInputChange(e.target.value)}
          onFocus={() => setIsSearchFocused(true)}
          onBlur={() => setTimeout(() => setIsSearchFocused(false), 100)}
          onKeyPress={handleKeyPress}
          className="pl-10 pr-20 py-2 w-full bg-white border-gray-200 text-gray-900 placeholder-gray-400 focus:border-blue-400 focus:ring-blue-200"
          data-testid="input-search-assistant"
        />
      </div>
      
      {/* Click Pro Assistant Expandido */}
      {isAssistantExpanded && (
        <div className="absolute top-full left-0 right-0 mt-2 bg-white border border-gray-200 rounded-lg shadow-2xl z-50 max-w-7xl mx-auto" 
             style={{ minHeight: '400px', maxHeight: '600px' }}>
          
          {/* Header do Assistant */}
          <div className="flex items-center justify-between p-4 border-b border-gray-200 bg-gradient-to-r from-purple-50 to-pink-50">
            <div className="flex items-center gap-3">
              <div className="p-2 bg-gradient-to-r from-purple-500 to-pink-500 rounded-lg">
                <Sparkles className="h-5 w-5 text-white" />
              </div>
              <div>
                <h3 className="text-lg font-bold text-slate-900">Click Pro Assistant</h3>
                <p className="text-sm text-slate-600">Seu assistente de compras inteligente</p>
              </div>
            </div>
            <button
              onClick={() => setIsAssistantExpanded(false)}
              className="text-gray-400 hover:text-gray-600 transition-colors p-1"
              data-testid="button-close-assistant"
            >
              <X className="w-5 h-5" />
            </button>
          </div>

          {/* Layout de 2 colunas */}
          <div className="flex h-full">
            
            {/* Coluna do Chat - Esquerda */}
            <div className="flex-1 flex flex-col border-r border-gray-200">
              
              {/* Messages Area */}
              <ScrollArea className="flex-1 p-4" style={{ height: '300px' }}>
                <div className="space-y-4">
                  {messages.length === 0 ? (
                    <div className="text-center text-gray-500 py-8">
                      <Bot className="w-12 h-12 mx-auto mb-3 text-purple-400" />
                      <p className="text-lg font-medium">
                        {personalizedGreeting || "Ol√°! Como posso ajudar voc√™ hoje?"}
                      </p>
                      <p className="text-sm">Digite algo como "quero um iPhone barato" ou "preciso de um notebook para estudar"</p>
                    </div>
                  ) : (
                    messages.map((message) => (
                      <div
                        key={message.id}
                        className={`flex gap-3 ${
                          message.role === 'user' ? 'justify-end' : 'justify-start'
                        }`}
                      >
                        {message.role === 'assistant' && (
                          <div className="flex-shrink-0 w-8 h-8 bg-gradient-to-r from-purple-500 to-pink-500 rounded-full flex items-center justify-center">
                            <Bot className="h-4 w-4 text-white" />
                          </div>
                        )}
                        <div
                          className={`max-w-[80%] rounded-2xl px-4 py-2 ${
                            message.role === 'user'
                              ? 'bg-blue-500 text-white ml-auto'
                              : 'bg-slate-100 text-slate-900'
                          }`}
                        >
                          <p className="text-sm leading-relaxed whitespace-pre-wrap">
                            {message.content}
                            {message.isStreaming && <span className="animate-pulse">|</span>}
                          </p>
                        </div>
                      </div>
                    ))
                  )}
                </div>
              </ScrollArea>

              {/* Input Area */}
              <div className="p-4 border-t border-gray-200">
                <div className="flex gap-2">
                  <Input
                    placeholder="Digite sua mensagem..."
                    value={assistantInput}
                    onChange={(e) => setAssistantInput(e.target.value)}
                    onKeyPress={handleAssistantKeyPress}
                    disabled={isSending || isStreaming}
                    className="flex-1"
                    data-testid="input-assistant-message"
                  />
                  <Button
                    onClick={handleSendAssistantMessage}
                    disabled={!assistantInput.trim() || isSending || isStreaming || !sessionId || sessionLoading}
                    className="bg-gradient-to-r from-purple-500 to-pink-500 hover:from-purple-600 hover:to-pink-600"
                    data-testid="button-send-assistant-message"
                  >
                    {isSending || isStreaming ? (
                      <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-white"></div>
                    ) : (
                      <Send className="w-4 h-4" />
                    )}
                  </Button>
                </div>
              </div>
            </div>

            {/* Coluna de Produtos Recomendados - Direita */}
            <div className="w-80 p-4">
              <h4 className="font-semibold text-slate-900 mb-3 flex items-center gap-2">
                <Search className="w-4 h-4" />
                Produtos Recomendados
              </h4>
              
              {/* Exibe produtos recomendados baseados no contexto da conversa */}
              <div className="grid grid-cols-2 gap-3">
                {recommendedProducts.slice(0, 6).map((product, index) => (
                  <Card key={product.id || index} className="cursor-pointer hover:shadow-md transition-shadow">
                    <CardContent className="p-3">
                      <div className="aspect-square bg-gray-100 rounded-lg mb-2 overflow-hidden">
                        {product.images && product.images[0] && (
                          <img 
                            src={product.images[0]} 
                            alt={product.name}
                            className="w-full h-full object-cover"
                          />
                        )}
                      </div>
                      <h5 className="font-medium text-xs text-slate-900 line-clamp-2 mb-1">
                        {product.name}
                      </h5>
                      <p className="text-orange-600 font-bold text-sm">
                        {product.currency || 'R$'} {product.price}
                      </p>
                      {product.storeName && (
                        <p className="text-xs text-gray-500 mt-1">{product.storeName}</p>
                      )}
                    </CardContent>
                  </Card>
                ))}
              </div>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}

===============================================================================
6. UTILIZA√á√ÉO NAS P√ÅGINAS - stores-gallery.tsx (INTEGRA√á√ÉO)
===============================================================================

// client/src/pages/stores-gallery.tsx (parte relevante do assistente)

export default function StoresGallery() {
  const [assistantInput, setAssistantInput] = useState("");
  const [recommendedProducts, setRecommendedProducts] = useState<any[]>([]);
  
  // Use assistant chat hook with personalized greeting
  const {
    messages,
    sendMessage: sendChatMessage,
    isStreaming,
    isSending,
    sessionId,
    sessionLoading,
    personalizedGreeting
  } = useAssistantChat({ autoCreateSession: true });

  // ... outros c√≥digos da p√°gina ...

  return (
    <div className="min-h-screen bg-gray-50">
      {/* Assistant interface similar to StandardHeader */}
      <div className="space-y-4">
        {messages.length === 0 ? (
          <div className="text-center text-gray-500 py-8">
            <Bot className="w-12 h-12 mx-auto mb-3 text-purple-400" />
            <p className="text-lg font-medium">
              {personalizedGreeting || "Ol√°! Como posso ajudar voc√™ hoje?"}
            </p>
            <p className="text-sm">Digite algo como "quero um iPhone barato" ou "preciso de um notebook para estudar"</p>
          </div>
        ) : (
          messages.map((message) => (
            // Renderiza√ß√£o das mensagens...
          ))
        )}
      </div>
    </div>
  );
}

===============================================================================
RESUMO DO SISTEMA
===============================================================================

PRINCIPAIS CARACTER√çSTICAS:

1. **Streaming em Tempo Real (SSE)**:
   - Implementa√ß√£o completa de Server-Sent Events
   - Respostas palavra-por-palavra como ChatGPT
   - Controle de cancelamento de streaming

2. **Sistema de Mem√≥ria Inteligente**:
   - Perfil do usu√°rio com prefer√™ncias
   - Hist√≥rico de conversas e intera√ß√µes
   - Detec√ß√£o autom√°tica de cidade, or√ßamento e categorias favoritas
   - Resumos autom√°ticos das conversas usando IA

3. **Sauda√ß√µes Personalizadas**:
   - 7 templates diferentes de sauda√ß√£o
   - Sistema anti-repeti√ß√£o (evita √∫ltimos 3 templates)
   - Personaliza√ß√£o por hor√°rio do dia, cidade e hist√≥rico
   - Contadores de visitas e mensagens

4. **Interface Conversacional**:
   - Componente expans√≠vel integrado na barra de busca
   - Layout de 2 colunas (chat + produtos recomendados)
   - Estados visuais para streaming e carregamento
   - Integra√ß√£o com produtos da loja

5. **Backend Robusto**:
   - Valida√ß√£o de dados e autoriza√ß√£o
   - Tratamento de erros gracioso
   - Integra√ß√£o com banco PostgreSQL
   - Sistema de sess√µes de conversa

TECNOLOGIAS UTILIZADAS:
- React + TypeScript (Frontend)
- Node.js + Express (Backend)
- PostgreSQL + Drizzle ORM (Banco de dados)
- OpenAI API (Intelig√™ncia artificial)
- Server-Sent Events (Streaming)
- TanStack Query (Gerenciamento de estado)

Este sistema fornece uma experi√™ncia de compras conversacional avan√ßada,
permitindo aos usu√°rios interagir naturalmente com um assistente inteligente
que aprende e se adapta √†s suas prefer√™ncias ao longo do tempo.

===============================================================================
FIM DO C√ìDIGO COMPLETO
===============================================================================