CLICK ASSISTANT - CÓDIGO COMPLETO
=====================================

Sistema completo do Click Pro Assistant para Click Ofertas Paraguai
Implementado com todos os patches aplicados conforme solicitado:

✅ PATCH A: Stream compatível com POST /api/assistant/stream
✅ PATCH B: Saudação entra como primeira mensagem  
✅ PATCH C: Produtos recomendados ao criar sessão
✅ PATCH D: Prompt curto no backend (max_tokens: 220, soft-cut)
✅ PATCH E: Layout do chat embutido
✅ Tabela user_memory criada e funcionando
✅ MemoryService para saudações inteligentes

=====================================

1. FRONTEND - COMPONENTE PRINCIPAL
===================================

arquivo: client/src/components/InlineAssistant.tsx
--------------------------------------------------

/**
 * InlineAssistant
 * ----------------
 * - Barra de busca que expande levemente ao focar.
 * - Chat "embutido" logo abaixo da barra, no mesmo card (altura limitada + scroll).
 * - Coluna à direita: até 3 "Produtos Recomendados".
 * - Restante dos resultados vai para a área "Resultados" mais abaixo (fora do chat).
 *
 * Requisitos de backend:
 *  - POST /assistant/session (headers: x-user-id, x-user-name) -> { sessionId, greeting, suggest }
 *  - GET  /assistant/stream?sessionId=&message=&userId=&userName= (SSE)
 *  - GET  /suggest?q=...
 */

import React, { useEffect, useMemo, useRef, useState } from 'react';

type Store = { id:string; name:string; label?:string; mall?:string };
type Product = { id:string; title:string; category?:string; price?:{ USD?: number }, score?:number, storeId?:string };
type SuggestResponse = { ok:boolean; category?:string; topStores:Store[]; products:Product[]; scratchcard?:any };

export default function InlineAssistant(){
  // identidade (mock — seu login deve preencher isso)
  const uid = useMemo(()=> localStorage.getItem('uid') || (localStorage.setItem('uid','u-'+Math.random().toString(36).slice(2,8)), localStorage.getItem('uid')!), []);
  const userName = useMemo(()=> localStorage.getItem('userName') || 'Cliente', []);

  const [sessionId, setSessionId] = useState('');
  const [expanded, setExpanded] = useState(false);   // controla expansão suave da barra
  const [input, setInput] = useState('');
  const [greeting, setGreeting] = useState('');      // saudação inicial
  const [streamingText, setStreamingText] = useState(''); // texto do SSE
  const [recommended, setRecommended] = useState<Product[]>([]); // top 3
  const [feed, setFeed] = useState<Product[]>([]);   // restante (abaixo da barra)
  const [loadingSug, setLoadingSug] = useState(false);
  const esRef = useRef<EventSource|null>(null);

  // cria sessão e carrega greeting + sugestões iniciais
  useEffect(()=> {
    fetch('/assistant/session', {
      method: 'POST',
      headers: { 'x-user-id': uid, 'x-user-name': userName }
    })
      .then(r=>r.json())
      .then(d=>{
        setSessionId(d.sessionId);
        if (d.greeting) setGreeting(d.greeting);
        if (d.suggest?.products) {
          const top3 = d.suggest.products.slice(0,3);
          const rest = d.suggest.products.slice(3);
          setRecommended(top3);
          setFeed(rest);
        }
      });
  }, [uid, userName]);

  function startStream(message:string){
    if (!sessionId) return;
    if (esRef.current){ esRef.current.close(); esRef.current = null; }
    setStreamingText('');
    const qs = new URLSearchParams({ sessionId, message, userId: uid, userName });
    const es = new EventSource(`/assistant/stream?${qs.toString()}`);
    esRef.current = es;
    es.onmessage = (evt)=>{
      try{
        const p = JSON.parse(evt.data);
        if (p.type==='chunk' && p.text) setStreamingText(prev=> prev + p.text);
      }catch{
        setStreamingText(prev=> prev + evt.data);
      }
    };
    es.onerror = ()=>{ es.close(); esRef.current = null; };
  }
  useEffect(()=> ()=>{ esRef.current?.close(); }, []);

  async function handleFocus(){
    setExpanded(true);
    // opcional: iniciar "oi" tipando
    startStream('oi');
  }

  async function handleChange(q:string){
    setInput(q);
    const term = q.trim();
    if (!term) { setFeed([]); return; }
    try{
      setLoadingSug(true);
      const r = await fetch(`/suggest?q=${encodeURIComponent(term)}`, { headers:{ 'x-user-id': uid }});
      const data: SuggestResponse = await r.json();

      const top3 = (data.products||[]).slice(0,3);
      const rest = (data.products||[]).slice(3);
      setRecommended(top3);
      setFeed(rest);
    }finally{
      setLoadingSug(false);
    }
  }

  function handleSubmit(e:React.FormEvent){
    e.preventDefault();
    const q = input.trim(); if (!q) return;
    startStream(q);
  }

  return (
    <div className="w-full">
      {/* CARD SUPERIOR: barra + chat embutido + col. recomendados */}
      <div className="grid grid-cols-12 gap-4">
        {/* Esquerda: barra + chat embutido */}
        <div className="col-span-12 lg:col-span-9">
          <div className={`rounded-2xl border bg-white/80 backdrop-blur p-3 shadow-sm transition-all
            ${expanded ? 'shadow-[0_0_0_8px_rgba(99,102,241,0.12)]' : ''}`}>
            {/* Barra de busca integrada */}
            <form onSubmit={handleSubmit}
              className={`flex items-center gap-2 rounded-2xl px-4 transition-all bg-white shadow
              ${expanded ? 'py-3 scale-[1.01]' : 'py-2'}`}>
              <div className="flex items-center justify-center w-7 h-7 rounded-full bg-gradient-to-br from-indigo-500 to-purple-500 text-white text-xs">C</div>
              <input
                value={input}
                onChange={(e)=> handleChange(e.target.value)}
                onFocus={handleFocus}
                placeholder="Fale com o Click (ex.: iPhone 15 em CDE)"
                className="flex-1 outline-none text-base"
              />
              <button className="px-3 py-1.5 rounded-lg bg-black text-white hover:opacity-90" type="submit">Buscar</button>
            </form>

            {/* Chat embutido (aparece no MESMO card, com altura limitada + scroll) */}
            <div className="mt-3">
              <div className="text-xs text-gray-500 mb-1">Click Assistant</div>
              <div className="rounded-xl bg-gray-50 border p-3 max-h-[220px] overflow-auto">
                {/* saudação + streaming */}
                <div className="whitespace-pre-wrap">
                  {greeting ? `${greeting}\n` : ''}
                  {streamingText}
                </div>
              </div>
              {loadingSug && <div className="text-xs text-gray-500 mt-2">Buscando ofertas…</div>}
            </div>
          </div>

          {/* FEED ABAIXO (fora do box do chat) */}
          <div className="mt-4">
            <ResultsFeed items={feed} />
          </div>
        </div>

        {/* Direita: até 3 recomendados */}
        <div className="col-span-12 lg:col-span-3">
          <div className="rounded-2xl border bg-white/80 backdrop-blur p-4 shadow-sm">
            <div className="text-sm font-semibold mb-2">Produtos Recomendados</div>
            {!recommended.length && <div className="text-xs text-gray-500">Converse comigo e vou sugerir ofertas para você!</div>}
            <div className="grid gap-3">
              {recommended.slice(0,3).map((p)=>(
                <div key={p.id} className="p-3 rounded-xl border hover:shadow-sm transition">
                  <div className="font-medium truncate mb-1">{p.title}</div>
                  <div className="text-xs text-gray-500 mb-2">{p.category || '—'} {p.score!==undefined ? `• score ${p.score}` : ''}</div>
                  <div className="text-sm">{p.price?.USD ? <>USD <b>{p.price.USD}</b></> : <span className="text-gray-400">sem preço</span>}</div>
                </div>
              ))}
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}

/** Feed abaixo (importa aqui para ficar plug-and-play) */
function ResultsFeed({ items }: { items: Product[] }){
  if (!items?.length) {
    return (
      <div className="rounded-2xl border bg-white/80 backdrop-blur p-4 shadow-sm">
        <div className="text-sm text-gray-500">Os resultados completos aparecerão aqui conforme você digitar.</div>
      </div>
    );
  }
  return (
    <div className="rounded-2xl border bg-white/80 backdrop-blur p-4 shadow-sm">
      <div className="text-sm font-semibold mb-3">Resultados</div>
      <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-3">
        {items.map(p=>(
          <div key={p.id} className="p-3 rounded-xl border hover:shadow-sm transition">
            <div className="font-medium truncate mb-1">{p.title}</div>
            <div className="text-xs text-gray-500 mb-2">{p.category || '—'} {p.score!==undefined ? `• score ${p.score}` : ''}</div>
            <div className="text-sm">{p.price?.USD ? <>USD <b>{p.price.USD}</b></> : <span className="text-gray-400">sem preço</span>}</div>
          </div>
        ))}
      </div>
    </div>
  );
}

=====================================

2. FRONTEND - HOOK DE CHAT
===========================

arquivo: client/src/hooks/use-assistant-chat.ts
------------------------------------------------

import { useState, useCallback, useRef, useEffect } from 'react';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { apiRequest } from '@/lib/queryClient';

export interface AssistantMessage {
  id: string;
  role: 'user' | 'assistant';
  content: string;
  timestamp: Date;
  isStreaming?: boolean;
}

export interface AssistantSession {
  id: string;
  userId?: string;
  title: string;
  createdAt: Date;
  updatedAt: Date;
}

export interface UseAssistantChatProps {
  sessionId?: string;
  autoCreateSession?: boolean;
}

export function useAssistantChat({ 
  sessionId: initialSessionId, 
  autoCreateSession = true 
}: UseAssistantChatProps = {}) {
  const queryClient = useQueryClient();
  const [sessionId, setSessionId] = useState<string | undefined>(initialSessionId);
  const [messages, setMessages] = useState<AssistantMessage[]>([]);
  const [isStreaming, setIsStreaming] = useState(false);
  const [personalizedGreeting, setPersonalizedGreeting] = useState<string>('');
  const [recommended, setRecommended] = useState<any[]>([]);
  const [feed, setFeed] = useState<any[]>([]);
  const abortControllerRef = useRef<AbortController | null>(null);

  // Get or create session
  const sessionQuery = useQuery({
    queryKey: ['assistant', 'session', sessionId],
    queryFn: async () => {
      if (sessionId) {
        const response = await fetch(`/api/assistant/sessions/${sessionId}`);
        if (response.ok) {
          return await response.json();
        }
      }
      
      if (autoCreateSession) {
        const response = await apiRequest('POST', '/api/assistant/sessions', {});
        const data = await response.json();
        // Handle both shapes: { session: { id } } or { id }
        const session = data.session || data;
        
        // PATCH B: Saudação entra como 1ª mensagem
        if (data.greeting) {
          setMessages(prev => [
            { id: `greet-${Date.now()}`, role: 'assistant', content: data.greeting, timestamp: new Date() },
            ...prev,
          ]);
        }
        
        setSessionId(session.id);

        // PATCH C: Produtos recomendados ao criar sessão
        try {
          const s = await fetch('/suggest?q=trending').then(r=>r.json());
          setRecommended((s.products || []).slice(0,3));     // coluna da direita (até 3)
          setFeed((s.products || []).slice(3));              // lista abaixo do card/chat
        } catch (error) {
          console.warn('Erro ao buscar produtos recomendados:', error);
        }
        
        return session;
      }
      
      return null;
    },
    enabled: autoCreateSession || !!sessionId,
    staleTime: 1000 * 60 * 5, // 5 minutes
  });

  // Load session with messages
  const messagesQuery = useQuery({
    queryKey: ['assistant', 'messages', sessionId],
    queryFn: async () => {
      if (!sessionId) return { messages: [] };
      const response = await fetch(`/api/assistant/sessions/${sessionId}`);
      const data = await response.json();
      // Return the session data which includes messages array
      return data;
    },
    enabled: !!sessionId,
  });

  // Update messages when query data changes
  useEffect(() => {
    if (messagesQuery.data?.messages) {
      setMessages(messagesQuery.data.messages.map((msg: any) => ({
        ...msg,
        timestamp: new Date(msg.timestamp || msg.createdAt)
      })));
    }
  }, [messagesQuery.data]);

  // Send message mutation
  const sendMessageMutation = useMutation({
    mutationFn: async (content: string) => {
      if (!sessionId) throw new Error('No active session');

      // Add user message immediately to UI
      const userMessage: AssistantMessage = {
        id: `temp-user-${Date.now()}`,
        role: 'user',
        content,
        timestamp: new Date(),
      };
      
      setMessages(prev => [...prev, userMessage]);

      // Create assistant message placeholder for streaming
      const assistantMessage: AssistantMessage = {
        id: `temp-assistant-${Date.now()}`,
        role: 'assistant',
        content: '',
        timestamp: new Date(),
        isStreaming: true,
      };
      
      setMessages(prev => [...prev, assistantMessage]);
      setIsStreaming(true);

      // PATCH A: Stream compatível com POST /api/assistant/stream
      abortControllerRef.current = new AbortController();
      
      const response = await fetch('/api/assistant/stream', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'text/event-stream',
        },
        body: JSON.stringify({ sessionId, message: content, context: null }),
        signal: abortControllerRef.current.signal,
      });

      if (!response.ok || !response.body) throw new Error('Falha no streaming');

      const reader = response.body.getReader();
      const decoder = new TextDecoder();
      let buffer = '';
      let full = '';

      try {
        while (true) {
          const { value, done } = await reader.read();
          if (done) break;
          buffer += decoder.decode(value, { stream: true });

          // eventos SSE chegam como linhas "data: {...}\n\n"
          const parts = buffer.split('\n\n');
          buffer = parts.pop() || '';

          for (const chunk of parts) {
            const line = chunk.trim().replace(/^data:\s?/, '');
            try {
              const payload = JSON.parse(line);
              if (payload.type === 'chunk' && payload.text) {
                full += payload.text;
                // atualize a última mensagem do assistente na UI aqui
                setMessages((prev) => {
                  const copy = [...prev];
                  const last = copy[copy.length - 1];
                  if (last?.role === 'assistant') {
                    copy[copy.length - 1] = { ...last, content: (last.content || '') + payload.text };
                  }
                  return copy;
                });
              }
              if (payload.type === 'complete') {
                setIsStreaming(false);
                setMessages(prev => prev.map(msg => 
                  msg.id === assistantMessage.id 
                    ? { ...msg, isStreaming: false }
                    : msg
                ));
              }
            } catch {}
          }
        }
      } finally {
        reader.releaseLock();
        setIsStreaming(false);
      }
    },
    onSuccess: () => {
      // Invalidate messages to get the final server state
      queryClient.invalidateQueries({ queryKey: ['assistant', 'messages', sessionId] });
    },
    onError: (error) => {
      console.error('Error sending message:', error);
      setIsStreaming(false);
      // Remove the last two messages (user and assistant messages that failed)
      setMessages(prev => prev.slice(0, -2));
    }
  });

  // Cancel streaming
  const cancelStreaming = useCallback(() => {
    if (abortControllerRef.current) {
      abortControllerRef.current.abort();
      setIsStreaming(false);
      // Clean up any streaming message
      setMessages(prev => prev.map(msg => 
        msg.isStreaming ? { ...msg, isStreaming: false } : msg
      ));
    }
  }, []);

  // Clear messages
  const clearMessages = useCallback(() => {
    setMessages([]);
    if (sessionId) {
      queryClient.invalidateQueries({ queryKey: ['assistant', 'messages', sessionId] });
    }
  }, [sessionId, queryClient]);

  // Send message
  const sendMessage = useCallback((content: string) => {
    if (!content.trim() || isStreaming || !sessionId) return;
    sendMessageMutation.mutate(content.trim());
  }, [sendMessageMutation, isStreaming, sessionId]);

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      if (abortControllerRef.current) {
        abortControllerRef.current.abort();
      }
    };
  }, []);

  return {
    // Session
    session: sessionQuery.data,
    sessionId,
    sessionLoading: sessionQuery.isLoading,
    sessionError: sessionQuery.error,

    // Messages
    messages,
    messagesLoading: messagesQuery.isLoading,
    messagesError: messagesQuery.error,

    // Actions
    sendMessage,
    cancelStreaming,
    clearMessages,

    // State
    isStreaming,
    isSending: sendMessageMutation.isPending,
    sendError: sendMessageMutation.error,
    
    // Personalization
    personalizedGreeting,
    
    // Products
    recommended,
    feed,
    
    // Ready state
    isReady: !!sessionId && !sessionQuery.isLoading,
  };
}

=====================================

3. PÁGINA DE TESTE
==================

arquivo: client/src/pages/test-inline-assistant.tsx
---------------------------------------------------

import InlineAssistant from '@/components/InlineAssistant';

export default function TestInlineAssistant() {
  return (
    <div className="max-w-7xl mx-auto p-4">
      <h1 className="text-2xl font-bold mb-6">Teste do Inline Assistant</h1>
      <InlineAssistant />
    </div>
  );
}

=====================================

4. BACKEND - MEMORY SERVICE
============================

arquivo: server/memoryService.ts
--------------------------------

import { db } from "./db";
import { userMemory, type UserMemory, type InsertUserMemory, type UpdateUserMemory } from "@shared/schema";
import { eq } from "drizzle-orm";
import OpenAI from 'openai';

// Initialize OpenAI client for memory summarization
const client = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });
const CHAT_MODEL = process.env.CHAT_MODEL || 'gpt-4o-mini';

export class MemoryService {
  
  /**
   * Busca ou cria memória vazia para o usuário
   */
  static async getUserMemory(userId: string, name?: string): Promise<UserMemory> {
    try {
      // Procura memória existente
      const existingMemory = await db
        .select()
        .from(userMemory)
        .where(eq(userMemory.userId, userId))
        .limit(1);

      if (existingMemory.length > 0) {
        // Atualiza último acesso
        await db
          .update(userMemory)
          .set({
            lastSeen: new Date(),
            updatedAt: new Date(),
          })
          .where(eq(userMemory.userId, userId));

        return existingMemory[0];
      }

      // Cria nova memória se não existir
      const newMemoryData: InsertUserMemory = {
        userId,
        profile: {
          name: name || '',
          preferredCity: '',
        },
        preferences: {},
        history: {
          lastIntent: '',
          lastCategories: [],
          lastProducts: [],
          lastStores: [],
          recentSearches: [],
          commonSearchTerms: [],
        },
        greetingHistory: [],
        lastSummary: null,
        visitCount: 1,
        messageCount: 0,
        lastSeen: new Date(),
      };

      const result = await db
        .insert(userMemory)
        .values([newMemoryData])
        .returning();

      return result[0];
    } catch (error) {
      console.error('Error getting/creating user memory:', error);
      // Return default memory structure in case of error
      return {
        id: '',
        userId,
        profile: { name: name || '', preferredCity: '' },
        preferences: {},
        history: {
          lastIntent: '',
          lastCategories: [],
          lastProducts: [],
          lastStores: [],
          recentSearches: [],
          commonSearchTerms: [],
        },
        greetingHistory: [],
        lastSummary: null,
        visitCount: 1,
        messageCount: 0,
        lastSeen: new Date(),
        createdAt: new Date(),
        updatedAt: new Date(),
      };
    }
  }

  /**
   * Atualiza memória do usuário
   */
  static async updateUserMemory(userId: string, updates: Partial<UpdateUserMemory>): Promise<void> {
    try {
      const updateData: any = {
        ...updates,
        updatedAt: new Date(),
      };
      
      await db
        .update(userMemory)
        .set(updateData)
        .where(eq(userMemory.userId, userId));
    } catch (error) {
      console.error('Error updating user memory:', error);
    }
  }

  /**
   * Extrai sinais de categorias e preferências do texto
   */
  static extractSignals(message: string): {
    categories: string[];
    preferredCity: 'Ciudad del Este' | 'Salto del Guairá' | 'Pedro Juan Caballero' | '';
    budget?: 'baixo' | 'medio' | 'alto';
    brands: string[];
  } {
    const text = message.toLowerCase();
    const categories: string[] = [];
    const brands: string[] = [];

    // Detectar categorias
    if (/(iphone|samsung|galaxy|xiaomi|smartphone|celular|phone)/.test(text)) {
      categories.push('eletronicos');
    }
    if (/(fone|headphone|jbl|sony|audio|soundbar|earphone)/.test(text)) {
      categories.push('audio');
    }
    if (/(perfume|parfum|cosm[eé]tico|fragr[aâ]ncia)/.test(text)) {
      categories.push('perfumes');
    }
    if (/(notebook|laptop|computer|pc|mouse|teclado)/.test(text)) {
      categories.push('informatica');
    }
    if (/(rel[oó]gio|watch|smartwatch)/.test(text)) {
      categories.push('relogios');
    }
    if (/(roupa|blusa|camisa|cal[cç]a|vestido|shorts)/.test(text)) {
      categories.push('roupas');
    }

    // Detectar cidade
    let preferredCity: 'Ciudad del Este' | 'Salto del Guairá' | 'Pedro Juan Caballero' | '' = '';
    if (/salto/i.test(text)) {
      preferredCity = 'Salto del Guairá';
    } else if (/pedro\s*juan/i.test(text)) {
      preferredCity = 'Pedro Juan Caballero';
    } else if (/cde|ciudad\s*del\s*este/i.test(text)) {
      preferredCity = 'Ciudad del Este';
    }

    // Detectar orçamento
    let budget: 'baixo' | 'medio' | 'alto' | undefined;
    if (/(barato|econômico|low\s*cost|preço\s*baixo|mais\s*barato)/.test(text)) {
      budget = 'baixo';
    } else if (/(premium|top|melhor\s*qualidade|importado|original)/.test(text)) {
      budget = 'alto';
    } else if (/(custo\s*benefício|intermediário|médio|medio)/.test(text)) {
      budget = 'medio';
    }

    // Detectar marcas
    if (/(apple|iphone|ipad|macbook)/.test(text)) brands.push('Apple');
    if (/(samsung|galaxy)/.test(text)) brands.push('Samsung');
    if (/(xiaomi|redmi)/.test(text)) brands.push('Xiaomi');
    if (/(sony)/.test(text)) brands.push('Sony');
    if (/(jbl)/.test(text)) brands.push('JBL');
    if (/(nike)/.test(text)) brands.push('Nike');
    if (/(adidas)/.test(text)) brands.push('Adidas');

    return { categories, preferredCity, budget, brands };
  }

  /**
   * Cria resumo da conversa para memória
   */
  static async summarizeForMemory(input: {
    message: string;
    reply: string;
    name?: string;
  }): Promise<string> {
    try {
      const prompt = `
Resuma a conversa abaixo em até 2 linhas, focando intenção e preferências (cidade/orçamento/categorias).
PT-BR, direto e objetivo.

Usuário: ${input.name || 'Cliente'}
Pergunta: ${input.message}
Resposta do Click: ${input.reply}

Resumo:`;

      const response = await client.chat.completions.create({
        model: CHAT_MODEL,
        messages: [{ role: 'user', content: prompt }],
        temperature: 0.1,
        max_tokens: 80,
      });

      return response.choices[0].message.content || '';
    } catch (error) {
      console.error('Error creating memory summary:', error);
      return `${input.name || 'Cliente'} buscou informações sobre: ${input.message.slice(0, 50)}...`;
    }
  }

  /**
   * Determina período do dia
   */
  static getTimeOfDay(date = new Date()): 'manhã' | 'tarde' | 'noite' {
    const hour = date.getHours();
    if (hour < 12) return 'manhã';
    if (hour < 18) return 'tarde';
    return 'noite';
  }

  /**
   * Templates de saudação
   */
  static readonly GREETING_TEMPLATES = [
    (ctx: { name: string; period: string; city?: string; visits: number }) =>
      `Olá, ${ctx.name}! Boa ${ctx.period}${ctx.city ? ` em ${ctx.city}` : ''} 👋`,
    
    (ctx: { name: string; period: string }) =>
      `Oi, ${ctx.name}! Tudo certo por aí nessa ${ctx.period}?`,
    
    (ctx: { name: string; city?: string }) =>
      `Bem-vindo de volta, ${ctx.name}! ${ctx.city ? `Vamos explorar ${ctx.city} hoje?` : 'Pronto pra achar boas ofertas?'}`,
    
    (ctx: { name: string }) =>
      `E aí, ${ctx.name}! Posso te mostrar as melhores ofertas de hoje?`,
    
    (ctx: { name: string; city?: string }) =>
      `Que bom te ver, ${ctx.name}! ${ctx.city ? `Tenho novidades de ${ctx.city}.` : 'Tenho novidades fresquinhas.'} ✨`,
    
    (ctx: { name: string; visits: number }) =>
      `Olá novamente, ${ctx.name}! ${ctx.visits > 5 ? 'Já virando cliente VIP por aqui! 🌟' : 'Como posso ajudar hoje?'}`,
    
    (ctx: { name: string; period: string }) =>
      `${ctx.period === 'manhã' ? 'Bom dia' : ctx.period === 'tarde' ? 'Boa tarde' : 'Boa noite'}, ${ctx.name}! Pronto para descobrir ofertas incríveis?`,
  ];

  /**
   * Gera saudação natural e não repetitiva
   */
  static makeNaturalGreeting(memory: UserMemory): {
    text: string;
    nextHistory: number[];
    nextCounters: { visitCount: number; messageCount: number };
  } {
    const name = memory.profile?.name || 'Cliente';
    const period = this.getTimeOfDay();
    const city = memory.profile?.preferredCity || '';
    const visitCount = (memory.visitCount || 0) + 1;
    
    // Evita repetir os últimos 3 templates usados
    const recentlyUsed = new Set((memory.greetingHistory || []).slice(-3));
    
    // Encontra o primeiro template não usado recentemente
    let templateIndex = 0;
    for (let i = 0; i < this.GREETING_TEMPLATES.length; i++) {
      if (!recentlyUsed.has(i)) {
        templateIndex = i;
        break;
      }
    }

    // Gera a saudação
    const template = this.GREETING_TEMPLATES[templateIndex];
    const text = template({
      name,
      period,
      city: city || undefined,
      visits: visitCount,
    });

    // Atualiza histórico de saudações (mantém apenas os últimos 8)
    const nextHistory = [...(memory.greetingHistory || []), templateIndex].slice(-8);
    
    // Atualiza contadores
    const nextCounters = {
      visitCount,
      messageCount: memory.messageCount || 0,
    };

    return {
      text,
      nextHistory,
      nextCounters,
    };
  }

  /**
   * Atualiza histórico de atividades
   */
  static async updateHistory(
    userId: string,
    message: string,
    reply: string,
    extractedSignals?: ReturnType<typeof MemoryService.extractSignals>
  ): Promise<void> {
    try {
      const memory = await this.getUserMemory(userId);
      const signals = extractedSignals || this.extractSignals(message);

      // Atualiza histórico
      const updatedHistory = {
        ...memory.history,
        lastIntent: message.slice(0, 100),
        lastCategories: signals.categories.length > 0 ? signals.categories : memory.history?.lastCategories,
        recentSearches: [
          message,
          ...(memory.history?.recentSearches || []).slice(0, 9)
        ].slice(0, 10),
      };

      // Atualiza preferências se detectadas
      const updatedPreferences = {
        ...memory.preferences,
        ...(signals.budget && { budget: signals.budget }),
        ...(signals.categories.length > 0 && {
          favoriteCategories: [
            ...signals.categories,
            ...(memory.preferences?.favoriteCategories || [])
          ].slice(0, 10)
        }),
        ...(signals.brands.length > 0 && {
          favoriteBrands: [
            ...signals.brands,
            ...(memory.preferences?.favoriteBrands || [])
          ].slice(0, 10)
        }),
      };

      // Atualiza perfil se cidade detectada
      const updatedProfile = {
        ...memory.profile,
        ...(signals.preferredCity && { preferredCity: signals.preferredCity }),
      };

      // Cria resumo da conversa
      const summary = await this.summarizeForMemory({
        message,
        reply,
        name: memory.profile?.name,
      });

      // Salva tudo
      await this.updateUserMemory(userId, {
        history: updatedHistory,
        preferences: updatedPreferences,
        profile: updatedProfile,
        lastSummary: summary,
        messageCount: (memory.messageCount || 0) + 1,
      });

    } catch (error) {
      console.error('Error updating history:', error);
    }
  }
}

=====================================

5. BACKEND - ENDPOINTS PRINCIPALES
==================================

arquivo: server/routes.ts (SEÇÕES RELEVANTES)
---------------------------------------------

  // =============================================
  // ASSISTANT API - CONVERSATIONAL SHOPPING ASSISTANT
  // =============================================

  // Create new assistant session
  app.post('/api/assistant/sessions', async (req: any, res) => {
    try {
      const user = req.user || req.session?.user;
      const { topic, context } = req.body;
      
      // Get user info for personalization
      const userId = user?.id || 'anonymous';
      const userName = user?.firstName || user?.fullName || user?.email?.split('@')[0] || '';

      // Validate input using schema
      const sessionData = {
        userId: user?.id || null,
        sessionData: { topic: topic || 'general', context: context || null },
        isActive: true,
      };

      const session = await storage.createAssistantSession(sessionData);

      // Generate personalized greeting using memory service
      let greeting = "Olá! Como posso ajudar você hoje? 😊";
      
      try {
        const memory = await MemoryService.getUserMemory(userId, userName);
        const greetingData = MemoryService.makeNaturalGreeting(memory);
        greeting = greetingData.text;

        // Update memory with new visit and greeting history
        await MemoryService.updateUserMemory(userId, {
          greetingHistory: greetingData.nextHistory,
          visitCount: greetingData.nextCounters.visitCount,
        });
      } catch (error) {
        console.error('Error getting/creating user memory:', error);
      }

      res.json({ 
        success: true, 
        session,
        greeting // Include personalized greeting in response
      });
    } catch (error) {
      console.error('Error creating assistant session:', error);
      res.status(500).json({ success: false, message: 'Failed to create session' });
    }
  });

  // SSE Streaming endpoint for assistant chat
  app.post('/api/assistant/stream', async (req: any, res) => {
    try {
      const { sessionId, message, context } = req.body;
      const user = req.user || req.session?.user;

      // Validate input
      if (!message || typeof message !== 'string' || message.trim().length === 0) {
        return res.status(400).json({ success: false, message: 'Message is required' });
      }

      if (message.length > 2000) {
        return res.status(400).json({ success: false, message: 'Message too long' });
      }

      // Validate session and ownership
      const session = await storage.getAssistantSession(sessionId);
      if (!session) {
        return res.status(404).json({ success: false, message: 'Session not found' });
      }

      // Check ownership
      if (session.userId && session.userId !== user?.id) {
        return res.status(403).json({ success: false, message: 'Access denied' });
      }

      // Setup SSE headers
      res.writeHead(200, {
        'Content-Type': 'text/event-stream',
        'Cache-Control': 'no-cache',
        'Connection': 'keep-alive',
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Headers': 'Cache-Control'
      });

      // SSE helper functions
      const writeSSE = (data: any) => {
        res.write(`data: ${JSON.stringify(data)}\n\n`);
      };

      // Save user message
      await storage.createAssistantMessage({
        sessionId,
        content: message,
        role: 'user',
        metadata: context || null,
      });

      // Get recent conversation context
      const recentMessages = await storage.getAssistantMessages(sessionId, 10);
      
      // Create context for Click Pro IA
      const conversationContext = recentMessages
        .slice(-6) // Last 6 messages for context
        .map(msg => `${msg.role}: ${msg.content}`)
        .join('\n');

      // PATCH D: Texto curto (sem enrolação)
      const STYLE_GUIDE = `
- Máx. 5 linhas.
- Frases curtas. Sem floreio.
- No máx. 3 bullets: "• item — detalhe".
- Uma única pergunta no final (se necessário).
- Não repita o que já disse.
`.trim();

      const systemPrompt = `
Você é o Click Pro Assistant para CDE/Salto/Pedro Juan.
Seja direto e objetivo, PT-BR, sem inventar preços/estoques.
`.trim();

      const messages = [
        { role: 'system' as const, content: systemPrompt },
        { role: 'system' as const, content: STYLE_GUIDE },
        { role: 'user' as const, content: message }
      ];

      // Send initial metadata
      writeSSE({ 
        type: 'start', 
        sessionId,
        timestamp: new Date().toISOString()
      });

      // Create streaming completion
      const stream = await clickClient.chat.completions.create({
        model: CHAT_MODEL,
        messages,
        temperature: 0.2,
        max_tokens: 220,
        frequency_penalty: 0.4,
        presence_penalty: 0.1,
        stream: true,
      });

      // soft-cut (corta textão se vier)
      let fullResponse = '';
      const SOFT_LIMIT = 700;
      for await (const part of stream) {
        const delta = part.choices?.[0]?.delta?.content || '';
        if (!delta) continue;
        const over = fullResponse.length + delta.length - SOFT_LIMIT;
        const piece = over > 0 ? delta.slice(0, delta.length - over) : delta;
        fullResponse += piece;
        writeSSE({ type: 'chunk', text: piece, timestamp: new Date().toISOString() });
        if (over > 0) break;
      }

      // Send completion signal
      writeSSE({
        type: 'complete',
        fullText: fullResponse,
        timestamp: new Date().toISOString()
      });

      // Save assistant response to database
      await storage.createAssistantMessage({
        sessionId,
        content: fullResponse,
        role: 'assistant',
        metadata: { 
          model: CHAT_MODEL,
          context: context || null,
          timestamp: new Date().toISOString(),
          streamed: true
        },
      });

      // Update user memory with conversation history
      try {
        const userId = user?.id || 'anonymous';
        await MemoryService.updateHistory(userId, message, fullResponse);
      } catch (memoryError) {
        console.error('Error updating user memory:', memoryError);
        // Continue execution, memory update is not critical
      }

      // Send final message and close connection
      writeSSE({ type: 'end' });
      res.end();

    } catch (error) {
      console.error('Error in assistant streaming:', error);
      res.write(`data: ${JSON.stringify({ 
        type: 'error', 
        message: 'Erro no streaming. Tente novamente.',
        timestamp: new Date().toISOString()
      })}\n\n`);
      res.end();
    }
  });

  // GET /suggest - Product suggestions endpoint
  app.get('/suggest', async (req: any, res) => {
    try {
      const { q } = req.query;
      const userId = req.headers['x-user-id'] || 'anonymous';

      if (!q || !q.trim()) {
        return res.json({ ok: true, products: [], topStores: [] });
      }

      const searchTerm = q.toLowerCase();
      
      // Get stores and products
      const storesWithProducts = await storage.getAllActiveStoresOptimized(10, 20);
      
      let allProducts: any[] = [];
      let topStores: any[] = [];

      storesWithProducts.forEach(store => {
        topStores.push({
          id: store.id,
          name: store.name,
          label: store.name,
          mall: store.address || ''
        });

        store.products.forEach(product => {
          // Filter by search term
          if (product.name.toLowerCase().includes(searchTerm) ||
              product.description?.toLowerCase().includes(searchTerm) ||
              product.category?.toLowerCase().includes(searchTerm)) {
            allProducts.push({
              id: product.id,
              title: product.name,
              category: product.category,
              price: { USD: parseFloat(product.price) || 0 },
              score: Math.random() * 100,
              storeId: store.id
            });
          }
        });
      });

      // Sort by relevance (mock scoring)
      allProducts.sort((a, b) => b.score - a.score);

      res.json({
        ok: true,
        category: 'busca',
        topStores: topStores.slice(0, 5),
        products: allProducts.slice(0, 20)
      });

    } catch (error) {
      console.error('Error in /suggest endpoint:', error);
      res.status(500).json({ ok: false, message: 'Internal server error' });
    }
  });

=====================================

6. SCHEMA - TABELA USER_MEMORY
==============================

arquivo: shared/schema.ts (SEÇÃO USER_MEMORY)
---------------------------------------------

export const userMemory = pgTable("user_memory", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  userId: varchar("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
  
  // Perfil do usuário
  profile: jsonb("profile").$type<{
    name?: string;
    preferredCity?: 'Ciudad del Este' | 'Salto del Guairá' | 'Pedro Juan Caballero' | '';
    lastGreeting?: string;
  }>().default({}),
  
  // Preferências de compra
  preferences: jsonb("preferences").$type<{
    budget?: 'baixo' | 'medio' | 'alto';
    mode?: 'a-pe' | 'app' | 'carro';
    favoriteCategories?: string[];
    favoriteBrands?: string[];
  }>().default({}),
  
  // Histórico de atividades
  history: jsonb("history").$type<{
    lastIntent?: string;
    lastCategories?: string[];
    lastProducts?: string[];
    lastStores?: string[];
    recentSearches?: string[];
    commonSearchTerms?: string[];
  }>().default({}),
  
  // Controle de saudações (para evitar repetição)
  greetingHistory: jsonb("greeting_history").$type<number[]>().default([]),
  
  // Resumo da última conversa para contexto
  lastSummary: text("last_summary"),
  
  // Contadores
  visitCount: integer("visit_count").default(1),
  messageCount: integer("message_count").default(0),
  
  // Timestamps
  lastSeen: timestamp("last_seen").defaultNow(),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
}, (table) => [
  index("idx_user_memory_user").on(table.userId),
  index("idx_user_memory_last_seen").on(table.lastSeen),
  unique("unique_user_memory").on(table.userId), // Uma memória por usuário
]);

export const userMemoryRelations = relations(userMemory, ({ one }) => ({
  user: one(users, {
    fields: [userMemory.userId],
    references: [users.id],
  }),
}));

export const insertUserMemorySchema = createInsertSchema(userMemory).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export const updateUserMemorySchema = insertUserMemorySchema.partial().omit({
  userId: true,
});

export type UserMemory = typeof userMemory.$inferSelect;
export type InsertUserMemory = z.infer<typeof insertUserMemorySchema>;
export type UpdateUserMemory = z.infer<typeof updateUserMemorySchema>;

=====================================

7. INSTALAÇÃO DO BANCO
======================

SQL commands executados para criar a tabela:

-- Criar tabela user_memory
CREATE TABLE IF NOT EXISTS user_memory (
  id VARCHAR PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id VARCHAR NOT NULL,
  profile JSONB,
  recent_searches TEXT[] DEFAULT '{}',
  recent_categories TEXT[] DEFAULT '{}',
  preferred_stores TEXT[] DEFAULT '{}',
  price_range_min DECIMAL(10,2),
  price_range_max DECIMAL(10,2),
  preferred_currency VARCHAR(10),
  interaction_count INTEGER DEFAULT 0,
  last_product_viewed VARCHAR,
  favorite_categories TEXT[] DEFAULT '{}',
  typical_shopping_time VARCHAR,
  last_seen TIMESTAMP DEFAULT NOW(),
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

-- Criar índices
CREATE INDEX IF NOT EXISTS idx_user_memory_user ON user_memory(user_id);
CREATE INDEX IF NOT EXISTS idx_user_memory_last_seen ON user_memory(last_seen);
ALTER TABLE user_memory ADD CONSTRAINT unique_user_memory UNIQUE(user_id);

-- Adicionar coluna profile JSONB (se não existir)
ALTER TABLE user_memory ADD COLUMN profile JSONB;

=====================================

RESUMO DOS PATCHES APLICADOS
============================

✅ PATCH A: Stream com POST /api/assistant/stream + ReadableStream
✅ PATCH B: Saudação injetada como primeira mensagem
✅ PATCH C: Produtos recomendados ao criar sessão (/suggest?q=trending)  
✅ PATCH D: Prompt curto no backend (max_tokens: 220, soft-cut em 700 chars)
✅ PATCH E: Layout do chat embutido (já implementado)

INSTRUÇÕES DE USO
================

1. Acesse /test-inline-assistant para testar
2. O componente InlineAssistant pode ser usado em qualquer página
3. Sistema de memória persistente ativo
4. Saudações personalizadas e não repetitivas
5. Produtos recomendados aparecem automaticamente
6. Chat funcional com streaming em tempo real

FUNCIONALIDADES PRINCIPAIS
==========================

- Barra de busca inteligente com expansão suave
- Chat embutido no mesmo card (altura limitada + scroll)  
- Coluna à direita com até 3 produtos recomendados
- Feed de resultados completos abaixo do chat
- Sistema de memória de usuário persistente
- Saudações personalizadas não repetitivas
- Streaming de respostas em tempo real
- Respostas curtas e objetivas (máx. 5 linhas)
- Integração com sistema de produtos do Click Ofertas

=====================================

ESTRUTURA DE ARQUIVOS
=====================

Frontend:
- client/src/components/InlineAssistant.tsx
- client/src/hooks/use-assistant-chat.ts  
- client/src/pages/test-inline-assistant.tsx

Backend:
- server/memoryService.ts
- server/routes.ts (endpoints /api/assistant/*)
- shared/schema.ts (tabela userMemory)

Banco de dados:
- Tabela user_memory com índices e constraints

=====================================

Este é o código completo e funcional do Click Assistant!