=====================================
ARQUIVO ASSISTANTBAR.TSX - AN√ÅLISE COMPLETA
GERADO EM: 26/09/2025 - 19:32
=====================================

LOGS DO BACKEND MOSTRAM:
‚úÖ Backend funcionando PERFEITAMENTE
‚úÖ Resposta concisa: "Aqui est√£o as melhores op√ß√µes de iPhone que encontrei!" (95 chars)
‚úÖ Enviando 3 produtos do Clique via SSE
‚úÖ JSON estruturado funcionando

PROBLEMA EST√Å NO FRONTEND - ASSISTANTBAR N√ÉO EST√Å PROCESSANDO CORRETAMENTE

=====================================

import { useState, useEffect, useRef, useMemo } from 'react';
import { useLocation } from 'wouter';
import { useSuggestions } from '@/hooks/use-suggestions';
import { Search } from 'lucide-react';

// Sess√£o simples por usu√°rio (cache 1h)
const sessionCache = new Map();
const ONE_HOUR = 60 * 60 * 1000;

export default function AssistantBar() {
  console.log('üöÄ [AssistantBar] Componente sendo renderizado/inicializado');
  
  const [, setLocation] = useLocation();
  const uid = useMemo(() => localStorage.getItem('uid') || (localStorage.setItem('uid','u-'+Math.random().toString(36).slice(2,8)), localStorage.getItem('uid')!), []);
  const userName = useMemo(() => localStorage.getItem('userName') || 'Cliente', []);
  
  console.log('üë§ [AssistantBar] UID:', uid, 'UserName:', userName);
  
  const [sessionId, setSessionId] = useState('');
  
  // Manter sessionId atualizado no ref
  useEffect(() => {
    sessionIdRef.current = sessionId;
  }, [sessionId]);

  // Auto-flush pendente quando sess√£o fica dispon√≠vel 
  useEffect(() => {
    if (sessionId && pendingSearchRef.current && !hasTriggeredSearchRef.current) {
      const searchTerm = pendingSearchRef.current;
      const contextualMessage = pendingMessageRef.current;
      
      // Limpar apenas pendingMessageRef (pendingSearchRef precisa ficar para startStream usar)
      pendingMessageRef.current = '';
      hasTriggeredSearchRef.current = false;
      
      // Alinhar estado da UI com onSubmit
      setOpen(false);
      setShowResults(true);
      // üîß N√ÉO LIMPAR produtos aqui - s√≥ limpar no onSubmit para nova busca
      console.log('üîÑ [AssistantBar] Mantendo produtos existentes durante processamento do header');
      
      // Usar mensagem contextual se dispon√≠vel, sen√£o usar termo de busca
      const messageToShow = contextualMessage || searchTerm;
      const messageToStream = contextualMessage || searchTerm;
      
      // Adicionar mensagem do usu√°rio
      setChatMessages(prev => [...prev, { type: 'user', text: messageToShow }]);
      
      // Enviar para IA
      startStream(messageToStream);
    }
  }, [sessionId]);
  const [query, setQuery] = useState('');
  const [open, setOpen] = useState(false);
  const [streaming, setStreaming] = useState('');
  const [greeting, setGreeting] = useState('');
  const [topBox, setTopBox] = useState<any[]>([]);
  const [feed, setFeed] = useState<any[]>([]);
  const [combina, setCombina] = useState<any[]>([]);
  const [loadingSug, setLoadingSug] = useState(false);
  const [chatMessages, setChatMessages] = useState<Array<{type: 'user' | 'assistant', text: string}>>([]);
  const [isTyping, setIsTyping] = useState(false);
  const [showResults, setShowResults] = useState(false);
  const [overlayInput, setOverlayInput] = useState('');
  const readerRef = useRef<ReadableStreamDefaultReader<Uint8Array> | null>(null);
  const bootRef = useRef(false);
  const chatRef = useRef<HTMLFormElement>(null);
  const chatScrollRef = useRef<HTMLDivElement>(null);
  const hasTriggeredSearchRef = useRef(false);
  const pendingSearchRef = useRef('');
  const pendingMessageRef = useRef(''); // Para armazenar mensagem contextual quando sess√£o n√£o est√° pronta
  const [headerTriggered, setHeaderTriggered] = useState(false);
  const sessionIdRef = useRef('');
  const lastHeaderQueryRef = useRef('');
  const lastHeaderSubmitTime = useRef(0);

  // Estados para anima√ß√µes da barra de busca
  const [displayText, setDisplayText] = useState('');
  const [isSearchFocused, setIsSearchFocused] = useState(false);
  const animationRef = useRef<ReturnType<typeof setTimeout> | null>(null);
  
  // Estados para sugest√µes de autocomplete
  const [showSuggestions, setShowSuggestions] = useState(false);
  const { suggestions, isLoading: suggestionsLoading, hasResults } = useSuggestions(query, {
    enabled: showSuggestions && !open, // S√≥ buscar se n√£o est√° aberto o dropdown principal
    minLength: 2,
    debounceDelay: 300
  });
  
  // Event listeners para integra√ß√£o com header
  useEffect(() => {
    console.log('üéß [AssistantBar] Registrando event listeners');
    
    const handleHeaderFocus = (e: CustomEvent) => {
      console.log('üéØ [AssistantBar] Header focus event received:', e.detail);
      if (e.detail?.source === 'header') {
        setOpen(true);
        setShowResults(true);
        setHeaderTriggered(true);
        if (e.detail.query) {
          setOverlayInput(e.detail.query);
        }
      }
    };

    const handleHeaderSubmit = (e: CustomEvent) => {
      console.log('üì§ [AssistantBar] Header submit event received:', e.detail);
      if (e.detail?.query && e.detail?.source === 'header') {
        const query = e.detail.query.trim();
        
        // Throttling: evitar submissions duplicadas muito pr√≥ximas
        const now = Date.now();
        if (lastHeaderQueryRef.current === query && (now - lastHeaderSubmitTime.current) < 2000) {
          console.log('üîÑ [AssistantBar] Submission throttled (duplicada):', query);
          return;
        }
        
        lastHeaderQueryRef.current = query;
        lastHeaderSubmitTime.current = now;
        
        // Se session ainda n√£o est√° pronta, guardar a mensagem 
        if (!sessionId) {
          console.log('‚è∞ [AssistantBar] Sess√£o n√£o pronta - agendando busca:', query);
          pendingSearchRef.current = query;
          pendingMessageRef.current = e.detail.contextualMessage || '';
          return;
        }
        
        // Session est√° pronta - processar imediatamente
        handleSearchSubmission(query, e.detail.contextualMessage);
      }
    };
    
    const handleSearchSubmission = (searchQuery: string, contextualMessage?: string) => {
      console.log('üîç [AssistantBar] Processando submission:', { searchQuery, contextualMessage });
      
      setOpen(false);
      setShowResults(true);
      setHeaderTriggered(true);
      setOverlayInput(searchQuery);
      
      // Decidir qual mensagem mostrar no chat
      const messageToShow = contextualMessage || searchQuery;
      
      // Adicionar mensagem do usu√°rio ao chat
      setChatMessages(prev => [...prev, { type: 'user', text: messageToShow }]);
      
      // Iniciar stream da IA (sempre com a query original para busca)
      startStream(searchQuery);
    };

    document.addEventListener('headerFocus', handleHeaderFocus as EventListener);
    document.addEventListener('headerSubmit', handleHeaderSubmit as EventListener);
    
    return () => {
      console.log('üßπ [AssistantBar] Removendo event listeners');
      document.removeEventListener('headerFocus', handleHeaderFocus as EventListener);
      document.removeEventListener('headerSubmit', handleHeaderSubmit as EventListener);
    };
  }, [sessionId]); // Recriar listeners quando sessionId muda

  // Inicializar sessionId
  useEffect(() => {
    if (bootRef.current) return;
    bootRef.current = true;
    
    const initSession = async () => {
      try {
        const res = await fetch('/api/assistant/sessions', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'x-user-id': uid,
            'x-user-name': userName
          }
        });
        const data = await res.json();
        setSessionId(data.sessionId);
        
        // Buscar frases engra√ßadas (sem aguardar)
        fetch('/api/assistant/funny-phrases')
          .then(r => r.json())
          .then(d => {
            if (d.phrases && d.phrases.length > 0) {
              const randomPhrase = d.phrases[Math.floor(Math.random() * d.phrases.length)];
              setDisplayText(randomPhrase);
            }
          })
          .catch(() => setDisplayText('Carregando frases...'));
        
      } catch (e) {
        console.error('Erro ao inicializar sess√£o:', e);
      }
    };
    
    initSession();
  }, [uid, userName]);

  // Anima√ß√£o do texto de placeholder
  useEffect(() => {
    if (!displayText || isSearchFocused || query) return;
    
    const words = displayText.split(' ');
    if (words.length <= 1) return;
    
    let currentWordIndex = 0;
    
    const animateWords = () => {
      if (currentWordIndex < words.length) {
        const wordsToShow = words.slice(0, currentWordIndex + 1);
        setDisplayText(wordsToShow.join(' '));
        currentWordIndex++;
        
        animationRef.current = setTimeout(animateWords, 300);
      } else {
        // Reiniciar anima√ß√£o ap√≥s uma pausa
        animationRef.current = setTimeout(() => {
          currentWordIndex = 0;
          setDisplayText('');
          animateWords();
        }, 2000);
      }
    };
    
    animationRef.current = setTimeout(animateWords, 1000);
    
    return () => {
      if (animationRef.current) {
        clearTimeout(animationRef.current);
        animationRef.current = null;
      }
    };
  }, [displayText, isSearchFocused, query]);

  const onChange = (value: string) => {
    setQuery(value);
    
    // Controlar quando exibir sugest√µes autom√°ticas:
    // 1. H√° valor suficiente (2+ chars)
    // 2. N√£o est√° aberto o dropdown principal  
    // 3. Usu√°rio est√° focado no campo
    setShowSuggestions(!!value && value.length >= 2 && !open && isSearchFocused);
    
    // üîß N√ÉO LIMPAR produtos automaticamente - s√≥ quando nova busca
    // S√≥ limpar sugest√µes se n√£o h√° valor
    if (!value.trim()) {
      setShowSuggestions(false);
      return;
    }
    
    // N√£o chamar fetchSuggest aqui - usar apenas useSuggestions para autocomplete
    // fetchSuggest ser√° chamado apenas no submit ou quando o assistant sinalizar
  };

  const onFocus = () => {
    console.log('üîç onFocus called - opening dropdown');
    setOpen(true);
  };

  const selectSuggestion = (suggestion: string) => {
    setQuery(suggestion);
    setShowSuggestions(false);
    setOpen(false);
    // Submeter automaticamente quando seleciona sugest√£o
    setTimeout(() => {
      if (chatRef.current) {
        chatRef.current.requestSubmit();
      }
    }, 100);
  };

  const fetchSuggest = async (q: string) => {
    if (!q.trim() || loadingSug) return;
    setLoadingSug(true);
    
    try {
      // Buscar sugest√µes principais
      let r = await fetch(`/api/click/suggest?q=${encodeURIComponent(q)}`);
      if (!r.ok) r = await fetch(`/api/suggest?q=${encodeURIComponent(q)}`);
      const d = await r.json();
      const prods = (d?.products || []).slice(0, 8);
      
      // Se poucos produtos, mostrar todos no feed; se muitos, dividir
      if (prods.length <= 6) {
        setTopBox([]);
        setFeed(prods);
      } else {
        setTopBox(prods.slice(0, 3));
        setFeed(prods.slice(3));
      }
      
      // Buscar produtos relacionados/acess√≥rios se h√° produtos principais
      if (prods.length > 0) {
        const accQ = `${q} acessorio pelicula capinha`;
        let r2 = await fetch(`/suggest?q=${encodeURIComponent(accQ)}`);
        if (!r2.ok) r2 = await fetch(`/api/suggest?q=${encodeURIComponent(accQ)}`);
        const d2 = await r2.json();
        setCombina((d2?.products || []).slice(0, 6));
      } else {
        setCombina([]);
      }
    } finally {
      setLoadingSug(false);
    }
  };

  const onSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    const t = query.trim();
    if (!t || !sessionId) return;
    
    console.log('üì§ [onSubmit] Processando busca via form:', t);
    
    // üîÑ RESET COMPLETO para nova consulta
    console.log('üîÑ [onSubmit] Resetando estado para nova consulta:', t);
    
    // Armazenar termo para buscar ap√≥s o chat informar
    pendingSearchRef.current = t;
    hasTriggeredSearchRef.current = false; // Reset flag
    
    // Limpar produtos existentes SEMPRE
    setTopBox([]);
    setFeed([]);
    setCombina([]);
    
    // Mostrar mensagem do usu√°rio
    setChatMessages(prev => [...prev, { type: 'user', text: t }]);
    
    // Limpar campo
    setQuery('');
    
    // Ativar overlay de resultados e fechar dropdown
    setShowResults(true);
    setOpen(false);
    
    startStream(t);
  };

  const startStream = async (message: string) => {
    // üîí CONTROLE DE CONCORR√äNCIA: S√≥ um stream por vez
    if (readerRef.current) {
      console.log('üîí [AssistantBar] Cancelando stream anterior');
      try { await readerRef.current.cancel(); } catch {}
      readerRef.current = null;
    }
    
    // üîÑ RESET APENAS STREAMING (N√ÉO produtos)
    console.log('üîÑ [AssistantBar] Iniciando nova consulta:', message);
    setIsTyping(true);
    setStreaming('');
    // Reset flags cr√≠ticas
    pendingSearchRef.current = message;
    hasTriggeredSearchRef.current = false;
    
    console.log('üì° [AssistantBar] Iniciando stream para:', message);
    
    try {
      const res = await fetch('/api/assistant/stream', {
        method: 'POST',
        headers: { 
          'Content-Type': 'application/json',
          'x-user-id': uid, 
          'x-user-name': userName 
        },
        body: JSON.stringify({ sessionId, message })
      });
      
      if (!res.ok || !res.body) {
        setIsTyping(false);
        return;
      }
      
      // Remover indicador de digita√ß√£o quando come√ßar a receber resposta
      setIsTyping(false);
      
      const reader = res.body.getReader();
      readerRef.current = reader;
      const decoder = new TextDecoder();
      let buffer = '';
      let assistantMessage = '';
      let assistantMessageId = `assistant-${Date.now()}`;
      
      console.log('üëÇ [AssistantBar] Reader iniciado, aguardando chunks...');
      
      while (true) {
        const { value, done } = await reader.read();
        if (done) {
          console.log('üèÅ [AssistantBar] Stream finalizado');
          break;
        }
        
        const chunk = decoder.decode(value, { stream: true });
        console.log('üì¶ [AssistantBar] Chunk recebido:', chunk.substring(0, 200) + (chunk.length > 200 ? '...' : ''));
        
        buffer += chunk;
        const parts = buffer.split('\n\n');
        buffer = parts.pop() || '';
        
        console.log('üîÑ [AssistantBar] Processando', parts.length, 'partes');
        
        for (const part of parts) {
          const line = part.trim().replace(/^data:\s?/, '');
          
          // üõ°Ô∏è PROTE√á√ÉO: S√≥ processar linhas n√£o vazias
          if (!line) {
            console.log('‚è≠Ô∏è [DEBUG] Linha vazia ignorada');
            continue;
          }
          
          console.log('üîç [DEBUG] Processando parte:', line.substring(0, 150) + (line.length > 150 ? '...' : ''));
          
          // üß† PARSER ROBUSTO: Tentar JSON primeiro, s√≥ aceitar texto se N√ÉO for JSON malformado
          let isValidEvent = false;
          try {
            const p = JSON.parse(line);
            isValidEvent = true;
            console.log('‚úÖ [DEBUG] Evento JSON v√°lido:', p.type);
            
            if ((p.type === 'chunk' || p.type === 'delta') && p.text) {
              console.log('‚úÖ [DEBUG] Processando texto delta/chunk:', p.text.substring(0, 50));
              assistantMessage += p.text;
              setStreaming(assistantMessage);
              
              // Detectar quando assistente fala sobre buscar e executar busca pendente (apenas uma vez)
              if (pendingSearchRef.current && !hasTriggeredSearchRef.current && 
                  (assistantMessage.toLowerCase().includes('busca') || 
                   assistantMessage.toLowerCase().includes('procurando') ||
                   assistantMessage.toLowerCase().includes('op√ß√µes') ||
                   assistantMessage.toLowerCase().includes('aqui est√£o') ||
                   assistantMessage.toLowerCase().includes('vou buscar') ||
                   assistantMessage.toLowerCase().includes('procurar'))) {
                fetchSuggest(pendingSearchRef.current);
                hasTriggeredSearchRef.current = true;
                pendingSearchRef.current = ''; // Limpar busca pendente
              }
            } else if (p.type === 'products') {
              // üîß HARD GROUNDING FRONTEND: S√≥ produtos com ID v√°lido
              console.log('üì¶ [AssistantBar] ‚úÖ Produtos recebidos (evento separado):', p.products?.length || 0);
              
              if (p.products && p.products.length > 0) {
                // üîß VALIDA√á√ÉO RIGOROSA: S√≥ produtos com ID, t√≠tulo e dados b√°sicos
                const validProducts = p.products.filter((product: any) => 
                  product && 
                  product.id && 
                  (typeof product.id === 'string' || typeof product.id === 'number') &&
                  String(product.id).trim().length > 0 &&
                  (product.title || product.name) &&
                  (product.title || product.name).trim().length > 0
                );
                
                console.log('‚úÖ [HARD GROUNDING] Valida√ß√£o frontend:', {
                  received: p.products.length,
                  valid: validProducts.length,
                  filtered: p.products.length - validProducts.length,
                  hardGrounding: p.hardGrounding || false,
                  validationApplied: p.validationApplied || false
                });
                
                if (validProducts.length > 0) {
                  // Normalizar produtos para interface
                  const normalizedProducts = validProducts.map((product: any) => ({
                    ...product,
                    name: product.name || product.title,
                    title: product.title || product.name,
                    validatedById: true // Marca que passou pela valida√ß√£o
                  }));
                  
                  // Exibir apenas produtos validados na interface
                  setTopBox(normalizedProducts.slice(0, 3));
                  setFeed(normalizedProducts.slice(3));
                  setShowResults(true);
                  
                  console.log('üì¶ [HARD GROUNDING] ‚úÖ Interface atualizada com produtos validados por ID');
                } else {
                  console.warn('‚ö†Ô∏è [HARD GROUNDING] Nenhum produto v√°lido ap√≥s valida√ß√£o frontend');
                  // N√£o exibir produtos inv√°lidos
                }
              }
            } else if (p.type === 'end' || p.type === 'complete') {
              console.log('üèÅ [DEBUG] Stream finalizado com tipo:', p.type);
              // Fallback: se ainda h√° busca pendente, executar agora
              if (pendingSearchRef.current && !hasTriggeredSearchRef.current) {
                fetchSuggest(pendingSearchRef.current);
                hasTriggeredSearchRef.current = true;
                pendingSearchRef.current = '';
              }
              
              // üîß FINALIZAR: S√≥ adicionar se h√° mensagem v√°lida
              if (assistantMessage.trim()) {
                setChatMessages(prev => [...prev, { type: 'assistant', text: assistantMessage.trim() }]);
              }
              setStreaming('');
              return;
            } else if (p.type === 'meta' || p.type === 'paragraph_done') {
              // Eventos informativos que n√£o precisam processamento
              console.log('‚ÑπÔ∏è [DEBUG] Evento informativo:', p.type);
            } else {
              console.log('‚ö†Ô∏è [DEBUG] Evento n√£o processado:', p.type);
            }
          } catch (error) {
            // üö® CR√çTICO: S√ì adicionar ao texto se N√ÉO parecer JSON malformado
            const looksLikeJSON = line.includes('{') && (line.includes('"type"') || line.includes('"products"'));
            
            if (looksLikeJSON) {
              console.warn('üö® [DEBUG] JSON malformado detectado - IGNORANDO:', line.substring(0, 50));
              // N√ÉO adicionar ao assistantMessage - ignorar JSON malformado
            } else {
              console.log('üìù [DEBUG] Texto simples adicionado:', line.substring(0, 50));
              assistantMessage += line;
              setStreaming(assistantMessage);
            }
          }
        }
      }
      
      // üîß FALLBACK: Se terminar sem 'end', ainda adicionar a mensagem (evitar duplicatas)
      if (assistantMessage.trim() && !chatMessages.some(m => m.text === assistantMessage.trim())) {
        setChatMessages(prev => [...prev, { type: 'assistant', text: assistantMessage.trim() }]);
        setStreaming('');
      }
    } catch (e) {
      console.error('Stream error:', e);
      setIsTyping(false);
    }
  };

  const goProduct = (p: any) => {
    if (p?.id) {
      // Adicionar mensagem da IA antes do redirecionamento
      setChatMessages(prev => [...prev, { 
        type: 'assistant', 
        text: 'Vou te redirecionar para o ambiente Click com mais algumas sugest√µes!' 
      }]);
      
      // Aguardar um pouco antes de redirecionar para o usu√°rio ver a mensagem
      setTimeout(() => {
        setLocation(`/click-environment/${encodeURIComponent(p.id)}`);
      }, 1000);
    }
  };

  const closeResults = () => {
    setShowResults(false);
  };

  // Handler para ESC key
  useEffect(() => {
    const handleEsc = (e: KeyboardEvent) => {
      if (e.key === 'Escape' && showResults) {
        closeResults();
      }
    };
    
    document.addEventListener('keydown', handleEsc);
    return () => document.removeEventListener('keydown', handleEsc);
  }, [showResults]);

  const sendOverlayMessage = (e: React.FormEvent) => {
    e.preventDefault();
    const message = overlayInput.trim();
    if (!message || !sessionId) return;
    
    // üîÑ RESET para overlay message
    console.log('üîÑ [sendOverlayMessage] Nova consulta via overlay:', message);
    
    // Armazenar termo para buscar ap√≥s o chat informar (mesmo padr√£o do onSubmit)
    pendingSearchRef.current = message;
    hasTriggeredSearchRef.current = false; // Reset flag
    
    // Limpar produtos existentes para nova consulta
    setTopBox([]);
    setFeed([]);
    setCombina([]);
    
    // Adicionar mensagem do usu√°rio
    setChatMessages(prev => [...prev, { type: 'user', text: message }]);
    
    // Limpar input
    setOverlayInput('');
    
    // Enviar para IA
    startStream(message);
  };

  // Auto-scroll para √∫ltima mensagem
  const scrollToBottom = () => {
    if (chatScrollRef.current) {
      chatScrollRef.current.scrollTop = chatScrollRef.current.scrollHeight;
    }
  };

  // Auto-scroll quando mensagens mudam ou durante streaming
  useEffect(() => {
    scrollToBottom();
  }, [chatMessages, streaming, isTyping]);

  return (
    <>
      {/* WRAPPER RELATIVE para ancorar */} 
      <div className="w-full relative">
        {/* Barra = chat */}
        <form ref={chatRef} onSubmit={onSubmit} className="flex items-center gap-2 rounded-2xl px-4 py-2 bg-white shadow border">
          <div className="w-7 h-7 grid place-content-center text-lg">ü§ñ</div>
          <input
            value={query}
            onChange={e => onChange(e.target.value)}
            onFocus={() => {
              setIsSearchFocused(true);
              onFocus();
            }}
            onBlur={(e) => {
              // Delay para permitir clique nas sugest√µes
              setTimeout(() => setIsSearchFocused(false), 200);
              setTimeout(() => setShowSuggestions(false), 200);
            }}
            placeholder={isSearchFocused || query ? "Converse com o Click (ex.: iPhone 15 em CDE)" : (displayText || "Carregando frases...")}
            className="flex-1 outline-none text-base"
            data-testid="search-input"
          />
          {loadingSug && <div className="text-xs text-gray-500">Buscando...</div>}
          <button type="submit" className="p-1 hover:bg-gray-100 rounded" data-testid="search-submit">
            <Search className="w-4 h-4" />
          </button>
        </form>

        {/* SUGEST√ïES DE AUTOCOMPLETE */}
        {showSuggestions && suggestions.length > 0 && (
          <div className="absolute top-full left-0 right-0 bg-white border border-gray-200 rounded-lg shadow-lg z-50 mt-1">
            <div className="max-h-60 overflow-y-auto">
              {suggestions.map((suggestion, idx) => (
                <button
                  key={idx}
                  onClick={() => selectSuggestion(suggestion)}
                  className="w-full px-4 py-2 text-left hover:bg-gray-50 border-b border-gray-100 last:border-b-0"
                  data-testid={`suggestion-${idx}`}
                >
                  <div className="flex items-center gap-2">
                    <Search className="w-4 h-4 text-gray-400" />
                    <span className="text-sm text-gray-700">{suggestion}</span>
                  </div>
                </button>
              ))}
            </div>
          </div>
        )}

        {/* DROPDOWN de resultados */}
        {open && (
          <div className="absolute top-full left-0 right-0 bg-white border border-gray-200 rounded-lg shadow-lg z-40 mt-1">
            <div className="p-4">
              <div className="text-sm text-gray-500 mb-3">Sugest√µes de busca:</div>
              <div className="space-y-2">
                {['iPhone 15', 'Samsung Galaxy', 'Perfumes importados', 'Notebook gamer'].map(item => (
                  <button
                    key={item}
                    onClick={() => {
                      setQuery(item);
                      setOpen(false);
                      setTimeout(() => chatRef.current?.requestSubmit(), 100);
                    }}
                    className="block w-full text-left p-2 hover:bg-gray-50 rounded text-sm"
                    data-testid={`quick-search-${item.toLowerCase().replace(/\s+/g, '-')}`}
                  >
                    {item}
                  </button>
                ))}
              </div>
            </div>
          </div>
        )}
      </div>

      {/* OVERLAY de resultados (posi√ß√£o fixed para cobrir toda a tela) */}
      {showResults && (
        <div className="fixed inset-0 bg-black/50 z-[9999] flex justify-center items-start pt-4 px-4">
          <div className="bg-white rounded-2xl shadow-2xl max-w-6xl w-full max-h-[calc(100vh-2rem)] flex flex-col overflow-hidden">
            {/* Header do overlay */}
            <div className="flex items-center justify-between p-4 border-b bg-gradient-to-r from-blue-50 to-purple-50">
              <div className="flex items-center gap-3">
                <div className="w-8 h-8 bg-gradient-to-r from-blue-500 to-purple-500 rounded-full flex items-center justify-center text-white font-bold">
                  ü§ñ
                </div>
                <div>
                  <h2 className="font-semibold text-gray-900">Click Ofertas AI</h2>
                  <p className="text-sm text-gray-600">Conversando sobre suas buscas</p>
                </div>
              </div>
              <button 
                onClick={closeResults}
                className="p-2 hover:bg-white/50 rounded-full transition-colors"
                data-testid="close-results"
              >
                <span className="text-xl">√ó</span>
              </button>
            </div>

            {/* √Årea principal com layout flex */}
            <div className="flex flex-1 min-h-0">
              {/* Chat √† esquerda */}
              <div className="w-1/2 border-r flex flex-col">
                {/* Mensagens do chat */}
                <div ref={chatScrollRef} className="flex-1 overflow-y-auto p-4 space-y-3">
                  {chatMessages.map((msg, idx) => (
                    <div key={idx} className={`flex ${msg.type === 'user' ? 'justify-end' : 'justify-start'}`}>
                      <div className={`max-w-[80%] p-3 rounded-2xl text-sm ${
                        msg.type === 'user' 
                          ? 'bg-blue-500 text-white rounded-br-sm' 
                          : 'bg-gray-100 text-gray-800 rounded-bl-sm'
                      }`}>
                        {msg.text}
                      </div>
                    </div>
                  ))}
                  
                  {/* Mensagem sendo digitada */}
                  {streaming && (
                    <div className="flex justify-start">
                      <div className="max-w-[80%] p-3 rounded-2xl rounded-bl-sm bg-gray-100 text-gray-800 text-sm">
                        {streaming}
                        <span className="inline-block w-2 h-4 bg-gray-400 ml-1 animate-pulse">|</span>
                      </div>
                    </div>
                  )}
                  
                  {/* Indicador de digita√ß√£o */}
                  {isTyping && !streaming && (
                    <div className="flex justify-start">
                      <div className="max-w-[80%] p-3 rounded-2xl rounded-bl-sm bg-gray-100 text-gray-800 text-sm">
                        <span className="inline-flex items-center gap-1">
                          <span className="w-2 h-2 bg-gray-400 rounded-full animate-bounce"></span>
                          <span className="w-2 h-2 bg-gray-400 rounded-full animate-bounce" style={{animationDelay: '0.1s'}}></span>
                          <span className="w-2 h-2 bg-gray-400 rounded-full animate-bounce" style={{animationDelay: '0.2s'}}></span>
                        </span>
                      </div>
                    </div>
                  )}
                </div>
                
                {/* Input para nova mensagem */}
                <div className="p-4 border-t">
                  <form onSubmit={sendOverlayMessage} className="flex gap-2">
                    <input
                      type="text"
                      value={overlayInput}
                      onChange={(e) => setOverlayInput(e.target.value)}
                      placeholder="Digite sua mensagem..."
                      className="flex-1 p-3 border border-gray-300 rounded-xl outline-none focus:ring-2 focus:ring-blue-500 text-sm"
                      data-testid="overlay-input"
                    />
                    <button 
                      type="submit"
                      className="px-4 py-3 bg-blue-500 text-white rounded-xl hover:bg-blue-600 transition-colors text-sm font-medium"
                      data-testid="send-message"
                    >
                      Enviar
                    </button>
                  </form>
                </div>
              </div>

              {/* Produtos √† direita */}
              <div className="w-1/2 flex flex-col">
                <div className="p-4 border-b">
                  <h3 className="font-semibold text-gray-900 mb-2">Produtos Encontrados</h3>
                  <p className="text-sm text-gray-600">Resultados da busca</p>
                </div>
                
                <div className="flex-1 overflow-y-auto p-4">
                  {/* Top Box - produtos principais */}
                  {topBox.length > 0 && (
                    <div className="mb-6">
                      <h4 className="font-medium text-gray-800 mb-3">Principais</h4>
                      <div className="grid grid-cols-1 gap-3">
                        {topBox.map((product, idx) => (
                          <div 
                            key={product.id || idx} 
                            onClick={() => goProduct(product)}
                            className="border border-gray-200 rounded-lg p-3 hover:shadow-md transition-shadow cursor-pointer bg-white"
                            data-testid={`product-main-${idx}`}
                          >
                            <div className="flex gap-3">
                              {product.imageUrl && (
                                <img 
                                  src={product.imageUrl} 
                                  alt={product.name || product.title}
                                  className="w-16 h-16 object-cover rounded"
                                  loading="lazy"
                                />
                              )}
                              <div className="flex-1 min-w-0">
                                <h5 className="font-medium text-sm text-gray-900 line-clamp-2">
                                  {product.name || product.title}
                                </h5>
                                {product.storeName && (
                                  <p className="text-xs text-gray-600 mt-1">{product.storeName}</p>
                                )}
                                {product.priceUSD && (
                                  <p className="text-sm font-semibold text-green-600 mt-1">
                                    ${product.priceUSD}
                                  </p>
                                )}
                              </div>
                            </div>
                          </div>
                        ))}
                      </div>
                    </div>
                  )}

                  {/* Feed - demais produtos */}
                  {feed.length > 0 && (
                    <div className="mb-6">
                      <h4 className="font-medium text-gray-800 mb-3">Outras op√ß√µes</h4>
                      <div className="grid grid-cols-1 gap-3">
                        {feed.map((product, idx) => (
                          <div 
                            key={product.id || idx} 
                            onClick={() => goProduct(product)}
                            className="border border-gray-200 rounded-lg p-3 hover:shadow-md transition-shadow cursor-pointer bg-white"
                            data-testid={`product-feed-${idx}`}
                          >
                            <div className="flex gap-3">
                              {product.imageUrl && (
                                <img 
                                  src={product.imageUrl} 
                                  alt={product.name || product.title}
                                  className="w-16 h-16 object-cover rounded"
                                  loading="lazy"
                                />
                              )}
                              <div className="flex-1 min-w-0">
                                <h5 className="font-medium text-sm text-gray-900 line-clamp-2">
                                  {product.name || product.title}
                                </h5>
                                {product.storeName && (
                                  <p className="text-xs text-gray-600 mt-1">{product.storeName}</p>
                                )}
                                {product.priceUSD && (
                                  <p className="text-sm font-semibold text-green-600 mt-1">
                                    ${product.priceUSD}
                                  </p>
                                )}
                              </div>
                            </div>
                          </div>
                        ))}
                      </div>
                    </div>
                  )}

                  {/* Produtos combinados/acess√≥rios */}
                  {combina.length > 0 && (
                    <div>
                      <h4 className="font-medium text-gray-800 mb-3">Acess√≥rios e relacionados</h4>
                      <div className="grid grid-cols-1 gap-3">
                        {combina.map((product, idx) => (
                          <div 
                            key={product.id || idx} 
                            onClick={() => goProduct(product)}
                            className="border border-gray-200 rounded-lg p-3 hover:shadow-md transition-shadow cursor-pointer bg-white"
                            data-testid={`product-related-${idx}`}
                          >
                            <div className="flex gap-3">
                              {product.imageUrl && (
                                <img 
                                  src={product.imageUrl} 
                                  alt={product.name || product.title}
                                  className="w-16 h-16 object-cover rounded"
                                  loading="lazy"
                                />
                              )}
                              <div className="flex-1 min-w-0">
                                <h5 className="font-medium text-sm text-gray-900 line-clamp-2">
                                  {product.name || product.title}
                                </h5>
                                {product.storeName && (
                                  <p className="text-xs text-gray-600 mt-1">{product.storeName}</p>
                                )}
                                {product.priceUSD && (
                                  <p className="text-sm font-semibold text-green-600 mt-1">
                                    ${product.priceUSD}
                                  </p>
                                )}
                              </div>
                            </div>
                          </div>
                        ))}
                      </div>
                    </div>
                  )}

                  {/* Estado vazio */}
                  {topBox.length === 0 && feed.length === 0 && combina.length === 0 && (
                    <div className="text-center py-8 text-gray-500">
                      <div className="w-16 h-16 bg-gray-100 rounded-full flex items-center justify-center mx-auto mb-3">
                        üîç
                      </div>
                      <p className="text-sm">Nenhum produto encontrado</p>
                      <p className="text-xs mt-1">Tente uma busca diferente</p>
                    </div>
                  )}
                </div>
              </div>
            </div>
          </div>
        </div>
      )}
    </>
  );
}

=====================================
AN√ÅLISE DO PROBLEMA:

1. O BACKEND EST√Å FUNCIONANDO PERFEITAMENTE
   - Logs mostram resposta concisa: "Aqui est√£o as melhores op√ß√µes"
   - Produtos sendo enviados corretamente via SSE
   - JSON estruturado validado

2. PROBLEMA NO FRONTEND:
   - AssistantBar recebe dados corretos mas algo limpa os produtos
   - Pode haver race conditions entre streams
   - Ou problema na atualiza√ß√£o de estado

3. SUSPEITAS:
   - Linha 695-696: setTopBox/setFeed pode estar sendo chamado incorretamente
   - M√∫ltiplas chamadas de startStream podem estar limpando estado
   - Auto-flush do useEffect pode estar interferindo

SOLU√á√ÉO RECOMENDADA:
Verificar logs do browser para ver exatamente onde os produtos est√£o sendo perdidos.
=====================================