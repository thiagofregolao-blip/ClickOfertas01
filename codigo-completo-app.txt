# C√ìDIGO COMPLETO - CLICK OFERTAS PARAGUAI
# =====================================================
# Gerado em: 19 de setembro de 2025
# Aplica√ß√£o PWA completa com funcionalidades avan√ßadas
# =====================================================

## CONFIGURA√á√ÉO INICIAL

### package.json
```json
{
  "name": "rest-express",
  "version": "1.0.0",
  "type": "module",
  "license": "MIT",
  "scripts": {
    "dev": "NODE_ENV=development tsx server/index.ts",
    "build": "vite build && esbuild server/index.ts --platform=node --packages=external --bundle --format=esm --outdir=dist",
    "start": "NODE_ENV=production node dist/index.js",
    "check": "tsc",
    "db:push": "drizzle-kit push"
  },
  "dependencies": {
    "@google-cloud/storage": "^7.17.0",
    "@google/genai": "^1.18.0",
    "@google/generative-ai": "^0.24.1",
    "@hookform/resolvers": "^3.10.0",
    "@jridgewell/trace-mapping": "^0.3.25",
    "@neondatabase/serverless": "^0.10.4",
    "@radix-ui/react-accordion": "^1.2.4",
    "@radix-ui/react-alert-dialog": "^1.1.7",
    "@radix-ui/react-aspect-ratio": "^1.1.3",
    "@radix-ui/react-avatar": "^1.1.4",
    "@radix-ui/react-checkbox": "^1.1.5",
    "@radix-ui/react-collapsible": "^1.1.4",
    "@radix-ui/react-context-menu": "^2.2.7",
    "@radix-ui/react-dialog": "^1.1.7",
    "@radix-ui/react-dropdown-menu": "^2.1.7",
    "@radix-ui/react-hover-card": "^1.1.7",
    "@radix-ui/react-label": "^2.1.3",
    "@radix-ui/react-menubar": "^1.1.7",
    "@radix-ui/react-navigation-menu": "^1.2.6",
    "@radix-ui/react-popover": "^1.1.7",
    "@radix-ui/react-progress": "^1.1.3",
    "@radix-ui/react-radio-group": "^1.2.4",
    "@radix-ui/react-scroll-area": "^1.2.4",
    "@radix-ui/react-select": "^2.1.7",
    "@radix-ui/react-separator": "^1.1.3",
    "@radix-ui/react-slider": "^1.2.4",
    "@radix-ui/react-slot": "^1.2.0",
    "@radix-ui/react-switch": "^1.1.4",
    "@radix-ui/react-tabs": "^1.1.4",
    "@radix-ui/react-toast": "^1.2.7",
    "@radix-ui/react-toggle": "^1.1.3",
    "@radix-ui/react-toggle-group": "^1.1.3",
    "@radix-ui/react-tooltip": "^1.2.0",
    "@tanstack/react-query": "^5.60.5",
    "@types/bcryptjs": "^2.4.6",
    "@types/file-saver": "^2.0.7",
    "@types/html2canvas": "^0.5.35",
    "@types/jspdf": "^1.3.3",
    "@types/leaflet": "^1.9.20",
    "@types/memoizee": "^0.4.12",
    "@types/multer": "^2.0.0",
    "@types/passport-apple": "^2.0.3",
    "@types/passport-google-oauth20": "^2.0.16",
    "@types/qrcode": "^1.5.5",
    "@uppy/aws-s3": "^5.0.0",
    "@uppy/core": "^5.0.0",
    "@uppy/dashboard": "^5.0.0",
    "@uppy/react": "^5.0.0",
    "@uppy/webcam": "^5.0.0",
    "apify": "^3.4.4",
    "apify-client": "^2.16.0",
    "axios": "^1.11.0",
    "bcryptjs": "^3.0.2",
    "cheerio": "^1.1.2",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "cmdk": "^1.1.1",
    "connect-pg-simple": "^10.0.0",
    "crawlee": "^3.14.1",
    "date-fns": "^3.6.0",
    "drizzle-orm": "^0.39.1",
    "drizzle-zod": "^0.7.0",
    "embla-carousel-react": "^8.6.0",
    "express": "^4.21.2",
    "express-session": "^1.18.1",
    "file-saver": "^2.0.5",
    "framer-motion": "^11.13.1",
    "google-auth-library": "^10.3.0",
    "html2canvas": "^1.4.1",
    "input-otp": "^1.4.2",
    "jspdf": "^3.0.2",
    "leaflet": "^1.9.4",
    "lucide-react": "^0.453.0",
    "memoizee": "^0.4.17",
    "memorystore": "^1.6.7",
    "multer": "^2.0.2",
    "nanoid": "^5.1.5",
    "next-themes": "^0.4.6",
    "openai": "^5.15.0",
    "openid-client": "^6.7.0",
    "passport": "^0.7.0",
    "passport-apple": "^2.0.2",
    "passport-google-oauth20": "^2.0.0",
    "passport-local": "^1.0.0",
    "puppeteer": "^24.17.1",
    "puppeteer-extra": "^3.3.6",
    "puppeteer-extra-plugin-stealth": "^2.11.2",
    "qrcode": "^1.5.4",
    "react": "^18.3.1",
    "react-day-picker": "^8.10.1",
    "react-dom": "^18.3.1",
    "react-hook-form": "^7.55.0",
    "react-icons": "^5.4.0",
    "react-leaflet": "^4.2.1",
    "react-multi-carousel": "^2.8.6",
    "react-resizable-panels": "^2.1.7",
    "recharts": "^2.15.2",
    "serpapi": "^2.2.1",
    "sharp": "^0.34.3",
    "swiper": "^12.0.1",
    "tailwind-merge": "^2.6.0",
    "tailwindcss-animate": "^1.0.7",
    "tw-animate-css": "^1.2.5",
    "user-agents": "^1.1.647",
    "vaul": "^1.1.2",
    "wouter": "^3.3.5",
    "ws": "^8.18.0",
    "xlsx": "^0.18.5",
    "zod": "^3.24.2",
    "zod-validation-error": "^3.4.0"
  },
  "devDependencies": {
    "@replit/vite-plugin-cartographer": "^0.3.0",
    "@replit/vite-plugin-runtime-error-modal": "^0.0.3",
    "@tailwindcss/typography": "^0.5.15",
    "@tailwindcss/vite": "^4.1.3",
    "@types/connect-pg-simple": "^7.0.3",
    "@types/express": "4.17.21",
    "@types/express-session": "^1.18.0",
    "@types/node": "20.16.11",
    "@types/passport": "^1.0.16",
    "@types/passport-local": "^1.0.38",
    "@types/react": "^18.3.11",
    "@types/react-dom": "^18.3.1",
    "@types/ws": "^8.5.13",
    "@vitejs/plugin-react": "^4.3.2",
    "autoprefixer": "^10.4.20",
    "drizzle-kit": "^0.30.4",
    "esbuild": "^0.25.0",
    "postcss": "^8.4.47",
    "tailwindcss": "^3.4.17",
    "tsx": "^4.19.1",
    "typescript": "5.6.3",
    "vite": "^5.4.19"
  },
  "optionalDependencies": {
    "bufferutil": "^4.0.8"
  }
}
```

### tsconfig.json
```json
{
  "include": ["client/src/**/*", "shared/**/*", "server/**/*"],
  "exclude": ["node_modules", "build", "dist", "**/*.test.ts"],
  "compilerOptions": {
    "incremental": true,
    "tsBuildInfoFile": "./node_modules/typescript/tsbuildinfo",
    "noEmit": true,
    "module": "ESNext",
    "strict": true,
    "lib": ["esnext", "dom", "dom.iterable"],
    "jsx": "preserve",
    "esModuleInterop": true,
    "skipLibCheck": true,
    "allowImportingTsExtensions": true,
    "moduleResolution": "bundler",
    "baseUrl": ".",
    "types": ["node", "vite/client"],
    "paths": {
      "@/*": ["./client/src/*"],
      "@shared/*": ["./shared/*"]
    }
  }
}
```

### vite.config.ts
```typescript
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import path from "path";
import runtimeErrorOverlay from "@replit/vite-plugin-runtime-error-modal";

export default defineConfig({
  plugins: [
    react(),
    runtimeErrorOverlay(),
    ...(process.env.NODE_ENV !== "production" &&
    process.env.REPL_ID !== undefined
      ? [
          await import("@replit/vite-plugin-cartographer").then((m) =>
            m.cartographer(),
          ),
        ]
      : []),
  ],
  resolve: {
    alias: {
      "@": path.resolve(import.meta.dirname, "client", "src"),
      "@shared": path.resolve(import.meta.dirname, "shared"),
      "@assets": path.resolve(import.meta.dirname, "attached_assets"),
    },
  },
  root: path.resolve(import.meta.dirname, "client"),
  build: {
    outDir: path.resolve(import.meta.dirname, "dist/public"),
    emptyOutDir: true,
  },
  server: {
    fs: {
      strict: true,
      deny: ["**/.*"],
    },
  },
});
```

### tailwind.config.ts
```typescript
import type { Config } from "tailwindcss";

export default {
  darkMode: ["class"],
  content: ["./client/index.html", "./client/src/**/*.{js,jsx,ts,tsx}"],
  theme: {
    extend: {
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)",
      },
      colors: {
        background: "var(--background)",
        foreground: "var(--foreground)",
        card: {
          DEFAULT: "var(--card)",
          foreground: "var(--card-foreground)",
        },
        popover: {
          DEFAULT: "var(--popover)",
          foreground: "var(--popover-foreground)",
        },
        primary: {
          DEFAULT: "var(--primary)",
          foreground: "var(--primary-foreground)",
        },
        secondary: {
          DEFAULT: "var(--secondary)",
          foreground: "var(--secondary-foreground)",
        },
        muted: {
          DEFAULT: "var(--muted)",
          foreground: "var(--muted-foreground)",
        },
        accent: {
          DEFAULT: "var(--accent)",
          foreground: "var(--accent-foreground)",
        },
        destructive: {
          DEFAULT: "var(--destructive)",
          foreground: "var(--destructive-foreground)",
        },
        border: "var(--border)",
        input: "var(--input)",
        ring: "var(--ring)",
        chart: {
          "1": "var(--chart-1)",
          "2": "var(--chart-2)",
          "3": "var(--chart-3)",
          "4": "var(--chart-4)",
          "5": "var(--chart-5)",
        },
        sidebar: {
          DEFAULT: "var(--sidebar)",
          foreground: "var(--sidebar-foreground)",
          primary: "var(--sidebar-primary)",
          "primary-foreground": "var(--sidebar-primary-foreground)",
          accent: "var(--sidebar-accent)",
          "accent-foreground": "var(--sidebar-accent-foreground)",
          border: "var(--sidebar-border)",
          ring: "var(--sidebar-ring)",
        },
      },
      fontFamily: {
        sans: ["var(--font-sans)", "Inter", "system-ui", "sans-serif"],
        serif: ["var(--font-serif)", "Georgia", "serif"],
        mono: ["var(--font-mono)", "Menlo", "monospace"],
      },
      keyframes: {
        "accordion-down": {
          from: {
            height: "0",
          },
          to: {
            height: "var(--radix-accordion-content-height)",
          },
        },
        "accordion-up": {
          from: {
            height: "var(--radix-accordion-content-height)",
          },
          to: {
            height: "0",
          },
        },
      },
      animation: {
        "accordion-down": "accordion-down 0.2s ease-out",
        "accordion-up": "accordion-up 0.2s ease-out",
      },
    },
  },
  plugins: [require("tailwindcss-animate"), require("@tailwindcss/typography")],
} satisfies Config;
```

### postcss.config.js
```javascript
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}
```

### drizzle.config.ts
```typescript
import { defineConfig } from "drizzle-kit";

if (!process.env.DATABASE_URL) {
  throw new Error("DATABASE_URL, ensure the database is provisioned");
}

export default defineConfig({
  out: "./migrations",
  schema: "./shared/schema.ts",
  dialect: "postgresql",
  dbCredentials: {
    url: process.env.DATABASE_URL,
  },
});
```

## FRONTEND

### client/index.html
```html
<!DOCTYPE html>
<html lang="pt-BR">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1" />
    
    <!-- PWA Meta Tags -->
    <title>Click Ofertas Paraguai</title>
    <meta name="description" content="Crie e compartilhe panfletos digitais das suas ofertas. Encontre as melhores promo√ß√µes do Paraguai.">
    <meta name="theme-color" content="#21409A">
    <meta name="application-name" content="Click Ofertas">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="msapplication-config" content="/browserconfig.xml">
    <meta name="msapplication-TileColor" content="#21409A">
    <meta name="msapplication-tap-highlight" content="no">
    
    <!-- PWA Manifest embutido no HTML -->
    <script>
      // Criar manifest dinamicamente
      const manifestData = {
        "name": "Click Ofertas Paraguai",
        "short_name": "Click Ofertas", 
        "description": "Crie e compartilhe panfletos digitais das suas ofertas",
        "start_url": "/",
        "display": "standalone",
        "background_color": "#ffffff",
        "theme_color": "#21409A",
        "orientation": "portrait-primary",
        "scope": "/",
        "icons": [
          {
            "src": "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 512 512'%3E%3Cpath fill='%2321409A' d='M0 0h512v512H0z'/%3E%3Cpath fill='white' d='M128 128h256v64H128zm0 96h256v64H128zm0 96h192v64H128z'/%3E%3C/svg%3E",
            "sizes": "512x512",
            "type": "image/svg+xml",
            "purpose": "any"
          }
        ]
      };
      
      const manifestBlob = new Blob([JSON.stringify(manifestData)], {type: 'application/json'});
      const manifestURL = URL.createObjectURL(manifestBlob);
      const link = document.createElement('link');
      link.rel = 'manifest';
      link.href = manifestURL;
      document.head.appendChild(link);
    </script>
    
    <!-- PWA Icons -->
    <link rel="icon" type="image/png" sizes="32x32" href="/icon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/icon-16x16.png">
    <link rel="shortcut icon" href="/icon-32x32.png">
    
    
    <!-- Apple Touch Icon embutido -->
    <link rel="apple-touch-icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 180 180'%3E%3Cpath fill='%2321409A' d='M0 0h180v180H0z'/%3E%3Cpath fill='white' d='M36 36h108v27H36zm0 40.5h108v27H36zm0 40.5h81v27H36z'/%3E%3C/svg%3E">
    
    <!-- iOS PWA Configuration -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="Click Ofertas">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-touch-fullscreen" content="yes">
    
    <!-- Open Graph -->
    <meta property="og:type" content="website">
    <meta property="og:title" content="Click Ofertas Paraguai">
    <meta property="og:description" content="Crie e compartilhe panfletos digitais das suas ofertas">
    <meta property="og:site_name" content="Click Ofertas Paraguai">
    <meta property="og:url" content="https://click-ofertas-paraguai.replit.app">
    <meta property="og:image" content="/icon-512x512.png">
    
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Architects+Daughter&family=DM+Sans:ital,opsz,wght@0,9..40,100..1000;1,9..40,100..1000&family=Fira+Code:wght@300..700&family=Geist+Mono:wght@100..900&family=Geist:wght@100..900&family=IBM+Plex+Mono:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;1,100;1,200;1,300;1,400;1,500;1,600;1,700&family=IBM+Plex+Sans:ital,wght@0,100..700;1,100..700&family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&family=Libre+Baskerville:ital,wght@0,400;0,700;1,400&family=Lora:ital,wght@0,400..700;1,400..700&family=Merriweather:ital,opsz,wght@0,18..144,300..900;1,18..144,300..900&family=Montserrat:ital,wght@0,100..900;1,100..900&family=Open+Sans:ital,wght@0,300..800;1,300..800&family=Outfit:wght@100..900&family=Oxanium:wght@200..800&family=Playfair+Display:ital,wght@0,400..900;1,400..900&family=Plus+Jakarta+Sans:ital,wght@0,200..800;1,200..800&family=Poppins:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&family=Roboto+Mono:ital,wght@0,100..700;1,100..700&family=Roboto:ital,wght@0,100..900;1,100..900&family=Source+Code+Pro:ital,wght@0,200..900;1,200..900&family=Source+Serif+4:ital,opsz,wght@0,8..60,200..900;1,8..60,200..900&family=Space+Grotesk:wght@300..700&family=Space+Mono:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
    <!-- This is a replit script which adds a banner on the top of the page when opened in development mode outside the replit environment -->
    <script type="text/javascript" src="https://replit.com/public/js/replit-dev-banner.js"></script>
  </body>
</html>
```

### client/src/main.tsx
```tsx
import { createRoot } from "react-dom/client";
import App from "./App";
import "./index.css";

// Registro do Service Worker para PWA - APENAS EM PRODU√á√ÉO
if ('serviceWorker' in navigator) {
  if (import.meta.env.PROD) {
    window.addEventListener('load', () => {
      navigator.serviceWorker.register('/sw.js')
        .then((registration) => {
          console.log('Service Worker registrado com sucesso:', registration);
        })
        .catch((registrationError) => {
          console.log('Falha no registro do Service Worker:', registrationError);
        });
    });
  } else {
    // DESENVOLVIMENTO: Desregistrar qualquer Service Worker existente
    navigator.serviceWorker.getRegistrations().then((registrations) => {
      registrations.forEach((registration) => {
        registration.unregister();
        console.log('DEV: Service Worker desregistrado');
      });
    });
  }
}

createRoot(document.getElementById("root")!).render(<App />);
```

### client/src/App.tsx
```tsx
import { Switch, Route } from "wouter";
import { queryClient } from "./lib/queryClient";
import { QueryClientProvider, useQuery } from "@tanstack/react-query";
import { Toaster } from "@/components/ui/toaster";
import { TooltipProvider } from "@/components/ui/tooltip";
import { useAuth } from "@/hooks/useAuth";
import { useState } from "react";
import Landing from "@/pages/landing";
import AdminDashboard from "@/pages/admin-dashboard";
import AdminStoreConfig from "@/pages/admin-store-config";
import AdminProducts from "@/pages/admin-products";
import AdminPromotions from "@/pages/admin-promotions";
import AdminPremiumStores from "@/pages/admin-premium-stores";
import AdminTotem from "@/pages/admin-totem";
import AdminStories from "@/pages/admin-stories";
import Analytics from "@/pages/analytics";
import TotemDisplay from "@/pages/totem-display";
import PublicFlyer from "@/pages/public-flyer";
import StoresGallery from "@/pages/stores-gallery";
import UserSettingsPage from "@/pages/user-settings";
import ShoppingList from "@/pages/shopping-list";
import MyCoupons from "@/pages/my-coupons";
import CouponDetails from "@/pages/coupon-details";
import StoriesFeed from "@/pages/stories-feed";
import CreateStory from "@/pages/create-story";
import PriceComparison from "@/pages/price-comparison";
import ProductCompare from "@/pages/product-compare";
import SignupPage from "@/pages/signup";
import SuperAdmin from "@/pages/super-admin";
import SuperAdminLogin from "@/pages/super-admin-login";
import DailyScratchPage from "@/pages/daily-scratch";
import ApifyDemo from "@/pages/apify-demo";
import MaintenancePage from "@/pages/maintenance";
import NotFound from "@/pages/not-found";
import { MapModalTestPage } from "@/pages/map-modal-test";

function MaintenanceWrapper({ children }: { children: React.ReactNode }) {
  const [bypassMaintenance, setBypassMaintenance] = useState(() => {
    return localStorage.getItem('maintenance_bypass') === 'true';
  });

  // Hook para verificar status de manuten√ß√£o
  const { data: maintenanceStatus, isLoading: isLoadingMaintenance } = useQuery({
    queryKey: ['/api/maintenance/status'],
    refetchInterval: 30000, // Verifica a cada 30 segundos
    staleTime: 0, // Sem cache para for√ßar nova consulta
    gcTime: 0, // N√£o manter em cache (v5 usa gcTime ao inv√©s de cacheTime)
  });

  const { user } = useAuth();

  // Se est√° carregando, mostra um loading simples
  if (isLoadingMaintenance) {
    return (
      <div className="min-h-screen w-full flex items-center justify-center bg-gray-50">
        <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-primary"></div>
      </div>
    );
  }

  // Se em manuten√ß√£o e usu√°rio n√£o √© admin nem tem bypass
  if (maintenanceStatus?.isMaintenanceMode && !user?.isSuperAdmin && !bypassMaintenance) {
    return <MaintenancePage onBypass={() => setBypassMaintenance(true)} />;
  }

  return <>{children}</>;
}

function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <TooltipProvider>
        <MaintenanceWrapper>
          <Switch>
            {/* Rotas p√∫blicas */}
            <Route path="/" component={StoresGallery} />
            <Route path="/cards" component={StoresGallery} />
            <Route path="/flyer/:slug" component={PublicFlyer} />
            <Route path="/stores/:slug" component={PublicFlyer} />
            <Route path="/:slug" component={PublicFlyer} />
            <Route path="/totem/:storeId" component={TotemDisplay} />
            <Route path="/landing" component={Landing} />
            <Route path="/signup" component={SignupPage} />
            <Route path="/stories" component={StoriesFeed} />
            <Route path="/price-comparison" component={PriceComparison} />
            <Route path="/product/:productId/compare" component={ProductCompare} />
            <Route path="/map-modal-test" component={MapModalTestPage} />

            {/* Rotas autenticadas */}
            <Route path="/admin" component={AdminDashboard} />
            <Route path="/admin/store" component={AdminStoreConfig} />
            <Route path="/admin/products" component={AdminProducts} />
            <Route path="/admin/promotions" component={AdminPromotions} />
            <Route path="/admin/premium-stores" component={AdminPremiumStores} />
            <Route path="/admin/totem" component={AdminTotem} />
            <Route path="/admin/stories" component={AdminStories} />
            <Route path="/admin/analytics" component={Analytics} />
            <Route path="/settings" component={UserSettingsPage} />
            <Route path="/shopping-list" component={ShoppingList} />
            <Route path="/my-coupons" component={MyCoupons} />
            <Route path="/coupon/:id" component={CouponDetails} />
            <Route path="/create-story" component={CreateStory} />
            <Route path="/daily-scratch" component={DailyScratchPage} />

            {/* Super Admin */}
            <Route path="/super-admin-login" component={SuperAdminLogin} />
            <Route path="/super-admin" component={SuperAdmin} />

            {/* Demo/Debug */}
            <Route path="/apify-demo" component={ApifyDemo} />

            {/* 404 */}
            <Route component={NotFound} />
          </Switch>
        </MaintenanceWrapper>
        <Toaster />
      </TooltipProvider>
    </QueryClientProvider>
  );
}

export default App;
```

### client/src/index.css
```css
@import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
@import url('https://unpkg.com/leaflet@1.9.4/dist/leaflet.css');

@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  --background: hsl(0, 0%, 100%);
  --foreground: hsl(222.2, 84%, 4.9%);
  --card: hsl(0, 0%, 100%);
  --card-foreground: hsl(222.2, 84%, 4.9%);
  --popover: hsl(0, 0%, 100%);
  --popover-foreground: hsl(222.2, 84%, 4.9%);
  --primary: hsl(224, 76%, 48%);
  --primary-foreground: hsl(0, 0%, 100%);
  --secondary: hsl(210, 40%, 96%);
  --secondary-foreground: hsl(222.2, 84%, 4.9%);
  --muted: hsl(210, 40%, 96%);
  --muted-foreground: hsl(215.4, 16.3%, 46.9%);
  --accent: hsl(210, 40%, 96%);
  --accent-foreground: hsl(222.2, 84%, 4.9%);
  --destructive: hsl(0, 84.2%, 60.2%);
  --destructive-foreground: hsl(210, 40%, 98%);
  --border: hsl(214.3, 31.8%, 91.4%);
  --input: hsl(214.3, 31.8%, 91.4%);
  --ring: hsl(224, 76%, 48%);
  --chart-1: hsl(12, 76%, 61%);
  --chart-2: hsl(173, 58%, 39%);
  --chart-3: hsl(197, 37%, 24%);
  --chart-4: hsl(43, 74%, 66%);
  --chart-5: hsl(27, 87%, 67%);
  --sidebar: hsl(0, 0%, 100%);
  --sidebar-foreground: hsl(222.2, 84%, 4.9%);
  --sidebar-primary: hsl(224, 76%, 48%);
  --sidebar-primary-foreground: hsl(0, 0%, 100%);
  --sidebar-accent: hsl(210, 40%, 96%);
  --sidebar-accent-foreground: hsl(222.2, 84%, 4.9%);
  --sidebar-border: hsl(214.3, 31.8%, 91.4%);
  --sidebar-ring: hsl(224, 76%, 48%);
  --font-sans: 'Inter', system-ui, -apple-system, sans-serif;
  --font-serif: Georgia, serif;
  --font-mono: Menlo, monospace;
  --radius: 0.75rem;
}

.dark {
  --background: hsl(222.2, 84%, 4.9%);
  --foreground: hsl(210, 40%, 98%);
  --card: hsl(222.2, 84%, 4.9%);
  --card-foreground: hsl(210, 40%, 98%);
  --popover: hsl(222.2, 84%, 4.9%);
  --popover-foreground: hsl(210, 40%, 98%);
  --primary: hsl(224, 76%, 48%);
  --primary-foreground: hsl(0, 0%, 100%);
  --secondary: hsl(217.2, 32.6%, 17.5%);
  --secondary-foreground: hsl(210, 40%, 98%);
  --muted: hsl(217.2, 32.6%, 17.5%);
  --muted-foreground: hsl(215, 20.2%, 65.1%);
  --accent: hsl(217.2, 32.6%, 17.5%);
  --accent-foreground: hsl(210, 40%, 98%);
  --destructive: hsl(0, 62.8%, 30.6%);
  --destructive-foreground: hsl(210, 40%, 98%);
  --border: hsl(217.2, 32.6%, 17.5%);
  --input: hsl(217.2, 32.6%, 17.5%);
  --ring: hsl(224.3, 76.3%, 94.1%);
  --sidebar: hsl(222.2, 84%, 4.9%);
  --sidebar-foreground: hsl(210, 40%, 98%);
  --sidebar-primary: hsl(224, 76%, 48%);
  --sidebar-primary-foreground: hsl(0, 0%, 100%);
  --sidebar-accent: hsl(217.2, 32.6%, 17.5%);
  --sidebar-accent-foreground: hsl(210, 40%, 98%);
  --sidebar-border: hsl(217.2, 32.6%, 17.5%);
  --sidebar-ring: hsl(224.3, 76.3%, 94.1%);
}

@layer base {
  * {
    @apply border-border;
  }

  body {
    @apply font-sans antialiased bg-background text-foreground;
  }
}

/* Anima√ß√µes customizadas para transi√ß√µes */
@keyframes heartPop {
  0% {
    transform: scale(0) rotate(0deg);
    opacity: 1;
  }
  15% {
    transform: scale(1.2) rotate(-5deg);
    opacity: 1;
  }
  30% {
    transform: scale(1) rotate(5deg);
    opacity: 1;
  }
  50% {
    transform: scale(1.1) rotate(-2deg) translateY(-20px);
    opacity: 0.8;
  }
  80% {
    transform: scale(0.8) rotate(2deg) translateY(-40px);
    opacity: 0.4;
  }
  100% {
    transform: scale(0.5) rotate(0deg) translateY(-60px);
    opacity: 0;
  }
}

/* ... Mais anima√ß√µes CSS omitidas para brevidade ... */
```

### client/src/components/TwoPartHeader.tsx
```tsx
import { useState, ReactNode } from "react";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { Search, X } from "lucide-react";
import { useScrollDetection } from "@/hooks/use-scroll-detection";

interface TwoPartHeaderProps {
  // Primeira parte - Header superior
  title?: string;
  titleComponent?: ReactNode;
  showSearch?: boolean;
  searchValue?: string;
  searchPlaceholder?: string;
  onSearchChange?: (value: string) => void;
  onSearchFocus?: () => void;
  onSearchBlur?: () => void;
  showNotifications?: boolean;
  notificationCount?: number;
  onNotificationClick?: () => void;
  
  // Segunda parte - Menu deslizante
  children?: ReactNode;
  
  
  // Personaliza√ß√£o visual
  gradient?: string;
  className?: string;
  
  // Controle do scroll
  scrollThreshold?: number;
  
  // Altura da primeira parte (para posicionar a segunda)
  headerHeight?: number;
}

/**
 * Componente reutiliz√°vel TwoPartHeader com header fixo e menu deslizante
 * Baseado na implementa√ß√£o do stores-gallery.tsx
 */
export function TwoPartHeader({
  title = "Click Ofertas.PY",
  titleComponent,
  showSearch = true,
  searchValue = "",
  searchPlaceholder = "Buscar produtos ou lojas...",
  onSearchChange,
  onSearchFocus,
  onSearchBlur,
  showNotifications = true,
  notificationCount = 0,
  onNotificationClick,
  children,
  gradient = "linear-gradient(135deg, #F04940 0%, #FA7D22 100%)",
  className = "",
  scrollThreshold = 100,
  headerHeight = 72
}: TwoPartHeaderProps) {
  
  const [searchInput, setSearchInput] = useState(searchValue);
  const [isSearchFocused, setIsSearchFocused] = useState(false);
  
  const { isVisible: isMenuVisible } = useScrollDetection({ 
    threshold: scrollThreshold 
  });

  const handleSearchChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const value = e.target.value;
    setSearchInput(value);
    onSearchChange?.(value);
  };

  const handleSearchFocus = () => {
    setIsSearchFocused(true);
    onSearchFocus?.();
  };

  const handleSearchBlur = () => {
    setIsSearchFocused(false);
    onSearchBlur?.();
  };

  const clearSearch = () => {
    setSearchInput('');
    onSearchChange?.('');
  };


  return (
    <>
      {/* PARTE 1: Header superior fixo (sempre vis√≠vel) */}
      <div 
        className={`fixed top-0 left-0 right-0 z-50 ${className}`}
        style={{ background: gradient }}
      >
        <div className="py-4 px-2 ml-[5%]">
          {/* Logo e Barra de Busca */}
          <div className="flex items-center gap-4">
            
            {/* T√≠tulo customiz√°vel */}
            {titleComponent || (
              <div className="flex items-center gap-1 flex-shrink-0">
                <span 
                  className="text-white font-bold text-2xl tracking-normal" 
                  style={{
                    textShadow: '0 1px 2px rgba(0,0,0,0.1)', 
                    fontWeight: '700'
                  }}
                >
                  {title.split('.')[0]}
                </span>
                {title.includes('.') && (
                  <span className="font-bold text-2xl tracking-normal">
                    <span className="text-white">.</span>
                    <span style={{color: '#FFE600'}}>
                      {title.split('.')[1]}
                    </span>
                  </span>
                )}
              </div>
            )}
            
            {/* Barra de Busca */}
            {showSearch && (
              <div className="flex-1 max-w-4xl">
                <div className="relative">
                  <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 w-4 h-4" />
                  <Input
                    placeholder={searchPlaceholder}
                    value={searchInput}
                    onChange={handleSearchChange}
                    onFocus={handleSearchFocus}
                    onBlur={handleSearchBlur}
                    className="pl-10 pr-10 py-2 w-full bg-white border-gray-200 text-gray-900 placeholder-gray-400 focus:border-blue-400 focus:ring-blue-200"
                    data-testid="header-search-input"
                  />
                  {searchInput && (
                    <button
                      onClick={clearSearch}
                      className="absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-400 hover:text-gray-600 transition-colors"
                      title="Limpar busca"
                      data-testid="clear-search-button"
                    >
                      <X className="w-4 h-4" />
                    </button>
                  )}
                </div>
              </div>
            )}

            {/* Bot√£o de Sauda√ß√£o */}
            <button
              className="bg-white/90 backdrop-blur-sm text-gray-600 hover:text-blue-500 px-3 py-2 rounded-lg shadow-sm transition-colors font-medium"
              title="Sauda√ß√£o"
              data-testid="greeting-button"
            >
              <span className="text-sm">üëã Ol√°!</span>
            </button>


            {/* Sino de notifica√ß√µes */}
            {showNotifications && (
              <button
                onClick={onNotificationClick}
                className="bg-white/90 backdrop-blur-sm text-gray-600 hover:text-orange-500 p-2 rounded-lg shadow-sm transition-colors relative"
                title="Notifica√ß√µes"
                data-testid="notifications-button"
              >
                <svg className="w-5 h-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                  <path d="M6 8a6 6 0 0 1 12 0c0 7 3 9 3 9H3s3-2 3-9"/>
                  <path d="M10.3 21a1.94 1.94 0 0 0 3.4 0"/>
                </svg>
                {/* Badge de notifica√ß√£o */}
                {notificationCount > 0 && (
                  <span 
                    className="absolute -top-1 -right-1 bg-red-500 text-white text-xs rounded-full w-5 h-5 flex items-center justify-center"
                    data-testid="notification-badge"
                  >
                    {notificationCount > 99 ? '99+' : notificationCount}
                  </span>
                )}
              </button>
            )}
          </div>
        </div>
      </div>

      {/* PARTE 2: Menu de navega√ß√£o (deslizante) */}
      {children && (
        <div 
          className={`fixed left-0 right-0 z-40 transition-transform duration-300 ease-in-out ${
            isMenuVisible ? 'translate-y-0' : '-translate-y-full'
          }`}
          style={{
            top: `${headerHeight}px`,
            background: gradient
          }}
          data-testid="sliding-menu"
        >
          <div className="py-3 px-2 ml-[5%]">
            <div className="flex items-center justify-start gap-3 -ml-2">
              {children}
            </div>
          </div>
        </div>
      )}
    </>
  );
}
```

### client/src/components/MiniMap.tsx
```tsx
import { useEffect, useState } from 'react';
import { MapContainer, TileLayer, Marker } from 'react-leaflet';
import { MapPin } from 'lucide-react';
import L from 'leaflet';

// Fix for default marker icons in React Leaflet
delete (L.Icon.Default.prototype as any)._getIconUrl;
L.Icon.Default.mergeOptions({
  iconRetinaUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-icon-2x.png',
  iconUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-icon.png',
  shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-shadow.png',
});

interface MiniMapProps {
  latitude: number | string;
  longitude: number | string;
  storeName?: string;
  onClick?: () => void;
  className?: string;
  size?: 'small' | 'medium' | 'large' | 'custom';
}

export function MiniMap({ 
  latitude, 
  longitude, 
  storeName = 'Loja', 
  onClick,
  className = '',
  size = 'medium'
}: MiniMapProps) {
  const [hasValidCoordinates, setHasValidCoordinates] = useState(false);
  const [mapKey, setMapKey] = useState(0);

  // Parse and validate coordinates
  const lat = typeof latitude === 'string' ? parseFloat(latitude) : latitude;
  const lng = typeof longitude === 'string' ? parseFloat(longitude) : longitude;

  useEffect(() => {
    const isValidLat = lat !== null && lat !== undefined && !isNaN(lat) && lat >= -90 && lat <= 90;
    const isValidLng = lng !== null && lng !== undefined && !isNaN(lng) && lng >= -180 && lng <= 180;
    setHasValidCoordinates(Boolean(isValidLat && isValidLng));
    
    // Force map re-render when coordinates change
    setMapKey(prev => prev + 1);
  }, [lat, lng]);

  const handleClick = () => {
    if (onClick && hasValidCoordinates) {
      onClick();
    }
  };

  // Get default size classes if not using custom
  const getSizeClasses = () => {
    if (size === 'custom') return '';
    const sizeMap = {
      small: 'w-12 h-8 sm:w-14 sm:h-10',
      medium: 'w-16 h-10 sm:w-20 sm:h-12',
      large: 'w-24 h-16 sm:w-28 sm:h-20'
    };
    return sizeMap[size] || sizeMap.medium;
  };

  if (!hasValidCoordinates) {
    return (
      <div 
        className={`
          ${getSizeClasses()}
          rounded-lg 
          bg-gray-100 dark:bg-gray-800 
          border border-gray-200 dark:border-gray-700
          shadow-sm
          flex items-center justify-center
          transition-all duration-200
          ${onClick ? 'cursor-pointer hover:shadow-md hover:bg-gray-50 dark:hover:bg-gray-750' : ''}
          ${className}
        `}
        onClick={handleClick}
        title={hasValidCoordinates ? "Ver no mapa" : "Localiza√ß√£o n√£o dispon√≠vel"}
        data-testid="minimap-placeholder"
      >
        <MapPin className="h-4 w-4 text-gray-400" />
      </div>
    );
  }

  return (
    <div 
      className={`
        relative z-0 isolate
        ${getSizeClasses()}
        rounded-lg 
        overflow-hidden 
        border border-gray-200 dark:border-gray-700
        shadow-sm
        transition-all duration-200
        ${onClick ? 'cursor-pointer hover:shadow-md' : ''}
        ${className}
      `}
      onClick={handleClick}
      title={onClick ? "Ver no mapa" : storeName}
      data-testid="minimap-container"
    >
      <MapContainer
        key={mapKey}
        center={[lat!, lng!]}
        zoom={14}
        style={{ height: '100%', width: '100%' }}
        className="minimap-leaflet"
        zoomControl={false}
        scrollWheelZoom={false}
        doubleClickZoom={false}
        touchZoom={false}
        boxZoom={false}
        keyboard={false}
        dragging={false}
        attributionControl={false}
        data-testid="minimap-leaflet-container"
      >
        <TileLayer
          url="https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png"
          attribution=""
        />
        <Marker 
          position={[lat!, lng!]} 
          data-testid="minimap-marker"
        />
      </MapContainer>
      
      {/* Clickable overlay for the entire map */}
      {onClick && (
        <div 
          className="absolute inset-0 bg-blue-600/20 hover:bg-blue-600/30 transition-all cursor-pointer flex flex-col items-center justify-center"
          onClick={handleClick}
          title="Clique para ver no mapa"
          data-testid="minimap-clickable-overlay"
        >
          <div className="text-white text-xs font-medium mb-1 text-center">
            Localiza√ß√£o
          </div>
          <div className="bg-blue-600 hover:bg-blue-700 text-white text-xs font-medium px-2 py-1 rounded shadow-lg transition-all">
            üìç Ver mapa
          </div>
        </div>
      )}
    </div>
  );
}
```

## BACKEND

### server/index.ts
```typescript
import express, { type Request, Response, NextFunction } from "express";
import { registerRoutes } from "./routes";
import { setupVite, serveStatic, log } from "./vite";
import { startCleanupJobs, startTrendingAnalysisJob } from "./cleanupJobs";
import path from "path";

const app = express();
// Aumentar limite de payload para suportar upload de imagens/v√≠deos maiores
app.use(express.json({ limit: '50mb' }));
app.use(express.urlencoded({ extended: false, limit: '50mb' }));

// Serve attached assets statically with cache headers
app.use('/attached_assets', express.static(path.resolve(process.cwd(), 'attached_assets'), {
  maxAge: '10m', // Cache por 10 minutos
  etag: true,
  lastModified: true
}));

app.use((req, res, next) => {
  const start = Date.now();
  const path = req.path;

  // S√≥ aplicar logging detalhado para rotas /api
  if (path.startsWith("/api")) {
    res.on("finish", () => {
      const duration = Date.now() - start;
      // Log apenas essenciais: method, path, status, duration
      const logLine = `${req.method} ${path} ${res.statusCode} in ${duration}ms`;
      log(logLine);
    });
  }

  next();
});

(async () => {
  const server = await registerRoutes(app);

  app.use((err: any, _req: Request, res: Response, _next: NextFunction) => {
    const status = err.status || err.statusCode || 500;
    const message = err.message || "Internal Server Error";

    res.status(status).json({ message });
    throw err;
  });

  // importantly only setup vite in development and after
  // setting up all the other routes so the catch-all route
  // doesn't interfere with the other routes
  if (app.get("env") === "development") {
    await setupVite(app, server);
  } else {
    serveStatic(app);
  }

  // ALWAYS serve the app on the port specified in the environment variable PORT
  // Other ports are firewalled. Default to 5000 if not specified.
  // this serves both the API and the client.
  // It is the only port that is not firewalled.
  const port = parseInt(process.env.PORT || '5000', 10);
  server.listen({
    port,
    host: "0.0.0.0",
    reusePort: true,
  }, () => {
    log(`serving on port ${port}`);
    
    // Modo desenvolvimento r√°pido: pular jobs pesados para evitar travamentos durante HMR
    const isDevelopment = app.get("env") === "development";
    const fastDev = process.env.FAST_DEV !== 'false'; // true por padr√£o
    
    if (!isDevelopment || !fastDev) {
      // Executar jobs de forma ass√≠ncrona ap√≥s um pequeno delay
      setTimeout(() => {
        startCleanupJobs().catch(console.error);
        startTrendingAnalysisJob().catch(console.error);
      }, 2000);
    } else {
      console.log("‚ö° Fast dev mode enabled - skipping heavy background jobs");
    }
  });
})();
```

### server/replitAuth.ts
```typescript
import * as client from "openid-client";
import { Strategy, type VerifyFunction } from "openid-client/passport";

import passport from "passport";
import session from "express-session";
import type { Express, RequestHandler } from "express";
import memoize from "memoizee";
import connectPg from "connect-pg-simple";
import { storage } from "./storage";

if (!process.env.REPLIT_DOMAINS) {
  throw new Error("Environment variable REPLIT_DOMAINS not provided");
}

const getOidcConfig = memoize(
  async () => {
    return await client.discovery(
      new URL(process.env.ISSUER_URL ?? "https://replit.com/oidc"),
      process.env.REPL_ID!
    );
  },
  { maxAge: 3600 * 1000 }
);

export function getSession() {
  const sessionTtl = 7 * 24 * 60 * 60 * 1000; // 1 week
  const pgStore = connectPg(session);
  const sessionStore = new pgStore({
    conString: process.env.DATABASE_URL,
    createTableIfMissing: false,
    ttl: sessionTtl,
    tableName: "sessions",
  });
  return session({
    secret: process.env.SESSION_SECRET!,
    store: sessionStore,
    resave: false,
    saveUninitialized: false,
    cookie: {
      httpOnly: true,
      secure: true,
      maxAge: sessionTtl,
    },
  });
}

function updateUserSession(
  user: any,
  tokens: client.TokenEndpointResponse & client.TokenEndpointResponseHelpers
) {
  user.claims = tokens.claims();
  user.access_token = tokens.access_token;
  user.refresh_token = tokens.refresh_token;
  user.expires_at = user.claims?.exp;
}

async function upsertUser(
  claims: any,
) {
  await storage.upsertUser({
    id: claims["sub"],
    email: claims["email"],
    firstName: claims["first_name"],
    lastName: claims["last_name"],
    profileImageUrl: claims["profile_image_url"],
  });
}

export async function setupAuth(app: Express) {
  app.set("trust proxy", 1);
  app.use(getSession());
  app.use(passport.initialize());
  app.use(passport.session());

  const config = await getOidcConfig();

  const verify: VerifyFunction = async (
    tokens: client.TokenEndpointResponse & client.TokenEndpointResponseHelpers,
    verified: passport.AuthenticateCallback
  ) => {
    const user = {};
    updateUserSession(user, tokens);
    await upsertUser(tokens.claims());
    verified(null, user);
  };

  for (const domain of process.env
    .REPLIT_DOMAINS!.split(",")) {
    const strategy = new Strategy(
      {
        name: `replitauth:${domain}`,
        config,
        scope: "openid email profile offline_access",
        callbackURL: `https://${domain}/api/callback`,
      },
      verify,
    );
    passport.use(strategy);
  }

  passport.serializeUser((user: Express.User, cb) => cb(null, user));
  passport.deserializeUser((user: Express.User, cb) => cb(null, user));

  app.get("/api/login", (req, res, next) => {
    passport.authenticate(`replitauth:${req.hostname}`, {
      prompt: "login consent",
      scope: ["openid", "email", "profile", "offline_access"],
    })(req, res, next);
  });

  app.get("/api/signup", (req, res) => {
    res.redirect('/api/login?signup=true');
  });

  app.get("/api/callback", (req, res, next) => {
    passport.authenticate(`replitauth:${req.hostname}`, 
      async (err: any, user: any) => {
        if (err || !user) {
          return res.redirect("/api/login");
        }
        
        // Fazer login do usu√°rio na sess√£o
        req.logIn(user, async (loginErr) => {
          if (loginErr) {
            return res.redirect("/api/login");
          }
          
          try {
            // Buscar dados do usu√°rio no banco para verificar se tem loja
            const userId = user.claims?.sub;
            if (userId) {
              const userData = await storage.getUser(userId);
              
              // Redirecionar baseado no perfil
              if (userData?.storeOwnerToken) {
                res.redirect("/admin");
              } else {
                res.redirect("/cards");
              }
            } else {
              res.redirect("/cards");
            }
          } catch (error) {
            console.error("Error checking user store status:", error);
            res.redirect("/cards");
          }
        });
      }
    )(req, res, next);
  });
}

export const isAuthenticated: RequestHandler = async (req: any, res, next) => {
  // Sistema personalizado de email/senha - verificar sess√£o
  if (req.session?.user?.id) {
    return next();
  }

  // Se n√£o h√° sess√£o personalizada, negar acesso
  return res.status(401).json({ message: "Unauthorized" });
};
```

## SCHEMA DE BANCO DE DADOS

### shared/schema.ts
```typescript
import { sql } from 'drizzle-orm';
import {
  boolean,
  index,
  integer,
  jsonb,
  pgTable,
  text,
  timestamp,
  varchar,
  decimal,
  unique,
} from "drizzle-orm/pg-core";
import { relations } from "drizzle-orm";
import { createInsertSchema } from "drizzle-zod";
import { z } from "zod";

// Session storage table for Replit Auth
export const sessions = pgTable(
  "sessions",
  {
    sid: varchar("sid").primaryKey(),
    sess: jsonb("sess").notNull(),
    expire: timestamp("expire").notNull(),
  },
  (table) => [index("IDX_session_expire").on(table.expire)],
);

// Funny messages for scratch cards
export const funnyMessages = pgTable("funny_messages", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  message: text("message").notNull(),
  emoji: text("emoji").notNull(),
  category: varchar("category", { length: 10 }).default("lose"), // 'lose', 'win'
  createdAt: timestamp("created_at").defaultNow(),
});

// User storage table for Replit Auth
export const users = pgTable("users", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  email: varchar("email").unique().notNull(),
  password: varchar("password"), // Hash da senha
  storeName: varchar("store_name"), // Nome da loja
  phone: varchar("phone"),
  address: text("address"), // Endere√ßo completo
  city: varchar("city"),
  firstName: varchar("first_name"),
  lastName: varchar("last_name"),
  fullName: varchar("full_name"),
  state: varchar("state"),
  country: varchar("country"),
  profileImageUrl: varchar("profile_image_url"),
  provider: varchar("provider").default("email"), // 'email', 'google', 'apple', 'replit'
  providerId: varchar("provider_id"),
  isEmailVerified: boolean("is_email_verified").default(false),
  storeOwnerToken: varchar("store_owner_token"),
  isSuperAdmin: boolean("is_super_admin").default(false), // Super admin do sistema
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});

// Store configuration table
export const stores = pgTable("stores", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  userId: varchar("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
  name: text("name").notNull(),
  logoUrl: text("logo_url"),
  themeColor: varchar("theme_color", { length: 7 }).default("#E11D48"),
  currency: varchar("currency", { length: 10 }).default("Gs."),
  displayCurrency: varchar("display_currency", { length: 10 }).default("local"), // "usd", "local", "both"
  dollarRate: decimal("dollar_rate", { precision: 10, scale: 2 }).default("7500"),
  bannerUrl: text("banner_url"),
  bannerText: text("banner_text"),
  bannerSubtext: text("banner_subtext"),
  bannerGradient: text("banner_gradient"),
  slug: text("slug").unique(),
  address: text("address"),
  whatsapp: varchar("whatsapp"),
  instagram: varchar("instagram"),
  isActive: boolean("is_active").default(true),
  isPremium: boolean("is_premium").default(false),
  customUsdBrlRate: text("custom_usd_brl_rate"), // Armazenado como string para precis√£o
  latitude: decimal("latitude", { precision: 10, scale: 8 }),
  longitude: decimal("longitude", { precision: 11, scale: 8 }),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});

// Product table
export const products = pgTable("products", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  storeId: varchar("store_id").notNull().references(() => stores.id, { onDelete: "cascade" }),
  name: text("name").notNull(),
  description: text("description"),
  price: decimal("price", { precision: 10, scale: 2 }).notNull(),
  imageUrl: text("image_url"),
  imageUrl2: text("image_url_2"),
  imageUrl3: text("image_url_3"),
  category: text("category"),
  brand: text("brand"),
  gtin: text("gtin"), // C√≥digo de barras global
  productCode: text("product_code"), // C√≥digo interno da loja
  isActive: boolean("is_active").default(true),
  isFeatured: boolean("is_featured").default(false),
  showInStories: boolean("show_in_stories").default(false),
  showInTotem: boolean("show_in_totem").default(false),
  sortOrder: text("sort_order").default("0"),
  sourceType: varchar("source_type", { length: 20 }).default("manual"), // "manual", "icecat", "mercadolibre"
  // Scratch card properties
  isScratchCard: boolean("is_scratch_card").default(false),
  scratchMessage: text("scratch_message"),
  scratchPrice: decimal("scratch_price", { precision: 10, scale: 2 }),
  scratchExpiresAt: timestamp("scratch_expires_at"),
  scratchTimeLimitMinutes: integer("scratch_time_limit_minutes"),
  scratchBackgroundColor: varchar("scratch_background_color", { length: 7 }),
  maxScratchRedemptions: integer("max_scratch_redemptions"),
  currentScratchRedemptions: integer("current_scratch_redemptions").default(0),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});

// ... Mais tabelas do schema omitidas para brevidade ...

// TIPOS TYPESCRIPT EXPORTADOS
export type User = typeof users.$inferSelect;
export type InsertUser = typeof users.$inferInsert;
export type UpsertUser = InsertUser;

export type Store = typeof stores.$inferSelect;
export type InsertStore = typeof stores.$inferInsert;
export type UpdateStore = Partial<InsertStore>;

export type Product = typeof products.$inferSelect;
export type InsertProduct = typeof products.$inferInsert;
export type UpdateProduct = Partial<InsertProduct>;

export type StoreWithProducts = Store & {
  products: Product[];
  totalProducts?: number;
};

// ... Mais tipos omitidos para brevidade ...
```

### server/storage.ts
```typescript
import {
  users,
  stores,
  products,
  savedProducts,
  storyViews,
  flyerViews,
  productLikes,
  scratchedProducts,
  coupons,
  scratchCampaigns,
  virtualScratchClones,
  promotions,
  promotionScratches,
  promotionAssignments,
  instagramStories,
  instagramStoryViews,
  instagramStoryLikes,
  brazilianPrices,
  priceComparisons,
  productSuggestions,
  priceHistory,
  priceAlerts,
  banners,
  bannerViews,
  bannerClicks,
  // Sistema de raspadinha di√°ria
  dailyPrizes,
  userDailyAttempts,
  scratchSystemConfig,
  algorithmSuggestions,
  dailyScratchResults,
  dailyScratchCards,
  budgetConfig,
  funnyMessages,
  maintenanceMode,
  totemContent,
  totemSettings,
  // Metadados an√¥nimos para analytics
  userSessions,
  productSearches,
  productViews,
  trendingProducts,
  generatedTotemArts,
  categories,
  type User,
  type UpsertUser,
  type InsertUser,
  type Store,
  type InsertStore,
  type UpdateStore,
  type Product,
  type InsertProduct,
  type UpdateProduct,
  type StoreWithProducts,
  type SavedProduct,
  type InsertSavedProduct,
  type StoryView,
  type InsertStoryView,
  type FlyerView,
  type InsertFlyerView,
  type ProductLike,
  type InsertProductLike,
  type ScratchedProduct,
  type InsertScratchedProduct,
  type SavedProductWithDetails,
  type Coupon,
  type InsertCoupon,
  type CouponWithDetails,
  type ScratchCampaign,
  type InsertScratchCampaign,
  type VirtualScratchClone,
  type InsertVirtualScratchClone,
  type ScratchCampaignWithDetails,
  type VirtualScratchCloneWithDetails,
  type Promotion,
  type InsertPromotion,
  type UpdatePromotion,
  type PromotionScratch,
  type InsertPromotionScratch,
  type PromotionAssignment,
  type InsertPromotionAssignment,
  type UpdatePromotionAssignment,
  type PromotionWithDetails,
  type InstagramStory,
  type InsertInstagramStory,
  type UpdateInstagramStory,
  type InstagramStoryView,
  type InsertInstagramStoryView,
  type InstagramStoryLike,
  type InsertInstagramStoryLike,
  type InstagramStoryWithDetails,
  type BrazilianPrice,
  type InsertBrazilianPrice,
  type PriceComparison,
  type InsertPriceComparison,
  type ProductSuggestion,
  type InsertProductSuggestion,
  type PriceComparisonWithDetails,
  type PriceHistory,
  type InsertPriceHistory,
  type PriceAlert,
  type InsertPriceAlert,
  type Banner,
  type InsertBanner,
  // Tipos do sistema de raspadinha di√°ria
  type DailyPrize,
  type InsertDailyPrize,
  type UserDailyAttempt,
  type InsertUserDailyAttempt,
  type ScratchSystemConfig,
  type InsertScratchSystemConfig,
  type AlgorithmSuggestion,
  type InsertAlgorithmSuggestion,
  type DailyScratchResult,
  type InsertDailyScratchResult,
  type DailyScratchCard,
  type InsertDailyScratchCard,
  type BudgetConfig,
  type InsertBudgetConfig,
  type TotemContent,
  type InsertTotemContent,
  type TotemSettings,
  type InsertTotemSettings,
  type UpdateTotemSettings,
  insertTotemContentSchema,
  updateTotemContentSchema,
  insertTotemSettingsSchema,
  updateTotemSettingsSchema,
  // Types de metadados an√¥nimos
  type UserSession,
  type InsertUserSession,
  type ProductSearch,
  type InsertProductSearch,
  type ProductView,
  type InsertProductView,
  type TrendingProduct,
  type InsertTrendingProduct,
  type GeneratedTotemArt,
  type InsertGeneratedTotemArt,
  // Categories
  type Category,
  type InsertCategory,
  type UpdateCategory,
} from "@shared/schema";
import { db } from "./db";
import { eq, and, desc, asc, count, gte, lte, lt, sql, inArray, or, isNull } from "drizzle-orm";

export interface IStorage {
  // User operations (required for Replit Auth)
  getUser(id: string): Promise<User | undefined>;
  getUserByEmail(email: string): Promise<User | undefined>;
  createUser(user: InsertUser): Promise<User>;
  upsertUser(user: UpsertUser): Promise<User>;
  updateUser(id: string, updates: Partial<User>): Promise<User>;
  getAllUsers(): Promise<User[]>;
  deleteUser(id: string): Promise<void>;

  // Store operations
  getUserStore(userId: string): Promise<Store | undefined>;
  createStore(userId: string, store: InsertStore): Promise<Store>;
  updateStore(storeId: string, store: UpdateStore): Promise<Store>;
  getStoreBySlug(slug: string): Promise<StoreWithProducts | undefined>;
  getAllActiveStores(): Promise<StoreWithProducts[]>;
  getAllActiveStoresOptimized(limit?: number, productsPerStore?: number): Promise<StoreWithProducts[]>;
  getAllStores(): Promise<StoreWithProducts[]>;
  deleteStore(storeId: string, userId: string, isSuperAdmin?: boolean): Promise<void>;

  // Product operations
  getStoreProducts(storeId: string): Promise<Product[]>;
  createProduct(storeId: string, product: InsertProduct): Promise<Product>;
  updateProduct(productId: string, storeId: string, product: UpdateProduct): Promise<Product>;
  deleteProduct(productId: string, storeId: string): Promise<void>;
  getProduct(productId: string, storeId: string): Promise<Product | undefined>;
  getProductById(productId: string): Promise<Product | undefined>;

  // Engagement operations
  createProductLike(like: InsertProductLike): Promise<ProductLike>;
  saveProduct(savedProduct: InsertSavedProduct): Promise<SavedProduct>;
  getSavedProducts(userId: string): Promise<SavedProductWithDetails[]>;
  removeSavedProduct(savedProductId: string, userId: string): Promise<void>;
  createStoryView(view: InsertStoryView): Promise<StoryView>;
  createFlyerView(view: InsertFlyerView): Promise<FlyerView>;
  getStoreAnalytics(storeId: string, days?: number): Promise<any>;
  getStoresByUserId(userId: string): Promise<Store[]>;
  getTopProductsByEngagement(storeId: string, days?: number): Promise<any[]>;

  // Scratch card operations
  createScratchedProduct(scratch: InsertScratchedProduct): Promise<ScratchedProduct>;
  getScratchedProduct(productId: string, userId?: string): Promise<ScratchedProduct | undefined>;
  updateScratchRedemptionCount(productId: string): Promise<void>;

  // Coupon operations
  createCoupon(coupon: InsertCoupon): Promise<Coupon>;
  getUserCoupons(userId?: string): Promise<CouponWithDetails[]>;
  getCouponByCode(couponCode: string): Promise<CouponWithDetails | undefined>;
  redeemCoupon(couponCode: string): Promise<Coupon>;
  getCoupon(couponId: string): Promise<CouponWithDetails | undefined>;
  
  // Verifica√ß√£o para galeria
  shouldShowProductInGallery(productId: string): Promise<boolean>;
  getCouponsCountForProduct(productId: string): Promise<number>;
  
  // Scratch Campaign operations (NEW - Virtual Clones System)
  createScratchCampaign(campaign: InsertScratchCampaign): Promise<ScratchCampaign>;
  getScratchCampaignByProduct(productId: string): Promise<ScratchCampaignWithDetails | undefined>;
  updateScratchCampaign(campaignId: string, updates: Partial<ScratchCampaign>): Promise<ScratchCampaign>;
  deactivateScratchCampaign(campaignId: string): Promise<void>;
  getCampaignStats(campaignId: string): Promise<{usedClones: number, totalClones: number, expiredClones: number}>;
  
  // Virtual Clone operations (NEW)
  createVirtualClones(campaignId: string, assignedUserIds: string[], productSnapshot: any): Promise<VirtualScratchClone[]>;
  getVirtualCloneById(cloneId: string): Promise<VirtualScratchCloneWithDetails | undefined>;
  getUserAvailableClone(userId: string, productId: string): Promise<VirtualScratchCloneWithDetails | undefined>;
  markCloneAsUsed(cloneId: string): Promise<VirtualScratchClone>;
  markExpiredClones(): Promise<void>;
  deleteUnusedClones(campaignId: string): Promise<void>;
  
  // User lottery/selection operations (NEW)
  getAllRegisteredUsers(): Promise<User[]>;
  selectRandomUsers(userPool: User[], maxSelections: number): Promise<User[]>;
  
  // Delete cupom
  deleteCoupon(couponId: string): Promise<void>;
  
  // üßπ M√âTODO TEMPOR√ÅRIO: Excluir todos os cupons do usu√°rio (para testes)
  deleteAllUserCoupons(userId: string): Promise<void>;

  // NEW: Promotion operations (Simplified System)
  getStorePromotions(storeId: string): Promise<PromotionWithDetails[]>;
  getPromotion(promotionId: string): Promise<PromotionWithDetails | undefined>;
  createPromotion(storeId: string, promotion: InsertPromotion): Promise<Promotion>;
  updatePromotion(promotionId: string, updates: UpdatePromotion): Promise<Promotion>;
  deletePromotion(promotionId: string): Promise<void>;
  canUserScratchPromotion(promotionId: string, userId?: string, userAgent?: string, ipAddress?: string): Promise<{allowed: boolean, reason: string, promotion?: Promotion}>;
  createPromotionScratch(scratch: InsertPromotionScratch): Promise<PromotionScratch>;
  incrementPromotionUsage(promotionId: string): Promise<boolean>;
  getActivePromotions(): Promise<PromotionWithDetails[]>;
  getPromotionStats(promotionId: string): Promise<any>;
  markExpiredPromotions(): Promise<number>;

  // NEW: Promotion Assignment operations (User-specific promotions)
  createPromotionAssignment(assignment: InsertPromotionAssignment): Promise<PromotionAssignment>;
  createPromotionAssignments(assignments: InsertPromotionAssignment[]): Promise<PromotionAssignment[]>;
  getUserPromotionAssignments(userId: string, storeId: string): Promise<PromotionAssignment[]>;
  updatePromotionAssignmentStatus(promotionId: string, userId: string, status: 'assigned' | 'generated' | 'redeemed'): Promise<PromotionAssignment>;
  getMyAvailablePromotions(userId: string, storeId: string): Promise<PromotionWithDetails[]>;
  hasUserGeneratedCoupon(promotionId: string, userId: string): Promise<boolean>;

  // NEW: Instagram Stories operations 
  createInstagramStory(story: InsertInstagramStory): Promise<InstagramStory>;
  getStoreInstagramStories(storeId: string): Promise<InstagramStoryWithDetails[]>;
  getAllActiveInstagramStories(): Promise<InstagramStoryWithDetails[]>;
  getInstagramStory(storyId: string): Promise<InstagramStoryWithDetails | undefined>;
  updateInstagramStory(storyId: string, updates: UpdateInstagramStory): Promise<InstagramStory>;
  deleteInstagramStory(storyId: string): Promise<void>;
  createInstagramStoryView(view: InsertInstagramStoryView): Promise<InstagramStoryView>;
  createInstagramStoryLike(like: InsertInstagramStoryLike): Promise<InstagramStoryLike>;
  removeInstagramStoryLike(storyId: string, userId: string): Promise<void>;
  incrementStoryViewsCount(storyId: string): Promise<void>;
  incrementStoryLikesCount(storyId: string): Promise<void>;
  decrementStoryLikesCount(storyId: string): Promise<void>;
  getUserInstagramStories(userId: string): Promise<InstagramStoryWithDetails[]>;
  expireOldStories(): Promise<void>;

  // NEW: Store user management (for dual authentication)
  createStoreUser(storeId: string, storeData: any): Promise<User>;
  getStoreUser(storeId: string): Promise<User | undefined>;

  // Price comparison operations
  getProductsForComparison(): Promise<Product[]>;
  getProductWithStore(productId: string): Promise<(Product & { store?: Store }) | undefined>;
  getAllProducts(): Promise<Product[]>;
  saveBrazilianPrice(priceData: InsertBrazilianPrice): Promise<BrazilianPrice>;
  getBrazilianPricesByProduct(productName: string): Promise<BrazilianPrice[]>;
  savePriceComparison(comparison: InsertPriceComparison): Promise<PriceComparison>;
  getUserPriceComparisons(userId: string): Promise<PriceComparisonWithDetails[]>;
  saveProductSuggestion(suggestion: InsertProductSuggestion): Promise<ProductSuggestion>;

  // Price alerts operations
  createPriceAlert(alert: InsertPriceAlert): Promise<PriceAlert>;
  getUserPriceAlerts(userId: string): Promise<PriceAlert[]>;
  getPriceAlert(alertId: string): Promise<PriceAlert | undefined>;
  deletePriceAlert(alertId: string): Promise<void>;

  // Daily Scratch System operations
  getDailyPrizes(): Promise<DailyPrize[]>;
  getActiveDailyPrizes(): Promise<DailyPrize[]>;
  getDailyPrize(prizeId: string): Promise<DailyPrize | undefined>;
  createDailyPrize(prize: InsertDailyPrize): Promise<DailyPrize>;
  updateDailyPrize(prizeId: string, updates: Partial<DailyPrize>): Promise<DailyPrize>;
  incrementPrizeWins(prizeId: string): Promise<void>;

  getUserDailyAttempt(userId: string, date: string): Promise<UserDailyAttempt[]>;
  createUserDailyAttempt(attempt: InsertUserDailyAttempt): Promise<UserDailyAttempt>;

  getScratchSystemConfig(): Promise<ScratchSystemConfig | undefined>;
  updateScratchSystemConfig(updates: Partial<ScratchSystemConfig>): Promise<ScratchSystemConfig>;

  getAlgorithmSuggestions(): Promise<AlgorithmSuggestion[]>;
  updateAlgorithmSuggestion(suggestionId: string, updates: Partial<AlgorithmSuggestion>): Promise<AlgorithmSuggestion>;

  createDailyScratchResult(result: InsertDailyScratchResult): Promise<DailyScratchResult>;

  // Budget operations
  getBudgetConfig(): Promise<BudgetConfig | undefined>;
  updateBudgetConfig(updates: Partial<BudgetConfig>): Promise<BudgetConfig>;
  getBudgetStats(): Promise<any>;
  getAvailableProductsForPrizes(): Promise<Product[]>;

  // Totem operations
  getTotemContent(storeId: string): Promise<TotemContent[]>;
  createTotemContent(content: InsertTotemContent): Promise<TotemContent>;
  updateTotemContent(id: string, storeId: string, content: Partial<InsertTotemContent>): Promise<TotemContent>;
  deleteTotemContent(id: string, storeId: string): Promise<void>;
  
  getTotemSettings(storeId: string): Promise<TotemSettings | undefined>;
  upsertTotemSettings(storeId: string, settings: InsertTotemSettings | UpdateTotemSettings): Promise<TotemSettings>;
  updateTotemLastSync(storeId: string): Promise<void>;

  // Analytics operations (metadados an√¥nimos)
  createUserSession(session: InsertUserSession): Promise<UserSession>;
  updateUserSession(sessionToken: string, updates: { visitDuration?: number; pagesViewed?: number }): Promise<void>;
  createProductSearch(search: InsertProductSearch): Promise<ProductSearch>;
  createProductView(view: InsertProductView): Promise<ProductView>;
  updateProductSearchClick(sessionToken: string, productId: string, searchTerm?: string): Promise<void>;
  updateProductViewAction(sessionToken: string, productId: string, action: 'save' | 'compare'): Promise<void>;
  getTrendingProducts(days?: number): Promise<TrendingProduct[]>;
  generateTrendingProducts(date: Date): Promise<TrendingProduct[]>;
  createGeneratedTotemArt(art: InsertGeneratedTotemArt): Promise<GeneratedTotemArt>;
  getGeneratedTotemArts(storeId: string): Promise<GeneratedTotemArt[]>;

  // Categories operations
  getAllCategories(): Promise<Category[]>;
  getActiveCategories(): Promise<Category[]>;
  getCategoryById(id: string): Promise<Category | undefined>;
  createCategory(category: InsertCategory): Promise<Category>;
  updateCategory(id: string, category: UpdateCategory): Promise<Category>;
  deleteCategory(id: string): Promise<void>;
  toggleCategoryStatus(id: string): Promise<Category>;
}

export class DatabaseStorage implements IStorage {
  // User operations
  async getUser(id: string): Promise<User | undefined> {
    const [user] = await db.select().from(users).where(eq(users.id, id));
    return user;
  }

  async getUserByEmail(email: string): Promise<User | undefined> {
    const [user] = await db.select().from(users).where(eq(users.email, email));
    return user;
  }

  async createUser(userData: InsertUser): Promise<User> {
    const [user] = await db
      .insert(users)
      .values({
        ...userData,
        provider: userData.provider || 'email'
      })
      .returning();
    return user;
  }

  async upsertUser(userData: UpsertUser): Promise<User> {
    const [user] = await db
      .insert(users)
      .values(userData)
      .onConflictDoUpdate({
        target: users.id,
        set: {
          ...userData,
          updatedAt: new Date(),
        },
      })
      .returning();
    return user;
  }

  // ... Implementa√ß√µes dos m√©todos omitidas para brevidade ...

  private generateSlug(name: string): string {
    return name
      .toLowerCase()
      .normalize("NFD")
      .replace(/[\u0300-\u036f]/g, "")
      .replace(/[^\w\s-]/g, "")
      .replace(/[\s_-]+/g, "-")
      .replace(/^-+|-+$/g, "");
  }
}

export const storage = new DatabaseStorage();
```

### Principais Rotas do Backend - server/routes.ts (TRECHO)
```typescript
import type { Express } from "express";
import { createServer, type Server } from "http";
import { storage } from "./storage";
import { setupAuth, isAuthenticated } from "./replitAuth";
import { getUserId } from "./utils/auth";
import { generatePromotionalArt } from "../gemini.js";
import multer from "multer";
import path from "path";
import fs from "fs";

// Middleware para verificar autentica√ß√£o (sess√£o manual ou Replit Auth)
const isAuthenticatedCustom = async (req: any, res: any, next: any) => {
  try {
    // 1. Verificar sess√£o manual primeiro (usu√°rios registrados via formul√°rio)
    if (req.session?.user) {
      return next();
    }
    
    // 2. Verificar Replit OIDC Auth (sistema principal do projeto)
    if (req.user?.claims?.sub || req.user?.id) {
      return next();
    }
    
    // Se nenhuma autentica√ß√£o foi encontrada, negar acesso
    return res.status(401).json({ message: "Unauthorized" });
    
  } catch (error) {
    console.error('Erro no middleware de autentica√ß√£o:', error);
    return res.status(500).json({ message: "Internal server error" });
  }
};

// Middleware para verificar super admin
const isSuperAdmin = async (req: any, res: any, next: any) => {
  try {
    let user = null;
    console.log('üîç isSuperAdmin middleware - verificando autentica√ß√£o...');
    
    // Verificar sess√£o manual primeiro (usu√°rios registrados via formul√°rio)
    if (req.session?.user) {
      user = req.session.user;
      console.log('‚úÖ Usu√°rio encontrado via sess√£o manual:', { id: user.id, email: user.email, isSuperAdmin: user.isSuperAdmin });
    }
    // Verificar autentica√ß√£o Replit como fallback
    else if (req.user?.claims?.sub || req.user?.id) {
      const userId = req.user?.claims?.sub || req.user?.id;
      console.log('üîç Verificando via Replit Auth, userId:', userId);
      user = await storage.getUser(userId);
      console.log('‚úÖ Usu√°rio encontrado via Replit Auth:', user ? { id: user.id, email: user.email, isSuperAdmin: user.isSuperAdmin } : 'n√£o encontrado');
    }
    
    if (!user) {
      console.log('‚ùå Nenhum usu√°rio encontrado');
      return res.status(401).json({ message: "Unauthorized" });
    }
    
    if (!user?.isSuperAdmin) {
      console.log('‚ùå Usu√°rio n√£o √© super admin:', { id: user.id, isSuperAdmin: user.isSuperAdmin });
      return res.status(403).json({ message: "Access denied - Super Admin required" });
    }

    console.log('‚úÖ Super admin verificado com sucesso:', user.id);
    next();
  } catch (error) {
    console.error("Error checking super admin:", error);
    res.status(500).json({ message: "Server error" });
  }
};

export async function registerRoutes(app: Express): Promise<Server> {
  // Configurar autentica√ß√£o Replit OIDC
  await setupAuth(app);

  // ROTAS P√öBLICAS
  
  // Buscar lojas p√∫blicas
  app.get("/api/public/stores", async (req, res) => {
    try {
      const stores = await storage.getAllActiveStoresOptimized(50, 10);
      res.json(stores);
    } catch (error) {
      console.error("Error fetching public stores:", error);
      res.status(500).json({ message: "Server error" });
    }
  });

  // Buscar loja espec√≠fica por slug (p√∫blico)
  app.get("/api/public/stores/:slug", async (req, res) => {
    try {
      const store = await storage.getStoreBySlug(req.params.slug);
      if (!store) {
        return res.status(404).json({ message: "Store not found" });
      }
      res.json(store);
    } catch (error) {
      console.error("Error fetching store:", error);
      res.status(500).json({ message: "Server error" });
    }
  });

  // ROTAS AUTENTICADAS
  
  // Buscar lojas do usu√°rio
  app.get("/api/stores", isAuthenticatedCustom, async (req: any, res) => {
    try {
      const userId = getUserId(req);
      if (!userId) {
        return res.status(401).json({ message: "Unauthorized" });
      }

      const stores = await storage.getStoresByUserId(userId);
      res.json(stores);
    } catch (error) {
      console.error("Error fetching user stores:", error);
      res.status(500).json({ message: "Server error" });
    }
  });

  // Criar nova loja
  app.post("/api/stores", isAuthenticatedCustom, async (req: any, res) => {
    try {
      const userId = getUserId(req);
      if (!userId) {
        return res.status(401).json({ message: "Unauthorized" });
      }

      // Verificar se o usu√°rio j√° tem uma loja
      const existingStore = await storage.getUserStore(userId);
      if (existingStore) {
        return res.status(400).json({ message: "User already has a store" });
      }

      const store = await storage.createStore(userId, req.body);
      res.status(201).json(store);
    } catch (error) {
      console.error("Error creating store:", error);
      res.status(500).json({ message: "Server error" });
    }
  });

  // Buscar produtos da loja
  app.get("/api/stores/:storeId/products", isAuthenticatedCustom, async (req: any, res) => {
    try {
      const products = await storage.getStoreProducts(req.params.storeId);
      res.json(products);
    } catch (error) {
      console.error("Error fetching products:", error);
      res.status(500).json({ message: "Server error" });
    }
  });

  // Criar novo produto
  app.post("/api/stores/:storeId/products", isAuthenticatedCustom, async (req: any, res) => {
    try {
      const product = await storage.createProduct(req.params.storeId, req.body);
      res.status(201).json(product);
    } catch (error) {
      console.error("Error creating product:", error);
      res.status(500).json({ message: "Server error" });
    }
  });

  // Atualizar produto
  app.put("/api/stores/:storeId/products/:productId", isAuthenticatedCustom, async (req: any, res) => {
    try {
      const product = await storage.updateProduct(req.params.productId, req.params.storeId, req.body);
      res.json(product);
    } catch (error) {
      console.error("Error updating product:", error);
      res.status(500).json({ message: "Server error" });
    }
  });

  // Deletar produto
  app.delete("/api/stores/:storeId/products/:productId", isAuthenticatedCustom, async (req: any, res) => {
    try {
      await storage.deleteProduct(req.params.productId, req.params.storeId);
      res.status(204).send();
    } catch (error) {
      console.error("Error deleting product:", error);
      res.status(500).json({ message: "Server error" });
    }
  });

  // Buscar promo√ß√µes dispon√≠veis para o usu√°rio em uma loja espec√≠fica
  app.get("/api/stores/:slug/my-available-promotions", async (req: any, res) => {
    try {
      const { slug } = req.params;
      
      // Buscar a loja pelo slug
      const store = await storage.getStoreBySlug(slug);
      if (!store) {
        return res.status(404).json({ message: "Store not found" });
      }

      let userId = null;
      
      // Verificar autentica√ß√£o (tanto sess√£o manual quanto Replit Auth)
      if (req.session?.user?.id) {
        userId = req.session.user.id;
      } else if (req.user?.claims?.sub || req.user?.id) {
        userId = req.user?.claims?.sub || req.user?.id;
      }

      let promotions = [];
      
      if (userId) {
        // Usu√°rio autenticado: buscar promo√ß√µes personalizadas
        promotions = await storage.getMyAvailablePromotions(userId, store.id);
      } else {
        // Usu√°rio n√£o autenticado: buscar promo√ß√µes p√∫blicas gerais
        const allPromotions = await storage.getActivePromotions();
        promotions = allPromotions.filter(promo => 
          promo.storeId === store.id && 
          promo.isPublic === true &&
          promo.maxUsage > promo.currentUsage
        );
      }

      res.json({
        promotions,
        storeId: store.id,
        userId: userId || null
      });
    } catch (error) {
      console.error("Error fetching user promotions:", error);
      res.status(500).json({ message: "Server error" });
    }
  });

  // SUPER ADMIN ROUTES
  
  // Buscar todas as lojas (Super Admin)
  app.get("/api/admin/stores", isSuperAdmin, async (req, res) => {
    try {
      const stores = await storage.getAllStores();
      res.json(stores);
    } catch (error) {
      console.error("Error fetching all stores:", error);
      res.status(500).json({ message: "Server error" });
    }
  });

  // ROTAS DE ANALYTICS

  // Registrar visualiza√ß√£o de produto
  app.post("/api/analytics/product-views", async (req: any, res) => {
    try {
      const { productId, storeId, sessionToken } = req.body;
      
      if (!productId || !storeId || !sessionToken) {
        return res.status(400).json({ message: "Missing required fields" });
      }

      await storage.createProductView({
        productId,
        storeId,
        sessionToken,
        timestamp: new Date(),
      });

      res.status(201).json({ message: "Product view recorded" });
    } catch (error) {
      console.error("Error recording product view:", error);
      res.status(500).json({ message: "Server error" });
    }
  });

  // Registrar busca de produto
  app.post("/api/analytics/product-searches", async (req: any, res) => {
    try {
      const { searchTerm, sessionToken, resultsCount } = req.body;
      
      if (!searchTerm || !sessionToken) {
        return res.status(400).json({ message: "Missing required fields" });
      }

      await storage.createProductSearch({
        searchTerm,
        sessionToken,
        resultsCount: resultsCount || 0,
        timestamp: new Date(),
      });

      res.status(201).json({ message: "Product search recorded" });
    } catch (error) {
      console.error("Error recording product search:", error);
      res.status(500).json({ message: "Server error" });
    }
  });

  // ... Mais rotas omitidas para brevidade ...

  const httpServer = createServer(app);
  return httpServer;
}
```

## FUNCIONALIDADES ESPECIAIS

### Sistema de Mapas - MiniMap + MapModal
O projeto inclui um sistema completo de mapas usando Leaflet + React Leaflet:
- **MiniMap**: Componente compacto para preview de localiza√ß√£o
- **MapModal**: Modal completo com mapa interativo
- Integra√ß√£o com Google Maps para dire√ß√µes
- Coordenadas armazenadas no banco de dados (latitude/longitude)

### Sistema de PWA (Progressive Web App)
- **Manifest din√¢mico**: Gerado via JavaScript no HTML
- **Service Worker**: Registrado apenas em produ√ß√£o
- **√çcones adaptativos**: SVG embutido + √≠cones PNG
- **Configura√ß√£o iOS**: Meta tags para iPhone/iPad
- **Modo standalone**: Funciona como app nativo

### Sistema de Autentica√ß√£o H√≠brido
- **Replit OIDC**: Autentica√ß√£o principal via OpenID Connect
- **Sess√µes locais**: Sistema de backup com email/senha
- **Super Admin**: Controle de acesso administrativo
- **Middleware duplo**: Verifica ambos os sistemas

### Sistema de Raspadinhas e Promo√ß√µes
- **Scratch Cards**: Cartas de raspagem interativas
- **Promo√ß√µes personalizadas**: Por usu√°rio e loja
- **Sistema de cupons**: Gera√ß√£o e valida√ß√£o
- **Algoritmo inteligente**: Distribui√ß√£o automatizada

### Sistema de Analytics An√¥nimo
- **Sess√µes de usu√°rio**: Rastreamento via tokens
- **Visualiza√ß√µes de produto**: M√©tricas de engajamento
- **Produtos em tend√™ncia**: Algoritmo de popularidade
- **Dados agregados**: Sem informa√ß√µes pessoais

### Sistema de Instagram Stories
- **Stories por loja**: Conte√∫do tempor√°rio
- **Visualiza√ß√µes e likes**: Engajamento social
- **Expira√ß√£o autom√°tica**: Limpeza de conte√∫do antigo
- **Upload de m√≠dia**: Suporte a imagem/v√≠deo

### Sistema de Compara√ß√£o de Pre√ßos
- **Scraping Brasil**: Pre√ßos do mercado brasileiro
- **Integra√ß√£o Icecat**: Cat√°logo internacional de produtos
- **MercadoLibre API**: Dados do Paraguai
- **Alertas de pre√ßo**: Notifica√ß√µes personalizadas

### Sistema de Totem Digital
- **Exibi√ß√£o p√∫blica**: Interface para TVs/monitores
- **Conte√∫do din√¢mico**: Sincroniza√ß√£o autom√°tica
- **Arte gerada por IA**: Banners promocionais
- **Configura√ß√£o flex√≠vel**: Por loja

## ESTRUTURA DE ARQUIVOS

```
‚îú‚îÄ‚îÄ client/                 # Frontend React
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ components/     # Componentes reutiliz√°veis
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ pages/         # P√°ginas da aplica√ß√£o
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ hooks/         # Custom hooks
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ lib/           # Utilit√°rios
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ types/         # Tipos TypeScript
‚îÇ   ‚îî‚îÄ‚îÄ index.html         # HTML principal
‚îú‚îÄ‚îÄ server/                # Backend Express
‚îÇ   ‚îú‚îÄ‚îÄ services/          # Servi√ßos externos
‚îÇ   ‚îú‚îÄ‚îÄ utils/             # Utilit√°rios do servidor
‚îÇ   ‚îî‚îÄ‚îÄ *.ts              # Arquivos principais
‚îú‚îÄ‚îÄ shared/                # C√≥digo compartilhado
‚îÇ   ‚îî‚îÄ‚îÄ schema.ts          # Schema do banco
‚îú‚îÄ‚îÄ public/                # Assets est√°ticos
‚îú‚îÄ‚îÄ uploads/               # Uploads de usu√°rios
‚îî‚îÄ‚îÄ attached_assets/       # Assets anexados

PRINCIPAIS ARQUIVOS:
- package.json             # Depend√™ncias
- vite.config.ts          # Configura√ß√£o Vite
- tailwind.config.ts      # Configura√ß√£o Tailwind
- drizzle.config.ts       # Configura√ß√£o banco
- tsconfig.json           # Configura√ß√£o TypeScript
```

## PRINCIPAIS TECNOLOGIAS

### Frontend
- **React 18** + **TypeScript**
- **Vite** (build tool)
- **Tailwind CSS** + **shadcn/ui**
- **TanStack Query** (data fetching)
- **Wouter** (routing)
- **React Hook Form** + **Zod**
- **Leaflet** (mapas)
- **Framer Motion** (anima√ß√µes)

### Backend
- **Node.js** + **Express**
- **TypeScript**
- **Drizzle ORM** + **PostgreSQL**
- **Passport.js** (autentica√ß√£o)
- **Express Session**
- **Multer** (uploads)
- **Sharp** (processamento de imagem)

### Servi√ßos Externos
- **Replit Auth** (OIDC)
- **Google Maps API**
- **Icecat Product Catalog**
- **MercadoLibre API**
- **Google Gemini AI**
- **Apify** (web scraping)
- **SerpAPI** (busca)

### Banco de Dados
- **PostgreSQL** (Neon serverless)
- **Drizzle Schema** com tipos TypeScript
- **Sess√µes persistentes**
- **√çndices otimizados**

## VARI√ÅVEIS DE AMBIENTE NECESS√ÅRIAS

```env
# Banco de dados
DATABASE_URL=postgresql://...
PGHOST=...
PGPORT=5432
PGUSER=...
PGPASSWORD=...
PGDATABASE=...

# Autentica√ß√£o Replit
REPLIT_DOMAINS=...
ISSUER_URL=https://replit.com/oidc
SESSION_SECRET=...

# APIs Externas
GEMINI_API_KEY=...
GOOGLE_API_KEY=...
SERPAPI_KEY=...
APIFY_TOKEN=...
ICECAT_API_TOKEN=...
ICECAT_CONTENT_TOKEN=...
ICECAT_USER=...
MERCADOLIVRE_CLIENT_ID=...

# Google Cloud
GCLOUD_PROJECT=...
GOOGLE_CLIENT_EMAIL=...
GOOGLE_PRIVATE_KEY=...

# APIs Opcionais
OPENAI_API_KEY=...
PEXELS_API_KEY=...
GOOGLE_CSE_ID=...
HUGGINGFACE_API_KEY=...
```

## COMO EXECUTAR

### Desenvolvimento
```bash
npm install
npm run db:push    # Configurar banco
npm run dev        # Iniciar servidor
```

### Produ√ß√£o
```bash
npm run build
npm start
```

### Deploy no Replit
1. Conectar reposit√≥rio
2. Configurar vari√°veis de ambiente
3. Executar automaticamente

## NOTAS IMPORTANTES

- **Sistema PWA completo** com offline support
- **Mapas integrados** em todas as p√°ginas de loja
- **Autentica√ß√£o h√≠brida** (Replit + local)
- **Sistema de promo√ß√µes** com raspadinhas
- **Analytics an√¥nimo** para m√©tricas
- **Compara√ß√£o de pre√ßos** internacional
- **Instagram Stories** integrado
- **Totem digital** para lojas f√≠sicas
- **Super Admin** para gest√£o global

Este c√≥digo representa uma aplica√ß√£o PWA completa e robusta para gerenciamento de ofertas e panfletos digitais no Paraguai, com funcionalidades avan√ßadas de e-commerce, mapas, autentica√ß√£o e analytics.